<!--
The MIT License (MIT)

Copyright (c) 2013 bill@bunkat.com

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
-->

<html>
<head>
<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
<meta content="utf-8" http-equiv="encoding">
    <style rel="stylesheet">
#chart {
    float: left;
}

#menu {
    float: right;
    width: 240px;
}

#to_main_menu_button {
    float: left;
    margin-left: -134px;
    margin-top: 2px;
}

#legend {
    float: right;
    width: 240px;
}

#legend .block {
    width: 230px;
}

#legend.collapsed p {
    margin-bottom: 5px;
}

#legend.collapsed p::before {
    float: left;
    font-size: 12px;
    content: '\a0+\a0';
    color: #DDD;
    cursor: pointer;
    border: 1px rgb(200, 200, 200) solid;
}

#legend.expanded p::before {
    float: left;
    font-size: 12px;
    content: '\a0\2212\a0';  /* &minus&nbsp */
    color: #DDD;
    cursor: pointer;
    border: 1px rgb(200, 200, 200) solid;
}

.collapsed svg {
    height: 0px;
}

.icarus_summary_content {
    margin-top: 40px;
}

.icarus_summary_content h3 {
    font-size: 1em;
    /*font-weight: bold;*/
    line-height: 3em;
}

.icarus_summary_content .assemblies_table td, .icarus_summary_content .assemblies_table th {
    padding-top: 10px;
}

.icarus_summary_content .contig_alignment_viewer_panel {
    margin-top: -4px;
}
.icarus_summary_content .contig_alignment_viewer_panel .reference_details {
    margin-left: 20px;
}
.icarus_summary_content .contig_alignment_viewer_panel p {
    line-height: 0.8em;
}

.summary_table {
    border-collapse: collapse;
    color: black;
    margin-right: auto;
}

.summary_table th {
    border-bottom: 1px solid #bcbcbc;
}

.summary_table th, .summary_table td {
    padding-right: 15px;
    text-align: left;
    padding-top: 5px;
}

.block {
    color: white;
    background: #444;
    padding: 5px;
    margin-top: 5px;
    overflow: hidden;
}

.menu_block {
    font-size: 16px;
    color: white;
    background: #444;
    padding: 5px;
    margin-top: 5px;
    overflow: hidden;
}

.head {
    margin-left: 10px;
    padding: 5px;
    border: 1px rgb(200, 200, 200) solid;
    display: block;
    word-wrap: break-word;
}

.head.main {
    margin-left: 0;
}

.head_plus.collapsed::before {
    float: left;
    margin-top: 3px;
    font-size: 12px;
    content: '+ ';
    color: #DDD;
    cursor: pointer;
}

.head_plus.expanded::before {
    float: left;
    margin-top: 3px;
    font-size: 12px;
    content: '\2212\a0';  /* &minus&nbsp */
    color: #DDD;
    cursor: pointer;
}

.open {
    padding-left: 10px;
    display: block;
}

.close {
    display: none;
}

span {
    font-size: 10px;
    text-align: left;
}

.title {
    font-size: 20px;
    text-align: center;
    font-weight: bold;
}

.subtitle {
    padding-top: 10px;
    padding-bottom: 10px;
    font-size: 18px;
}

.summary_table a {
    text-decoration: none;
    /*color: #0c4f72;*/
    color: #0077B5;
    border-bottom: 1px solid #487b95;
    border-color: #487b95; /* #487b95 */
    border-color: rgba(12, 79, 114, 0.2); /* #0c4f72; */ /* #a0d2eb; */ /*rgba(0, 88, cc, 0.3);*/
}
.summary_table a:visited {
    text-decoration: none;
    color: #8C66B2;
    border-bottom: 1px solid #8c66b2;
    border-color: #8c66b2;
    border-color: rgba(102, 51, 153, 0.2);
}
.summary_table a:hover {
    text-decoration: none;
    color: #b33; /* #0088cc; */
    border-bottom: 1px solid #ffcccc;
    border-color: #ffcccc;
    border-color: rgba(255, 0, 0, 0.2); /* #55b2e0; */ /*#005580;*/
}

.arrow {
    stroke: #666;
    stroke-width: 2;
}

.arrow_selected {
    stroke: #000;
    stroke-width: 2;
}

.COV .y {
    font: 12px sans-serif;
}

.COV .x path {
    stroke: black;
    stroke-width: 1px;
}

.COV .covered path {
    fill: #799FCA;
    opacity: .8;
}
.COV .notCovered path {
    stroke: blue;
    stroke-width: 5px;
}

.coverage text {
    font: 16px sans-serif;
}

.coverage .x path, .x line, .y path, .y line {
    fill: none;
    stroke: black;
    stroke-width: 1px;
}

.coverage .y text {
    font: 12px sans-serif;
}

.coverage .axis text {
    font: 12px sans-serif;
}

.coverage .covered {
    fill: #799FCA;
    opacity: .8;
}

.coverage .notCovered {
    stroke: rgb(10, 10, 240);
    stroke-width: 3px;
    fill: none;
}

.chart {
    shape-rendering: optimizeSpeed;
}

.legend {
    shape-rendering: geometricPrecision;
}

.mini text {
    font: 9px sans-serif;
}

.main text {
    font: 12px sans-serif;
}

.mainItem text {
    fill: black;
    stroke-width: 0;
}

.axis line, .axis path {
    stroke: black;
}

path {
    shape-rendering: optimizeSpeed;
}

.shadow_svg {
    -webkit-filter: drop-shadow( -2px 2px 1px #808080);
            filter: drop-shadow( -2px 2px 1px #808080);
}

.main_labels rect {
    fill: #fff;
}

.mainItem {
    stroke: black;
    fill: #059B00;
}
.miniItem {
    stroke-width: .3;
    stroke: #444;
    fill: #4daf4a;
}
.item.gradient {
    stroke-width: .3;
    stroke: #444;
}

.item.legend {
    stroke-width: 0;
}

.mainItem.similar {
    fill: #00817F;
}
.mainItem.misassembled {
    fill: #D00000;
}
.mainItem.misassembled.similar {
    fill: #D26200;
}
.mainItem.disabled {
    fill: #757575;
}
.mainItem.unaligned {
    fill: #757575;
}
.mainItem.unknown {
    fill: #528CA6;
}

.miniItem.similar {
    fill: #4b9493;
}
.miniItem.misassembled {
    fill: #DD4343;
}
.miniItem.misassembled.similar {
    fill: #dd6800;
}
.miniItem.disabled {
    fill: #8e8e8e;
}
.miniItem.unaligned {
    fill: #8e8e8e;
}
.miniItem.unknown {
    fill: #7DA6B9;
}


.end {
    stroke-width: 0;
    opacity: 0;
}
.end.misassembled {
    opacity: 1;
    fill: #7C0239;
}
.item.disabled.end {
    opacity: 0;
}

.dashed_lines {
	stroke: black;
	stroke-width: 1;
	stroke-dasharray: 3,2;
}

.miniItems.text {
    text-shadow: 1px 0 0 #000,
                -1px 0 0 #000,
                 0 1px 0 #000,
                0 -1px 0 #000,
                 1px 1px #000,
             -1px -1px 0 #000,
              1px -1px 0 #000,
              -1px 1px 0 #000;
}

.block_circle {
  width: 16px;
  height: 16px;
  -webkit-border-radius: 8px;
  -moz-border-radius: 8px;
  border-radius: 50%;
  background: darkgray;
  box-shadow: inset 3px 3px 4px #000;
  float: right;
  display: none;
}

.block_circle.selected {
  display: block;
}

.annotation {
    fill: #612B1C;
}

.annotation.odd {
    fill: #49190C;
}

.featureLabel {
    fill: #ffffcc;
    font-size: 8px;
    pointer-events: none;
}

.feature_tip {
  position: absolute;
  z-index: 100;
  text-align: center;
  padding: 2px;
  font: 11px sans-serif;
  background: lightgray;
  border: 1px black solid;
  border-radius: 8px;
  content: "\25BC";
}

.trackBtn {
    rx: 20;
    ry: 20;
    stroke: black;
    stroke-width: 1;
    fill: white;
}

.trackBtnText {
    font-size: 11px;
}

.trackBtn:hover {
    stroke: red;
    cursor: pointer;
}

.brush .extent {
    stroke: gray;
    fill: yellow;
    fill-opacity: .165;
}

.itemLabel {
    font-size: 12px;
}

.reftitle {
    font-size: 16px;
    /*font-weight: bold;*/
    /*text-align: center;*/
    padding-top: 10px;
    padding-bottom: 10px;
    margin-top: 5px;
}

.moving_button {
    -webkit-transition:all 200ms ease;
   -moz-transition:all 200ms ease;
    -ms-transition:all 200ms ease;
     -o-transition:all 200ms ease;
        transition:all 200ms ease;
}

.lane_tooltip {
    font-size: 13px;
}

.click_a_contig_text {
    text-align: center;
    color: #cdcdcd;
}

/*.layout-table {*/
    /*max-width: 940px;*/
/*}*/

#controls_panel {
    float: left;
    font-size: 13px;
    margin-left: 30px;
    /*margin-top: 7px;*/
}

/*#controls_panel button {*/
    /*margin-top: -3px;*/
/*}*/
#controls_panel * {
    vertical-align: baseline;
}
#controls_panel span {
    line-height: 250%;
}

/*#controls_panel span {*/
    /*margin-left: 7px;*/
/*}*/

#misassemblies_selector_panel label {
    margin-right: 10px;
    white-space: nowrap;
}

.ie_warning {
    background-color: yellow;
    height: 50px;
    font-size: 14px;
    text-align: center;
    padding-top: 15px;
}

</style>

    <style rel="stylesheet">
/* Main things */
html, body, div, span, h1, h3, h4, h5, h6, blockquote, pre,
em, sub, sup, dl, dt, dd, ol, ul, li,
fieldset, form, label,
table, caption, tbody, tfoot, thead,
article, aside, canvas, details, figure, figcaption, footer, header, hgroup,
menu, nav, output, section, time {
    margin: 0;
    padding: 0;
    border: 0;
    font-size: 100%;
    font: inherit;
    vertical-align: baseline;
}
body {
    margin: 0;
    font-family: Lucida Grande, Verdana, Arial, sans-serif;
    font-size: 12px;
    color: black;
    padding-bottom: 30px;
}
a {
    text-decoration: none;
    /*color: #0c4f72;*/
    color: #0077B5;
    border-bottom: 1px solid #487b95;
    border-color: #487b95; /* #487b95 */
    border-color: rgba(12, 79, 114, 0.2); /* #0c4f72; */ /* #a0d2eb; */ /*rgba(0, 88, cc, 0.3);*/
}
a:visited {
    text-decoration: none;
    color: #8C66B2;
    border-bottom: 1px solid #8c66b2;
    border-color: #8c66b2;
    border-color: rgba(102, 51, 153, 0.2);
}
a:hover {
    text-decoration: none;
    color: #b33; /* #0088cc; */
    border-bottom: 1px solid #ffcccc;
    border-color: #ffcccc;
    border-color: rgba(255, 0, 0, 0.2); /* #55b2e0; */ /*#005580;*/
}
a.dark_bg_link {
    color: white; /* #0088cc; */
    border-bottom: 1px solid #cccccc;
    border-color: #cccccc;
}
a.dark_bg_link:hover {
    color: white; /* #0088cc; */
    border-bottom: 1px solid white;
}

.leading_link_dot {
    border-bottom: white solid 1px;
}

a.header_link, a.header_link:hover, a.header_link:visited {
    color: black;
    border-bottom: 1px solid #bbb;
}


.dotted-link {
    cursor: pointer;
    text-decoration: none;
    /*color: #0c4f72;*/
    color: #0077B5;
    border-bottom: 1px dashed #487b95;
    border-color: #487b95; /* #487b95 */
    border-color: rgba(12, 79, 114, 0.2);
}
.dotted-link:hover {
    text-decoration: none;
    color: #b33 !important;
    border-bottom: 1px dashed #b33 !important;
    border-color: rgba(255, 0, 0, 0.2) !important;
}
.js:visited {
    color: #0077B5;
    border-bottom: 1px dashed #487b95;
    border-color: #487b95;
    border-color: rgba(12, 79, 114, 0.2);
}

.selected-switch {
    background-color: #fafad2;
}

.json-code {
    display: none;
}
.smallcapitals {
    font-size: .875em;
    letter-spacing: .15em;
    margin-right: -.15em;
}
.highlight {
    background-color:#FFF9B5;
    padding: 0 3px;
    margin-left: -3px;
}

ul.list {
    list-style-type: none;
    padding: 0 0 0 2em;
    margin: -0.5em 0 0 0;
}
ul.list li {
    margin-bottom: 0.7em;
}

ul.mdash {
    margin: -1em 0 0 0;
    padding: 0 0 0 2em;
}
ul.mdash li {
    margin-bottom: 0.7em;
    list-style-type: none;
    text-indent: -1.3em;
    behavior: expression(!this.before ? this.before = this.innerHTML = '&mdash;&nbsp;' + this.innerHTML : '');
}
ul.mdash li:before {
    content: '\2014\a0';
}

.small_line_indent {
    height: 0;
    margin-top: -7px;
}
/************/

/* Tooltips */
.tooltip {
    font-size: 0.9em;
    margin-bottom: 5px;
}
.tooltip.in {
    opacity: 1;
}
.tooltip-inner {
    text-align: left;
}
.tooltip-link,
.tooltip-link:visited {
    text-decoration: none;
    color: #000;
    border-bottom: 1px dashed #bbb;
    cursor: hand;
}
.tooltip-link:hover {
    text-decoration: none;
    color: #b33;
    border-bottom: 1px dashed #b33;
}
/************/

/*********/

.hs {
    /* Полупробел для
  разделения разрядов чисел:
  10<span class="hs"></span>000 */
    margin-left: .2em;
}

.rhs {
    /* Полупробел на случай,
  если реальный пробел важен,
  например между ценой и валютой:
  1<span class="rhs">&nbsp;</span>$ */
    font-size: 50%;
    line-height: 1;
}

/*9490<span class="rhs"> </span>€<br/>*/
/*12<span class="hs"></span>650<span class="rhs"> </span>$<br/>*/
/*379<span class="hs"></span>000<span*/
/*class="rhs"> </span><span class="b-rub">Р</span><br/>*/
/*100<span class="hs"></span>500<span class="rhs"> </span>+*/

/* for wrapping long words with no spaces */
/* http://stackoverflow.com/questions/3247358/css-how-do-i-wrap-text-with-no-whitespace-inside-a-td */
.wrapword {
    white-space: -moz-pre-wrap !important;  /* Mozilla, since 1999 */
    white-space: -pre-wrap;      /* Opera 4-6 */
    white-space: -o-pre-wrap;    /* Opera 7 */
    white-space: pre-wrap;       /* css-3 */
    word-wrap: break-word;       /* Internet Explorer 5.5+ */
    word-break: break-all;
    white-space: normal;
}


.space_1px {
    height: 1px;
}
.space_2px {
    height: 2px;
}
.space_3px {
    height: 3px;
}
.space_4px {
    height: 4px;
}
.space_5px {
    height: 5px;
}
.space_6px {
    height: 6px;
}
.space_7px {
    height: 7px;
}
.space_8px {
    height: 8px;
}
.space_9px {
    height: 9px;
}
.space_10px {
    height: 10px;
}
.layout-table {
    width: 99%;
    border-spacing: 0;
}

.layout-table td.layout-table-td {
    vertical-align: top;
    padding: 0;
}
.layout-table td.layout-table-fst-td {
    min-width: 400px;
    padding-right: 50px;
}
.layout-table td.layout-table-snd-td {
    min-width: 200px;
}
.layout-table td.layout-table-trd-td {
}

.top-panel {
    background-color: #444;
    color: white;
    min-width: 650px;
    padding: 8px 10px 0 147px;
    min-height: 70px;
    text-shadow: -1px -1px 0 #111;
}
.top-panel span {
    color: white;
}
.top-panel a {
    color: white;
    border-bottom: 1px solid white;
}
#to_main_menu_button a {
    border-bottom: none;
}
.page_title {
    margin-top: -3px;
    margin-bottom: -3px;
    color: white;
}
.page_subtitle {
    line-height: 100%;
}
.content {
    margin-left: 147px;
    width: 90%;
    /*padding-top: 20px;*/
    margin-bottom: 0;
    /*padding-bottom: 50px;*/
/*{#        padding-right: 20px;#}*/
}
.p_after_content {
    margin-left: 147px;
}
.links_after_content{
    font-size: 14px;
}

p {
    display: block;
    font-size: 12px;
}

h1 {
    display: block;
    font-size: 26px;
    padding: 0 -3px 0 5px;
    -webkit-margin-before: 5px;
    -webkit-margin-after: 0px;
    -webkit-margin-start: 0px;
    -webkit-margin-end: 0px;
    font-weight: bold;
}

#header {
    display: block;
    width: 100%;
    margin-bottom: 10px;
}
</style>

    <style rel="stylesheet">

.btn {
    display: inline-block;
    *display: inline;
    padding: 4px 10px 4px;
    margin-bottom: 0;
    *margin-left: .3em;
    font-size: 13px;
    line-height: 18px;
    *line-height: 20px;
    color: #333333;
    text-align: center;
    text-shadow: 0 1px 1px rgba(255, 255, 255, 0.75);
    vertical-align: middle;
    cursor: pointer;
    background-color: #f5f5f5;
    *background-color: #e6e6e6;
    background-image: -ms-linear-gradient(top, #ffffff, #e6e6e6);
    background-image: -webkit-gradient(linear, 0 0, 0 100%, from(#ffffff), to(#e6e6e6));
    background-image: -webkit-linear-gradient(top, #ffffff, #e6e6e6);
    background-image: -o-linear-gradient(top, #ffffff, #e6e6e6);
    background-image: linear-gradient(top, #ffffff, #e6e6e6);
    background-image: -moz-linear-gradient(top, #ffffff, #e6e6e6);
    background-repeat: repeat-x;
    border: 1px solid #cccccc;
    *border: 0;
    border-color: rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.25);
    border-color: #e6e6e6 #e6e6e6 #bfbfbf;
    border-bottom-color: #b3b3b3;
    -webkit-border-radius: 4px;
    -moz-border-radius: 4px;
    border-radius: 4px;
    filter: progid:dximagetransform.microsoft.gradient(startColorstr='#ffffff', endColorstr='#e6e6e6', GradientType=0);
    filter: progid:dximagetransform.microsoft.gradient(enabled=false);
    *zoom: 1;
    -webkit-box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 1px 2px rgba(0, 0, 0, 0.05);
    -moz-box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 1px 2px rgba(0, 0, 0, 0.05);
    box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 1px 2px rgba(0, 0, 0, 0.05);
}

.btn:hover,
.btn:active,
.btn.active,
.btn.disabled,
.btn[disabled] {
    background-color: #e6e6e6;
    *background-color: #d9d9d9;
}

.btn:active,
.btn.active {
    background-color: #cccccc \9;
}

.btn:first-child {
    *margin-left: 0;
}

.btn:hover {
    color: #333333;
    text-decoration: none;
    background-color: #e6e6e6;
    *background-color: #d9d9d9;
    /* Buttons in IE7 don't get borders, so darken on hover */

    background-position: 0 -15px;
    -webkit-transition: background-position 0.1s linear;
    -moz-transition: background-position 0.1s linear;
    -ms-transition: background-position 0.1s linear;
    -o-transition: background-position 0.1s linear;
    transition: background-position 0.1s linear;
}

.btn:focus {
    outline: thin dotted #333;
    outline: 5px auto -webkit-focus-ring-color;
    outline-offset: -2px;
}

.btn.active,
.btn:active {
    background-color: #e6e6e6;
    background-color: #d9d9d9 \9;
    background-image: none;
    outline: 0;
    -webkit-box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.15), 0 1px 2px rgba(0, 0, 0, 0.05);
    -moz-box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.15), 0 1px 2px rgba(0, 0, 0, 0.05);
    box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.15), 0 1px 2px rgba(0, 0, 0, 0.05);
}

.btn.disabled,
.btn[disabled] {
    cursor: default;
    background-color: #e6e6e6;
    background-image: none;
    opacity: 0.65;
    filter: alpha(opacity=65);
    -webkit-box-shadow: none;
    -moz-box-shadow: none;
    box-shadow: none;
}

.btn-large {
    padding: 9px 14px;
    font-size: 15px;
    line-height: normal;
    -webkit-border-radius: 5px;
    -moz-border-radius: 5px;
    border-radius: 5px;
}

.btn-large [class^="icon-"] {
    margin-top: 1px;
}

.btn-small {
    padding: 5px 9px;
    font-size: 11px;
    line-height: 16px;
}

.btn-small [class^="icon-"] {
    margin-top: -1px;
}

.btn-mini {
    padding: 2px 6px;
    font-size: 11px;
    line-height: 14px;
}

.btn-primary,
.btn-primary:hover,
.btn-warning,
.btn-warning:hover,
.btn-danger,
.btn-danger:hover,
.btn-success,
.btn-success:hover,
.btn-info,
.btn-info:hover,
.btn-inverse,
.btn-inverse:hover {
    color: #ffffff;
    text-shadow: 0 -1px 0 rgba(0, 0, 0, 0.25);
}

.btn-primary.active,
.btn-warning.active,
.btn-danger.active,
.btn-success.active,
.btn-info.active,
.btn-inverse.active {
    color: rgba(255, 255, 255, 0.75);
}

.btn {
    border-color: #ccc;
    border-color: rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.25);
}

.btn-primary {
    background-color: #0074cc;
    *background-color: #0055cc;
    background-image: -ms-linear-gradient(top, #0088cc, #0055cc);
    background-image: -webkit-gradient(linear, 0 0, 0 100%, from(#0088cc), to(#0055cc));
    background-image: -webkit-linear-gradient(top, #0088cc, #0055cc);
    background-image: -o-linear-gradient(top, #0088cc, #0055cc);
    background-image: -moz-linear-gradient(top, #0088cc, #0055cc);
    background-image: linear-gradient(top, #0088cc, #0055cc);
    background-repeat: repeat-x;
    border-color: #0055cc #0055cc #003580;
    border-color: rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.25);
    filter: progid:dximagetransform.microsoft.gradient(startColorstr='#0088cc', endColorstr='#0055cc', GradientType=0);
    filter: progid:dximagetransform.microsoft.gradient(enabled=false);
}

.btn-primary:hover,
.btn-primary:active,
.btn-primary.active,
.btn-primary.disabled,
.btn-primary[disabled] {
    background-color: #0055cc;
    *background-color: #004ab3;
}

.btn-primary:active,
.btn-primary.active {
    background-color: #004099 \9;
}

.btn-warning {
    background-color: #faa732;
    *background-color: #f89406;
    background-image: -ms-linear-gradient(top, #fbb450, #f89406);
    background-image: -webkit-gradient(linear, 0 0, 0 100%, from(#fbb450), to(#f89406));
    background-image: -webkit-linear-gradient(top, #fbb450, #f89406);
    background-image: -o-linear-gradient(top, #fbb450, #f89406);
    background-image: -moz-linear-gradient(top, #fbb450, #f89406);
    background-image: linear-gradient(top, #fbb450, #f89406);
    background-repeat: repeat-x;
    border-color: #f89406 #f89406 #ad6704;
    border-color: rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.25);
    filter: progid:dximagetransform.microsoft.gradient(startColorstr='#fbb450', endColorstr='#f89406', GradientType=0);
    filter: progid:dximagetransform.microsoft.gradient(enabled=false);
}

.btn-warning:hover,
.btn-warning:active,
.btn-warning.active,
.btn-warning.disabled,
.btn-warning[disabled] {
    background-color: #f89406;
    *background-color: #df8505;
}

.btn-warning:active,
.btn-warning.active {
    background-color: #c67605 \9;
}

.btn-danger {
    background-color: #da4f49;
    *background-color: #bd362f;
    background-image: -ms-linear-gradient(top, #ee5f5b, #bd362f);
    background-image: -webkit-gradient(linear, 0 0, 0 100%, from(#ee5f5b), to(#bd362f));
    background-image: -webkit-linear-gradient(top, #ee5f5b, #bd362f);
    background-image: -o-linear-gradient(top, #ee5f5b, #bd362f);
    background-image: -moz-linear-gradient(top, #ee5f5b, #bd362f);
    background-image: linear-gradient(top, #ee5f5b, #bd362f);
    background-repeat: repeat-x;
    border-color: #bd362f #bd362f #802420;
    border-color: rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.25);
    filter: progid:dximagetransform.microsoft.gradient(startColorstr='#ee5f5b', endColorstr='#bd362f', GradientType=0);
    filter: progid:dximagetransform.microsoft.gradient(enabled=false);
}

.btn-danger:hover,
.btn-danger:active,
.btn-danger.active,
.btn-danger.disabled,
.btn-danger[disabled] {
    background-color: #bd362f;
    *background-color: #a9302a;
}

.btn-danger:active,
.btn-danger.active {
    background-color: #942a25 \9;
}

.btn-success {
    background-color: #5bb75b;
    *background-color: #51a351;
    background-image: -ms-linear-gradient(top, #62c462, #51a351);
    background-image: -webkit-gradient(linear, 0 0, 0 100%, from(#62c462), to(#51a351));
    background-image: -webkit-linear-gradient(top, #62c462, #51a351);
    background-image: -o-linear-gradient(top, #62c462, #51a351);
    background-image: -moz-linear-gradient(top, #62c462, #51a351);
    background-image: linear-gradient(top, #62c462, #51a351);
    background-repeat: repeat-x;
    border-color: #51a351 #51a351 #387038;
    border-color: rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.25);
    filter: progid:dximagetransform.microsoft.gradient(startColorstr='#62c462', endColorstr='#51a351', GradientType=0);
    filter: progid:dximagetransform.microsoft.gradient(enabled=false);
}

.btn-success:hover,
.btn-success:active,
.btn-success.active,
.btn-success.disabled,
.btn-success[disabled] {
    background-color: #51a351;
    *background-color: #499249;
}

.btn-success:active,
.btn-success.active {
    background-color: #408140 \9;
}

.btn-info {
    background-color: #49afcd;
    *background-color: #2f96b4;
    background-image: -ms-linear-gradient(top, #5bc0de, #2f96b4);
    background-image: -webkit-gradient(linear, 0 0, 0 100%, from(#5bc0de), to(#2f96b4));
    background-image: -webkit-linear-gradient(top, #5bc0de, #2f96b4);
    background-image: -o-linear-gradient(top, #5bc0de, #2f96b4);
    background-image: -moz-linear-gradient(top, #5bc0de, #2f96b4);
    background-image: linear-gradient(top, #5bc0de, #2f96b4);
    background-repeat: repeat-x;
    border-color: #2f96b4 #2f96b4 #1f6377;
    border-color: rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.25);
    filter: progid:dximagetransform.microsoft.gradient(startColorstr='#5bc0de', endColorstr='#2f96b4', GradientType=0);
    filter: progid:dximagetransform.microsoft.gradient(enabled=false);
}

.btn-info:hover,
.btn-info:active,
.btn-info.active,
.btn-info.disabled,
.btn-info[disabled] {
    background-color: #2f96b4;
    *background-color: #2a85a0;
}

.btn-info:active,
.btn-info.active {
    background-color: #24748c \9;
}

.btn-inverse {
    background-color: #414141;
    *background-color: #222222;
    background-image: -ms-linear-gradient(top, #555555, #222222);
    background-image: -webkit-gradient(linear, 0 0, 0 100%, from(#555555), to(#222222));
    background-image: -webkit-linear-gradient(top, #555555, #222222);
    background-image: -o-linear-gradient(top, #555555, #222222);
    background-image: -moz-linear-gradient(top, #555555, #222222);
    background-image: linear-gradient(top, #555555, #222222);
    background-repeat: repeat-x;
    border-color: #222222 #222222 #000000;
    border-color: rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.25);
    filter: progid:dximagetransform.microsoft.gradient(startColorstr='#555555', endColorstr='#222222', GradientType=0);
    filter: progid:dximagetransform.microsoft.gradient(enabled=false);
}

.btn-inverse:hover,
.btn-inverse:active,
.btn-inverse.active,
.btn-inverse.disabled,
.btn-inverse[disabled] {
    background-color: #222222;
    *background-color: #151515;
}

.btn-inverse:active,
.btn-inverse.active {
    background-color: #080808 \9;
}

button.btn,
input[type="submit"].btn {
    *padding-top: 2px;
    *padding-bottom: 2px;
}

button.btn::-moz-focus-inner,
input[type="submit"].btn::-moz-focus-inner {
    padding: 0;
    border: 0;
}

button.btn.btn-large,
input[type="submit"].btn.btn-large {
    *padding-top: 7px;
    *padding-bottom: 7px;
}

button.btn.btn-small,
input[type="submit"].btn.btn-small {
    *padding-top: 3px;
    *padding-bottom: 3px;
}

button.btn.btn-mini,
input[type="submit"].btn.btn-mini {
    *padding-top: 1px;
    *padding-bottom: 1px;
}

.btn-group {
    position: relative;
    *margin-left: .3em;
    *zoom: 1;
}

.btn-group:before,
.btn-group:after {
    display: table;
    content: "";
}

.btn-group:after {
    clear: both;
}

.btn-group:first-child {
    *margin-left: 0;
}

.btn-group + .btn-group {
    margin-left: 5px;
}

.btn-toolbar {
    margin-top: 9px;
    margin-bottom: 9px;
}

.btn-toolbar .btn-group {
    display: inline-block;
    *display: inline;
    /* IE7 inline-block hack */

    *zoom: 1;
}

.btn-group > .btn {
    position: relative;
    float: left;
    margin-left: -1px;
    -webkit-border-radius: 0;
    -moz-border-radius: 0;
    border-radius: 0;
}

.btn-group > .btn:first-child {
    margin-left: 0;
    -webkit-border-bottom-left-radius: 4px;
    border-bottom-left-radius: 4px;
    -webkit-border-top-left-radius: 4px;
    border-top-left-radius: 4px;
    -moz-border-radius-bottomleft: 4px;
    -moz-border-radius-topleft: 4px;
}

.btn-group > .btn:last-child,
.btn-group > .dropdown-toggle {
    -webkit-border-top-right-radius: 4px;
    border-top-right-radius: 4px;
    -webkit-border-bottom-right-radius: 4px;
    border-bottom-right-radius: 4px;
    -moz-border-radius-topright: 4px;
    -moz-border-radius-bottomright: 4px;
}

.btn-group > .btn.large:first-child {
    margin-left: 0;
    -webkit-border-bottom-left-radius: 6px;
    border-bottom-left-radius: 6px;
    -webkit-border-top-left-radius: 6px;
    border-top-left-radius: 6px;
    -moz-border-radius-bottomleft: 6px;
    -moz-border-radius-topleft: 6px;
}

.btn-group > .btn.large:last-child,
.btn-group > .large.dropdown-toggle {
    -webkit-border-top-right-radius: 6px;
    border-top-right-radius: 6px;
    -webkit-border-bottom-right-radius: 6px;
    border-bottom-right-radius: 6px;
    -moz-border-radius-topright: 6px;
    -moz-border-radius-bottomright: 6px;
}

.btn-group > .btn:hover,
.btn-group > .btn:focus,
.btn-group > .btn:active,
.btn-group > .btn.active {
    z-index: 2;
}

.btn-group .dropdown-toggle:active,
.btn-group.open .dropdown-toggle {
    outline: 0;
}

.btn-group > .dropdown-toggle {
    *padding-top: 4px;
    padding-right: 8px;
    *padding-bottom: 4px;
    padding-left: 8px;
    -webkit-box-shadow: inset 1px 0 0 rgba(255, 255, 255, 0.125), inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 1px 2px rgba(0, 0, 0, 0.05);
    -moz-box-shadow: inset 1px 0 0 rgba(255, 255, 255, 0.125), inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 1px 2px rgba(0, 0, 0, 0.05);
    box-shadow: inset 1px 0 0 rgba(255, 255, 255, 0.125), inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 1px 2px rgba(0, 0, 0, 0.05);
}

.btn-group > .btn-mini.dropdown-toggle {
    padding-right: 5px;
    padding-left: 5px;
}

.btn-group > .btn-small.dropdown-toggle {
    *padding-top: 4px;
    *padding-bottom: 4px;
}

.btn-group > .btn-large.dropdown-toggle {
    padding-right: 12px;
    padding-left: 12px;
}

.btn-group.open .dropdown-toggle {
    background-image: none;
    -webkit-box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.15), 0 1px 2px rgba(0, 0, 0, 0.05);
    -moz-box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.15), 0 1px 2px rgba(0, 0, 0, 0.05);
    box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.15), 0 1px 2px rgba(0, 0, 0, 0.05);
}

.btn-group.open .btn.dropdown-toggle {
    background-color: #e6e6e6;
}

.btn-group.open .btn-primary.dropdown-toggle {
    background-color: #0055cc;
}

.btn-group.open .btn-warning.dropdown-toggle {
    background-color: #f89406;
}

.btn-group.open .btn-danger.dropdown-toggle {
    background-color: #bd362f;
}

.btn-group.open .btn-success.dropdown-toggle {
    background-color: #51a351;
}

.btn-group.open .btn-info.dropdown-toggle {
    background-color: #2f96b4;
}

.btn-group.open .btn-inverse.dropdown-toggle {
    background-color: #222222;
}

.btn .caret {
    margin-top: 7px;
    margin-left: 0;
}

.btn:hover .caret,
.open.btn-group .caret {
    opacity: 1;
    filter: alpha(opacity=100);
}

.btn-mini .caret {
    margin-top: 5px;
}

.btn-small .caret {
    margin-top: 6px;
}

.btn-large .caret {
    margin-top: 6px;
    border-top-width: 5px;
    border-right-width: 5px;
    border-left-width: 5px;
}

.dropup .btn-large .caret {
    border-top: 0;
    border-bottom: 5px solid #000000;
}

.btn-primary .caret,
.btn-warning .caret,
.btn-danger .caret,
.btn-info .caret,
.btn-success .caret,
.btn-inverse .caret {
    border-top-color: #ffffff;
    border-bottom-color: #ffffff;
    opacity: 0.75;
    filter: alpha(opacity=75);
}


.modal-open .dropdown-menu {
    z-index: 2050;
}

.modal-open .dropdown.open {
    *z-index: 2050;
}

.modal-open .popover {
    z-index: 2060;
}

.modal-open .tooltip {
    z-index: 2070;
}

.modal-backdrop {
    position: fixed;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    z-index: 1040;
    background-color: #000000;
}

.modal-backdrop.fade {
    opacity: 0;
}

.modal-backdrop,
.modal-backdrop.fade.in {
    opacity: 0.8;
    filter: alpha(opacity=80);
}

.modal {
    position: fixed;
    top: 50%;
    left: 50%;
    z-index: 1050;
    width: 560px;
    margin: -250px 0 0 -280px;
    overflow: auto;
    background-color: #ffffff;
    border: 1px solid #999;
    border: 1px solid rgba(0, 0, 0, 0.3);
    *border: 1px solid #999;
    -webkit-border-radius: 6px;
    -moz-border-radius: 6px;
    border-radius: 6px;
    -webkit-box-shadow: 0 3px 7px rgba(0, 0, 0, 0.3);
    -moz-box-shadow: 0 3px 7px rgba(0, 0, 0, 0.3);
    box-shadow: 0 3px 7px rgba(0, 0, 0, 0.3);
    -webkit-background-clip: padding-box;
    -moz-background-clip: padding-box;
    background-clip: padding-box;
}

.modal.fade {
    top: -25%;
    -webkit-transition: opacity 0.3s linear, top 0.3s ease-out;
    -moz-transition: opacity 0.3s linear, top 0.3s ease-out;
    -ms-transition: opacity 0.3s linear, top 0.3s ease-out;
    -o-transition: opacity 0.3s linear, top 0.3s ease-out;
    transition: opacity 0.3s linear, top 0.3s ease-out;
}

.modal.fade.in {
    top: 50%;
}

.modal-header {
    padding: 9px 15px;
    border-bottom: 1px solid #eee;
}

.modal-header .close {
    margin-top: 2px;
}

.modal-body {
    max-height: 400px;
    padding: 15px;
    overflow-y: auto;
}

.modal-form {
    margin-bottom: 0;
}

.modal-footer {
    padding: 14px 15px 15px;
    margin-bottom: 0;
    text-align: right;
    background-color: #f5f5f5;
    border-top: 1px solid #ddd;
    -webkit-border-radius: 0 0 6px 6px;
    -moz-border-radius: 0 0 6px 6px;
    border-radius: 0 0 6px 6px;
    *zoom: 1;
    -webkit-box-shadow: inset 0 1px 0 #ffffff;
    -moz-box-shadow: inset 0 1px 0 #ffffff;
    box-shadow: inset 0 1px 0 #ffffff;
}

.modal-footer:before,
.modal-footer:after {
    display: table;
    content: "";
}

.modal-footer:after {
    clear: both;
}

.modal-footer .btn + .btn {
    margin-bottom: 0;
    margin-left: 5px;
}

.modal-footer .btn-group .btn + .btn {
    margin-left: -1px;
}

.tooltip {
    position: absolute;
    z-index: 1020;
    display: block;
    padding: 5px;
    font-size: 11px;
    opacity: 0;
    visibility: visible;
    filter: alpha(opacity=0);
}

.tooltip.in {
    opacity: 0.8;
    filter: alpha(opacity=80);
}

.tooltip.top {
    margin-top: -2px;
}

.tooltip.right {
    margin-left: 2px;
}

.tooltip.bottom {
    margin-top: 2px;
}

.tooltip.left {
    margin-left: -2px;
}

.tooltip.top .tooltip-arrow {
    bottom: 0;
    left: 50%;
    margin-left: -5px;
    border-top: 5px solid #000000;
    border-right: 5px solid transparent;
    border-left: 5px solid transparent;
}

.tooltip.left .tooltip-arrow {
    top: 50%;
    right: 0;
    margin-top: -5px;
    border-top: 5px solid transparent;
    border-bottom: 5px solid transparent;
    border-left: 5px solid #000000;
}

.tooltip.bottom .tooltip-arrow {
    top: 0;
    left: 50%;
    margin-left: -5px;
    border-right: 5px solid transparent;
    border-bottom: 5px solid #000000;
    border-left: 5px solid transparent;
}

.tooltip.right .tooltip-arrow {
    top: 50%;
    left: 0;
    margin-top: -5px;
    border-top: 5px solid transparent;
    border-right: 5px solid #000000;
    border-bottom: 5px solid transparent;
}

.tooltip-inner {
    max-width: 200px;
    padding: 3px 8px;
    color: #ffffff;
    text-align: center;
    text-decoration: none;
    background-color: #000000;
    -webkit-border-radius: 4px;
    -moz-border-radius: 4px;
    border-radius: 4px;
}

.tooltip-arrow {
    position: absolute;
    width: 0;
    height: 0;
}

.popover {
    position: absolute;
    top: 0;
    left: 0;
    z-index: 1010;
    display: none;
    padding: 5px;
}

.popover.top {
    margin-top: -5px;
}

.popover.right {
    margin-left: 5px;
}

.popover.bottom {
    margin-top: 5px;
}

.popover.left {
    margin-left: -5px;
}

.popover.top .arrow {
    bottom: 0;
    left: 50%;
    margin-left: -5px;
    border-top: 5px solid #000000;
    border-right: 5px solid transparent;
    border-left: 5px solid transparent;
}

.popover.right .arrow {
    top: 50%;
    left: 0;
    margin-top: -5px;
    border-top: 5px solid transparent;
    border-right: 5px solid #000000;
    border-bottom: 5px solid transparent;
}

.popover.bottom .arrow {
    top: 0;
    left: 50%;
    margin-left: -5px;
    border-right: 5px solid transparent;
    border-bottom: 5px solid #000000;
    border-left: 5px solid transparent;
}

.popover.left .arrow {
    top: 50%;
    right: 0;
    margin-top: -5px;
    border-top: 5px solid transparent;
    border-bottom: 5px solid transparent;
    border-left: 5px solid #000000;
}

.popover .arrow {
    position: absolute;
    width: 0;
    height: 0;
}

.popover-inner {
    width: 280px;
    padding: 3px;
    overflow: hidden;
    background: #000000;
    background: rgba(0, 0, 0, 0.8);
    -webkit-border-radius: 6px;
    -moz-border-radius: 6px;
    border-radius: 6px;
    -webkit-box-shadow: 0 3px 7px rgba(0, 0, 0, 0.3);
    -moz-box-shadow: 0 3px 7px rgba(0, 0, 0, 0.3);
    box-shadow: 0 3px 7px rgba(0, 0, 0, 0.3);
}

.popover-title {
    padding: 9px 15px;
    line-height: 1;
    background-color: #f5f5f5;
    border-bottom: 1px solid #eee;
    -webkit-border-radius: 3px 3px 0 0;
    -moz-border-radius: 3px 3px 0 0;
    border-radius: 3px 3px 0 0;
}

.popover-content {
    padding: 14px;
    background-color: #ffffff;
    -webkit-border-radius: 0 0 3px 3px;
    -moz-border-radius: 0 0 3px 3px;
    border-radius: 0 0 3px 3px;
    -webkit-background-clip: padding-box;
    -moz-background-clip: padding-box;
    background-clip: padding-box;
}

.popover-content p,
.popover-content ul,
.popover-content ol {
    margin-bottom: 0;
}

.pull-right {
    float: right;
}

.pull-left {
    float: left;
}

.hide {
    display: none;
}

.show {
    display: block;
}

.invisible {
    visibility: hidden;
}

</style>

</head>
<body>
<!--[if lt IE 9]>
<div class="ie_warning">
    Your browser is not supported, please use Internet Explorer 9, Firefox, Safari or Google Chrome (recommended).
</div>
<![endif]-->
<div class="top-panel">
	<table class="layout-table">
		<tr>
		<td class='layout-table-td'>
            <div class="btn btn-inverse" id="to_main_menu_button">
                <a href="../icarus.html">Main menu</a>
            </div>
            <div class="page_title">
                <h1>
                    Icarus
                </h1>
                <p class="page_subtitle">
                    <b>QUAST Contig Browser</b>
                </p>
            </div>
		</td>
        <td class="layout-table-td">
            <div id='controls_panel'>
                <span style="white-space: nowrap;">
                    Move
                    <button id="left_shift" class="btn btn-inverse"><<</button>
                    <button id="left" class="btn btn-inverse"><</button>
                    <button id="right" class="btn btn-inverse">></button>
                    <button id="right_shift" class="btn btn-inverse">>></button>
                </span>
                <span style="white-space: nowrap; margin-left: 7px">
                    zoom
                    <button id="zoom_in_5" class="btn btn-inverse">+<span class="rhs"></span>5x</button>
                    <button id="zoom_in" class="btn btn-inverse">+<span class="rhs"></span>2x</button>
                    <button id="zoom_out" class="btn btn-inverse">–<span class="rhs"></span>2x</button>
                    <button id="zoom_out_5" class="btn btn-inverse">–<span class="rhs"></span>5x</button>
                </span>
                <span style="white-space: nowrap; margin-left: 7px">
                    go to coordinate <input class="textBox" id="input_coords" type="text" maxlength="30" />
                </span>
                <br>
                <span style="white-space: nowrap;">
                    Fade contigs shorter than <input class="textBox" id="input_contig_threshold" type="text" size="5" /> bp </span>
                </span>
                <span id="misassemblies_selector_panel">
                    
                </span>
			</div>
		</tr>
	</table>
</div>
<div class="content" style="padding-bottom: 0;">
    <div class="reftitle"><b>Contig size viewer</b>. For better performance, only largest 1000 contigs of each assembly were loaded</div>
    
</div>

<button id="hideBtnAnnoMini" class="btn moving_button btn-mini" style="display: none; position: absolute;">Hide</button>
<button id="hideBtnAnnoMain" class="btn moving_button btn-mini" style="display: none; position: absolute;">Show annotation</button>
<button id="hideBtnCovMini" class="btn moving_button btn-mini" style="display: none; position: absolute;">Hide</button>
<button id="hideBtnCovMain" class="btn moving_button btn-mini" style="display: none; position: absolute;">Show coverage</button>
<script type="text/javascript">
	window.onbeforeunload = function(){
		window.scrollTo(0,0);
	}
</script>
<script type="text/javascript">
    
    var assemblies_links = {};
var assemblies_len = {};
var assemblies_contigs = {};
var assemblies_misassemblies = {};
var assemblies_n50 = {};
assemblies_len["final_assembly"] = 674983205;
assemblies_contigs["final_assembly"] = 256913;
assemblies_n50["final_assembly"] = "3183";
var contig_data = {};
var chromosome;
contig_data["final_assembly"] = [ 
{name: "NODE_1_length_309697_cov_22.909544",size: 309697,contig_type: "",structure: []},
{name: "NODE_2_length_301284_cov_28.150095",size: 301284,contig_type: "",structure: []},
{name: "NODE_3_length_273391_cov_19.717363",size: 273391,contig_type: "",structure: []},
{name: "NODE_4_length_250963_cov_24.868781",size: 250963,contig_type: "",structure: []},
{name: "NODE_5_length_241511_cov_18.423386",size: 241511,contig_type: "",structure: []},
{name: "NODE_6_length_240506_cov_673.495976",size: 240506,contig_type: "",structure: []},
{name: "NODE_7_length_230422_cov_20.803279",size: 230422,contig_type: "",structure: []},
{name: "NODE_8_length_215276_cov_82.460299",size: 215276,contig_type: "",structure: []},
{name: "NODE_9_length_210145_cov_7.455034",size: 210145,contig_type: "",structure: []},
{name: "NODE_10_length_202336_cov_654.718599",size: 202336,contig_type: "",structure: []},
{name: "NODE_11_length_202111_cov_34.334793",size: 202111,contig_type: "",structure: []},
{name: "NODE_12_length_195282_cov_27.719941",size: 195282,contig_type: "",structure: []},
{name: "NODE_13_length_190748_cov_25.276371",size: 190748,contig_type: "",structure: []},
{name: "NODE_14_length_190215_cov_71.739782",size: 190215,contig_type: "",structure: []},
{name: "NODE_15_length_187619_cov_674.865870",size: 187619,contig_type: "",structure: []},
{name: "NODE_16_length_187616_cov_25.285987",size: 187616,contig_type: "",structure: []},
{name: "NODE_17_length_180428_cov_649.855477",size: 180428,contig_type: "",structure: []},
{name: "NODE_18_length_175702_cov_17.213787",size: 175702,contig_type: "",structure: []},
{name: "NODE_19_length_173052_cov_29.748741",size: 173052,contig_type: "",structure: []},
{name: "NODE_20_length_171045_cov_31.574589",size: 171045,contig_type: "",structure: []},
{name: "NODE_21_length_170187_cov_10.894170",size: 170187,contig_type: "",structure: []},
{name: "NODE_22_length_167677_cov_662.771080",size: 167677,contig_type: "",structure: []},
{name: "NODE_23_length_166300_cov_23.446702",size: 166300,contig_type: "",structure: []},
{name: "NODE_24_length_164261_cov_620.854025",size: 164261,contig_type: "",structure: []},
{name: "NODE_25_length_162795_cov_16.104369",size: 162795,contig_type: "",structure: []},
{name: "NODE_26_length_161470_cov_76.665372",size: 161470,contig_type: "",structure: []},
{name: "NODE_27_length_159837_cov_15.521335",size: 159837,contig_type: "",structure: []},
{name: "NODE_28_length_156744_cov_33.075819",size: 156744,contig_type: "",structure: []},
{name: "NODE_29_length_151994_cov_695.851322",size: 151994,contig_type: "",structure: []},
{name: "NODE_30_length_151643_cov_33.592079",size: 151643,contig_type: "",structure: []},
{name: "NODE_31_length_149540_cov_27.515858",size: 149540,contig_type: "",structure: []},
{name: "NODE_32_length_148373_cov_28.261364",size: 148373,contig_type: "",structure: []},
{name: "NODE_33_length_146975_cov_28.384019",size: 146975,contig_type: "",structure: []},
{name: "NODE_34_length_146734_cov_21.196824",size: 146734,contig_type: "",structure: []},
{name: "NODE_35_length_146383_cov_18.326499",size: 146383,contig_type: "",structure: []},
{name: "NODE_36_length_144050_cov_656.940109",size: 144050,contig_type: "",structure: []},
{name: "NODE_37_length_143658_cov_28.537948",size: 143658,contig_type: "",structure: []},
{name: "NODE_38_length_143326_cov_43.188531",size: 143326,contig_type: "",structure: []},
{name: "NODE_39_length_143184_cov_19.648646",size: 143184,contig_type: "",structure: []},
{name: "NODE_40_length_142318_cov_60.849047",size: 142318,contig_type: "",structure: []},
{name: "NODE_41_length_141950_cov_27.172557",size: 141950,contig_type: "",structure: []},
{name: "NODE_42_length_140087_cov_670.028222",size: 140087,contig_type: "",structure: []},
{name: "NODE_43_length_140083_cov_27.472934",size: 140083,contig_type: "",structure: []},
{name: "NODE_44_length_140001_cov_16.966044",size: 140001,contig_type: "",structure: []},
{name: "NODE_45_length_139764_cov_68.674402",size: 139764,contig_type: "",structure: []},
{name: "NODE_46_length_139733_cov_56.774030",size: 139733,contig_type: "",structure: []},
{name: "NODE_47_length_139656_cov_22.610361",size: 139656,contig_type: "",structure: []},
{name: "NODE_48_length_139514_cov_25.349149",size: 139514,contig_type: "",structure: []},
{name: "NODE_49_length_139467_cov_655.558187",size: 139467,contig_type: "",structure: []},
{name: "NODE_50_length_139192_cov_666.344948",size: 139192,contig_type: "",structure: []},
{name: "NODE_51_length_139048_cov_19.671609",size: 139048,contig_type: "",structure: []},
{name: "NODE_52_length_137271_cov_25.395515",size: 137271,contig_type: "",structure: []},
{name: "NODE_53_length_136760_cov_73.326594",size: 136760,contig_type: "",structure: []},
{name: "NODE_54_length_135906_cov_69.583286",size: 135906,contig_type: "",structure: []},
{name: "NODE_55_length_135521_cov_17.937822",size: 135521,contig_type: "",structure: []},
{name: "NODE_56_length_134941_cov_75.108484",size: 134941,contig_type: "",structure: []},
{name: "NODE_57_length_133765_cov_28.200322",size: 133765,contig_type: "",structure: []},
{name: "NODE_58_length_133013_cov_677.468216",size: 133013,contig_type: "",structure: []},
{name: "NODE_59_length_132663_cov_21.171709",size: 132663,contig_type: "",structure: []},
{name: "NODE_60_length_132207_cov_18.962150",size: 132207,contig_type: "",structure: []},
{name: "NODE_61_length_130572_cov_20.434219",size: 130572,contig_type: "",structure: []},
{name: "NODE_62_length_128444_cov_693.939909",size: 128444,contig_type: "",structure: []},
{name: "NODE_63_length_128111_cov_29.063511",size: 128111,contig_type: "",structure: []},
{name: "NODE_64_length_127890_cov_20.098142",size: 127890,contig_type: "",structure: []},
{name: "NODE_65_length_127162_cov_661.370074",size: 127162,contig_type: "",structure: []},
{name: "NODE_66_length_126814_cov_27.829314",size: 126814,contig_type: "",structure: []},
{name: "NODE_67_length_123804_cov_15.839829",size: 123804,contig_type: "",structure: []},
{name: "NODE_68_length_121245_cov_25.061218",size: 121245,contig_type: "",structure: []},
{name: "NODE_69_length_120466_cov_12.468736",size: 120466,contig_type: "",structure: []},
{name: "NODE_70_length_120411_cov_20.067707",size: 120411,contig_type: "",structure: []},
{name: "NODE_71_length_119328_cov_19.826390",size: 119328,contig_type: "",structure: []},
{name: "NODE_72_length_119278_cov_58.238360",size: 119278,contig_type: "",structure: []},
{name: "NODE_73_length_118629_cov_642.922766",size: 118629,contig_type: "",structure: []},
{name: "NODE_74_length_118573_cov_20.932601",size: 118573,contig_type: "",structure: []},
{name: "NODE_75_length_118025_cov_53.016148",size: 118025,contig_type: "",structure: []},
{name: "NODE_76_length_117832_cov_31.405028",size: 117832,contig_type: "",structure: []},
{name: "NODE_77_length_115842_cov_638.500583",size: 115842,contig_type: "",structure: []},
{name: "NODE_78_length_114974_cov_653.593627",size: 114974,contig_type: "",structure: []},
{name: "NODE_79_length_112738_cov_17.394088",size: 112738,contig_type: "",structure: []},
{name: "NODE_80_length_112411_cov_28.876945",size: 112411,contig_type: "",structure: []},
{name: "NODE_81_length_112210_cov_16.174027",size: 112210,contig_type: "",structure: []},
{name: "NODE_82_length_111810_cov_27.533775",size: 111810,contig_type: "",structure: []},
{name: "NODE_83_length_110268_cov_17.732699",size: 110268,contig_type: "",structure: []},
{name: "NODE_84_length_109546_cov_30.107004",size: 109546,contig_type: "",structure: []},
{name: "NODE_85_length_107099_cov_42.537601",size: 107099,contig_type: "",structure: []},
{name: "NODE_86_length_106832_cov_633.967933",size: 106832,contig_type: "",structure: []},
{name: "NODE_87_length_106178_cov_20.707905",size: 106178,contig_type: "",structure: []},
{name: "NODE_88_length_105625_cov_31.117960",size: 105625,contig_type: "",structure: []},
{name: "NODE_89_length_105405_cov_14.360028",size: 105405,contig_type: "",structure: []},
{name: "NODE_90_length_105016_cov_666.194396",size: 105016,contig_type: "",structure: []},
{name: "NODE_91_length_104541_cov_74.293302",size: 104541,contig_type: "",structure: []},
{name: "NODE_92_length_104334_cov_20.245888",size: 104334,contig_type: "",structure: []},
{name: "NODE_93_length_104329_cov_15.186221",size: 104329,contig_type: "",structure: []},
{name: "NODE_94_length_103342_cov_28.294374",size: 103342,contig_type: "",structure: []},
{name: "NODE_95_length_102645_cov_23.783215",size: 102645,contig_type: "",structure: []},
{name: "NODE_96_length_101261_cov_20.316878",size: 101261,contig_type: "",structure: []},
{name: "NODE_97_length_101087_cov_22.245734",size: 101087,contig_type: "",structure: []},
{name: "NODE_98_length_100999_cov_657.485497",size: 100999,contig_type: "",structure: []},
{name: "NODE_99_length_100787_cov_36.873188",size: 100787,contig_type: "",structure: []},
{name: "NODE_100_length_100195_cov_26.617635",size: 100195,contig_type: "",structure: []},
{name: "NODE_101_length_99547_cov_21.546717",size: 99547,contig_type: "",structure: []},
{name: "NODE_102_length_99314_cov_22.611965",size: 99314,contig_type: "",structure: []},
{name: "NODE_103_length_98925_cov_24.000647",size: 98925,contig_type: "",structure: []},
{name: "NODE_104_length_98711_cov_16.926137",size: 98711,contig_type: "",structure: []},
{name: "NODE_105_length_98658_cov_19.602193",size: 98658,contig_type: "",structure: []},
{name: "NODE_106_length_97545_cov_18.162376",size: 97545,contig_type: "",structure: []},
{name: "NODE_107_length_97477_cov_7.650767",size: 97477,contig_type: "",structure: []},
{name: "NODE_108_length_95977_cov_24.845823",size: 95977,contig_type: "",structure: []},
{name: "NODE_109_length_95629_cov_26.961088",size: 95629,contig_type: "",structure: []},
{name: "NODE_110_length_95361_cov_18.600655",size: 95361,contig_type: "",structure: []},
{name: "NODE_111_length_94945_cov_30.204595",size: 94945,contig_type: "",structure: []},
{name: "NODE_112_length_93924_cov_647.116311",size: 93924,contig_type: "",structure: []},
{name: "NODE_113_length_93032_cov_75.148037",size: 93032,contig_type: "",structure: []},
{name: "NODE_114_length_92667_cov_21.775861",size: 92667,contig_type: "",structure: []},
{name: "NODE_115_length_92383_cov_18.620787",size: 92383,contig_type: "",structure: []},
{name: "NODE_116_length_92154_cov_24.783906",size: 92154,contig_type: "",structure: []},
{name: "NODE_117_length_92057_cov_28.776690",size: 92057,contig_type: "",structure: []},
{name: "NODE_118_length_91607_cov_24.895327",size: 91607,contig_type: "",structure: []},
{name: "NODE_119_length_90848_cov_53.971892",size: 90848,contig_type: "",structure: []},
{name: "NODE_120_length_90690_cov_11.627914",size: 90690,contig_type: "",structure: []},
{name: "NODE_121_length_90678_cov_24.894828",size: 90678,contig_type: "",structure: []},
{name: "NODE_122_length_90599_cov_16.736647",size: 90599,contig_type: "",structure: []},
{name: "NODE_123_length_90148_cov_22.708934",size: 90148,contig_type: "",structure: []},
{name: "NODE_124_length_89997_cov_44.000100",size: 89997,contig_type: "",structure: []},
{name: "NODE_125_length_89987_cov_17.875439",size: 89987,contig_type: "",structure: []},
{name: "NODE_126_length_89755_cov_23.239855",size: 89755,contig_type: "",structure: []},
{name: "NODE_127_length_89355_cov_9.188275",size: 89355,contig_type: "",structure: []},
{name: "NODE_128_length_89342_cov_18.459440",size: 89342,contig_type: "",structure: []},
{name: "NODE_129_length_89231_cov_651.800955",size: 89231,contig_type: "",structure: []},
{name: "NODE_130_length_89116_cov_19.944611",size: 89116,contig_type: "",structure: []},
{name: "NODE_131_length_88804_cov_21.571544",size: 88804,contig_type: "",structure: []},
{name: "NODE_132_length_88745_cov_21.992457",size: 88745,contig_type: "",structure: []},
{name: "NODE_133_length_88382_cov_71.036184",size: 88382,contig_type: "",structure: []},
{name: "NODE_134_length_87877_cov_34.520633",size: 87877,contig_type: "",structure: []},
{name: "NODE_135_length_87652_cov_23.358323",size: 87652,contig_type: "",structure: []},
{name: "NODE_136_length_87523_cov_17.226677",size: 87523,contig_type: "",structure: []},
{name: "NODE_137_length_86951_cov_35.112053",size: 86951,contig_type: "",structure: []},
{name: "NODE_138_length_86941_cov_19.261342",size: 86941,contig_type: "",structure: []},
{name: "NODE_139_length_86674_cov_24.097958",size: 86674,contig_type: "",structure: []},
{name: "NODE_140_length_86515_cov_21.608686",size: 86515,contig_type: "",structure: []},
{name: "NODE_141_length_86512_cov_23.594319",size: 86512,contig_type: "",structure: []},
{name: "NODE_142_length_86252_cov_19.025755",size: 86252,contig_type: "",structure: []},
{name: "NODE_143_length_86028_cov_21.143103",size: 86028,contig_type: "",structure: []},
{name: "NODE_144_length_85954_cov_18.296104",size: 85954,contig_type: "",structure: []},
{name: "NODE_145_length_85669_cov_13.225302",size: 85669,contig_type: "",structure: []},
{name: "NODE_146_length_85527_cov_22.295243",size: 85527,contig_type: "",structure: []},
{name: "NODE_147_length_85224_cov_22.882786",size: 85224,contig_type: "",structure: []},
{name: "NODE_148_length_84941_cov_19.759265",size: 84941,contig_type: "",structure: []},
{name: "NODE_149_length_84729_cov_26.178083",size: 84729,contig_type: "",structure: []},
{name: "NODE_150_length_84598_cov_29.699987",size: 84598,contig_type: "",structure: []},
{name: "NODE_151_length_84324_cov_22.640936",size: 84324,contig_type: "",structure: []},
{name: "NODE_152_length_84282_cov_23.569853",size: 84282,contig_type: "",structure: []},
{name: "NODE_153_length_84204_cov_32.157673",size: 84204,contig_type: "",structure: []},
{name: "NODE_154_length_83948_cov_59.279725",size: 83948,contig_type: "",structure: []},
{name: "NODE_155_length_83621_cov_22.393174",size: 83621,contig_type: "",structure: []},
{name: "NODE_156_length_83352_cov_19.761084",size: 83352,contig_type: "",structure: []},
{name: "NODE_157_length_83170_cov_30.765253",size: 83170,contig_type: "",structure: []},
{name: "NODE_158_length_82513_cov_20.705280",size: 82513,contig_type: "",structure: []},
{name: "NODE_159_length_82385_cov_18.628714",size: 82385,contig_type: "",structure: []},
{name: "NODE_160_length_82341_cov_17.915514",size: 82341,contig_type: "",structure: []},
{name: "NODE_161_length_82296_cov_9.631704",size: 82296,contig_type: "",structure: []},
{name: "NODE_162_length_82290_cov_9.862248",size: 82290,contig_type: "",structure: []},
{name: "NODE_163_length_81935_cov_662.721971",size: 81935,contig_type: "",structure: []},
{name: "NODE_164_length_81882_cov_16.432351",size: 81882,contig_type: "",structure: []},
{name: "NODE_165_length_81793_cov_24.152499",size: 81793,contig_type: "",structure: []},
{name: "NODE_166_length_81589_cov_19.459060",size: 81589,contig_type: "",structure: []},
{name: "NODE_167_length_81540_cov_67.864662",size: 81540,contig_type: "",structure: []},
{name: "NODE_168_length_81391_cov_26.617377",size: 81391,contig_type: "",structure: []},
{name: "NODE_169_length_81050_cov_12.784073",size: 81050,contig_type: "",structure: []},
{name: "NODE_170_length_80882_cov_19.906813",size: 80882,contig_type: "",structure: []},
{name: "NODE_171_length_80803_cov_26.128969",size: 80803,contig_type: "",structure: []},
{name: "NODE_172_length_80713_cov_21.882553",size: 80713,contig_type: "",structure: []},
{name: "NODE_173_length_80645_cov_29.328552",size: 80645,contig_type: "",structure: []},
{name: "NODE_174_length_80594_cov_23.740871",size: 80594,contig_type: "",structure: []},
{name: "NODE_175_length_80427_cov_31.516386",size: 80427,contig_type: "",structure: []},
{name: "NODE_176_length_80327_cov_20.722456",size: 80327,contig_type: "",structure: []},
{name: "NODE_177_length_79973_cov_10.271128",size: 79973,contig_type: "",structure: []},
{name: "NODE_178_length_79041_cov_12.081179",size: 79041,contig_type: "",structure: []},
{name: "NODE_179_length_78945_cov_19.933084",size: 78945,contig_type: "",structure: []},
{name: "NODE_180_length_78725_cov_16.116194",size: 78725,contig_type: "",structure: []},
{name: "NODE_181_length_78626_cov_32.904558",size: 78626,contig_type: "",structure: []},
{name: "NODE_182_length_78572_cov_12.645236",size: 78572,contig_type: "",structure: []},
{name: "NODE_183_length_78169_cov_37.291561",size: 78169,contig_type: "",structure: []},
{name: "NODE_184_length_77498_cov_18.714125",size: 77498,contig_type: "",structure: []},
{name: "NODE_185_length_77215_cov_24.684889",size: 77215,contig_type: "",structure: []},
{name: "NODE_186_length_76907_cov_20.783701",size: 76907,contig_type: "",structure: []},
{name: "NODE_187_length_76899_cov_27.338452",size: 76899,contig_type: "",structure: []},
{name: "NODE_188_length_76471_cov_23.638832",size: 76471,contig_type: "",structure: []},
{name: "NODE_189_length_76216_cov_34.857526",size: 76216,contig_type: "",structure: []},
{name: "NODE_190_length_76112_cov_12.327728",size: 76112,contig_type: "",structure: []},
{name: "NODE_191_length_76070_cov_11.383898",size: 76070,contig_type: "",structure: []},
{name: "NODE_192_length_76019_cov_29.146727",size: 76019,contig_type: "",structure: []},
{name: "NODE_193_length_75798_cov_17.548962",size: 75798,contig_type: "",structure: []},
{name: "NODE_194_length_75616_cov_24.665158",size: 75616,contig_type: "",structure: []},
{name: "NODE_195_length_75201_cov_39.046257",size: 75201,contig_type: "",structure: []},
{name: "NODE_196_length_75039_cov_73.043583",size: 75039,contig_type: "",structure: []},
{name: "NODE_197_length_74920_cov_30.641435",size: 74920,contig_type: "",structure: []},
{name: "NODE_198_length_74118_cov_17.889337",size: 74118,contig_type: "",structure: []},
{name: "NODE_199_length_73949_cov_29.706133",size: 73949,contig_type: "",structure: []},
{name: "NODE_200_length_73912_cov_18.113693",size: 73912,contig_type: "",structure: []},
{name: "NODE_201_length_73680_cov_11.762173",size: 73680,contig_type: "",structure: []},
{name: "NODE_202_length_73123_cov_10.251369",size: 73123,contig_type: "",structure: []},
{name: "NODE_203_length_72960_cov_8.649983",size: 72960,contig_type: "",structure: []},
{name: "NODE_204_length_72923_cov_18.124183",size: 72923,contig_type: "",structure: []},
{name: "NODE_205_length_72603_cov_13.637247",size: 72603,contig_type: "",structure: []},
{name: "NODE_206_length_72225_cov_10.363738",size: 72225,contig_type: "",structure: []},
{name: "NODE_207_length_71972_cov_14.269352",size: 71972,contig_type: "",structure: []},
{name: "NODE_208_length_71952_cov_29.227436",size: 71952,contig_type: "",structure: []},
{name: "NODE_209_length_71658_cov_18.583970",size: 71658,contig_type: "",structure: []},
{name: "NODE_210_length_71007_cov_45.118334",size: 71007,contig_type: "",structure: []},
{name: "NODE_211_length_70472_cov_20.196714",size: 70472,contig_type: "",structure: []},
{name: "NODE_212_length_70126_cov_68.335431",size: 70126,contig_type: "",structure: []},
{name: "NODE_213_length_70105_cov_29.966495",size: 70105,contig_type: "",structure: []},
{name: "NODE_214_length_70088_cov_14.127854",size: 70088,contig_type: "",structure: []},
{name: "NODE_215_length_70027_cov_17.149160",size: 70027,contig_type: "",structure: []},
{name: "NODE_216_length_69915_cov_18.955883",size: 69915,contig_type: "",structure: []},
{name: "NODE_217_length_69909_cov_10.786140",size: 69909,contig_type: "",structure: []},
{name: "NODE_218_length_69098_cov_13.795953",size: 69098,contig_type: "",structure: []},
{name: "NODE_219_length_69039_cov_22.179708",size: 69039,contig_type: "",structure: []},
{name: "NODE_220_length_68954_cov_24.424883",size: 68954,contig_type: "",structure: []},
{name: "NODE_221_length_68910_cov_44.325045",size: 68910,contig_type: "",structure: []},
{name: "NODE_222_length_68486_cov_18.003566",size: 68486,contig_type: "",structure: []},
{name: "NODE_223_length_68459_cov_24.282937",size: 68459,contig_type: "",structure: []},
{name: "NODE_224_length_68426_cov_14.403899",size: 68426,contig_type: "",structure: []},
{name: "NODE_225_length_68397_cov_7.762547",size: 68397,contig_type: "",structure: []},
{name: "NODE_226_length_67937_cov_8.782608",size: 67937,contig_type: "",structure: []},
{name: "NODE_227_length_67714_cov_17.807816",size: 67714,contig_type: "",structure: []},
{name: "NODE_228_length_67596_cov_53.020062",size: 67596,contig_type: "",structure: []},
{name: "NODE_229_length_67292_cov_23.946161",size: 67292,contig_type: "",structure: []},
{name: "NODE_230_length_67192_cov_12.911018",size: 67192,contig_type: "",structure: []},
{name: "NODE_231_length_67157_cov_9.687595",size: 67157,contig_type: "",structure: []},
{name: "NODE_232_length_67009_cov_30.055366",size: 67009,contig_type: "",structure: []},
{name: "NODE_233_length_66662_cov_655.465507",size: 66662,contig_type: "",structure: []},
{name: "NODE_234_length_66549_cov_20.370048",size: 66549,contig_type: "",structure: []},
{name: "NODE_235_length_66401_cov_59.173409",size: 66401,contig_type: "",structure: []},
{name: "NODE_236_length_66236_cov_17.750910",size: 66236,contig_type: "",structure: []},
{name: "NODE_237_length_65944_cov_22.733977",size: 65944,contig_type: "",structure: []},
{name: "NODE_238_length_65742_cov_29.568453",size: 65742,contig_type: "",structure: []},
{name: "NODE_239_length_65473_cov_16.157189",size: 65473,contig_type: "",structure: []},
{name: "NODE_240_length_65237_cov_17.882575",size: 65237,contig_type: "",structure: []},
{name: "NODE_241_length_65107_cov_20.367644",size: 65107,contig_type: "",structure: []},
{name: "NODE_242_length_65022_cov_30.725584",size: 65022,contig_type: "",structure: []},
{name: "NODE_243_length_64951_cov_57.238397",size: 64951,contig_type: "",structure: []},
{name: "NODE_244_length_64923_cov_23.333523",size: 64923,contig_type: "",structure: []},
{name: "NODE_245_length_64881_cov_20.322062",size: 64881,contig_type: "",structure: []},
{name: "NODE_246_length_64840_cov_8.183422",size: 64840,contig_type: "",structure: []},
{name: "NODE_247_length_64791_cov_17.104177",size: 64791,contig_type: "",structure: []},
{name: "NODE_248_length_64760_cov_24.698292",size: 64760,contig_type: "",structure: []},
{name: "NODE_249_length_64757_cov_633.204646",size: 64757,contig_type: "",structure: []},
{name: "NODE_250_length_64553_cov_9.382679",size: 64553,contig_type: "",structure: []},
{name: "NODE_251_length_64549_cov_22.897820",size: 64549,contig_type: "",structure: []},
{name: "NODE_252_length_64334_cov_31.627406",size: 64334,contig_type: "",structure: []},
{name: "NODE_253_length_64255_cov_25.627819",size: 64255,contig_type: "",structure: []},
{name: "NODE_254_length_64148_cov_11.760629",size: 64148,contig_type: "",structure: []},
{name: "NODE_255_length_63973_cov_25.112394",size: 63973,contig_type: "",structure: []},
{name: "NODE_256_length_63973_cov_22.109985",size: 63973,contig_type: "",structure: []},
{name: "NODE_257_length_63759_cov_22.878705",size: 63759,contig_type: "",structure: []},
{name: "NODE_258_length_63673_cov_28.022981",size: 63673,contig_type: "",structure: []},
{name: "NODE_259_length_63447_cov_27.213812",size: 63447,contig_type: "",structure: []},
{name: "NODE_260_length_63347_cov_17.831906",size: 63347,contig_type: "",structure: []},
{name: "NODE_261_length_63319_cov_11.566183",size: 63319,contig_type: "",structure: []},
{name: "NODE_262_length_63252_cov_41.365840",size: 63252,contig_type: "",structure: []},
{name: "NODE_263_length_63240_cov_27.635721",size: 63240,contig_type: "",structure: []},
{name: "NODE_264_length_63077_cov_26.804338",size: 63077,contig_type: "",structure: []},
{name: "NODE_265_length_63010_cov_13.073624",size: 63010,contig_type: "",structure: []},
{name: "NODE_266_length_62960_cov_12.906462",size: 62960,contig_type: "",structure: []},
{name: "NODE_267_length_62884_cov_7.629311",size: 62884,contig_type: "",structure: []},
{name: "NODE_268_length_62721_cov_24.694061",size: 62721,contig_type: "",structure: []},
{name: "NODE_269_length_62673_cov_12.073413",size: 62673,contig_type: "",structure: []},
{name: "NODE_270_length_62453_cov_38.953620",size: 62453,contig_type: "",structure: []},
{name: "NODE_271_length_62417_cov_32.604214",size: 62417,contig_type: "",structure: []},
{name: "NODE_272_length_62160_cov_63.467611",size: 62160,contig_type: "",structure: []},
{name: "NODE_273_length_62081_cov_37.023780",size: 62081,contig_type: "",structure: []},
{name: "NODE_274_length_62059_cov_19.030853",size: 62059,contig_type: "",structure: []},
{name: "NODE_275_length_61993_cov_12.889309",size: 61993,contig_type: "",structure: []},
{name: "NODE_276_length_61974_cov_28.441335",size: 61974,contig_type: "",structure: []},
{name: "NODE_277_length_61974_cov_7.797170",size: 61974,contig_type: "",structure: []},
{name: "NODE_278_length_61893_cov_20.835716",size: 61893,contig_type: "",structure: []},
{name: "NODE_279_length_61771_cov_21.088632",size: 61771,contig_type: "",structure: []},
{name: "NODE_280_length_61423_cov_6.715911",size: 61423,contig_type: "",structure: []},
{name: "NODE_281_length_60782_cov_8.121050",size: 60782,contig_type: "",structure: []},
{name: "NODE_282_length_60691_cov_25.032027",size: 60691,contig_type: "",structure: []},
{name: "NODE_283_length_60685_cov_12.228171",size: 60685,contig_type: "",structure: []},
{name: "NODE_284_length_60651_cov_7.621972",size: 60651,contig_type: "",structure: []},
{name: "NODE_285_length_60591_cov_24.426474",size: 60591,contig_type: "",structure: []},
{name: "NODE_286_length_60557_cov_7.844881",size: 60557,contig_type: "",structure: []},
{name: "NODE_287_length_60393_cov_718.158723",size: 60393,contig_type: "",structure: []},
{name: "NODE_288_length_60374_cov_9.585620",size: 60374,contig_type: "",structure: []},
{name: "NODE_289_length_60228_cov_23.269938",size: 60228,contig_type: "",structure: []},
{name: "NODE_290_length_60196_cov_12.572288",size: 60196,contig_type: "",structure: []},
{name: "NODE_291_length_59768_cov_27.159848",size: 59768,contig_type: "",structure: []},
{name: "NODE_292_length_59641_cov_666.622713",size: 59641,contig_type: "",structure: []},
{name: "NODE_293_length_59602_cov_7.972476",size: 59602,contig_type: "",structure: []},
{name: "NODE_294_length_59545_cov_19.573458",size: 59545,contig_type: "",structure: []},
{name: "NODE_295_length_59533_cov_25.266552",size: 59533,contig_type: "",structure: []},
{name: "NODE_296_length_59487_cov_25.940756",size: 59487,contig_type: "",structure: []},
{name: "NODE_297_length_59359_cov_24.354883",size: 59359,contig_type: "",structure: []},
{name: "NODE_298_length_59320_cov_34.792272",size: 59320,contig_type: "",structure: []},
{name: "NODE_299_length_59278_cov_23.536869",size: 59278,contig_type: "",structure: []},
{name: "NODE_300_length_59127_cov_26.184791",size: 59127,contig_type: "",structure: []},
{name: "NODE_301_length_59081_cov_11.176803",size: 59081,contig_type: "",structure: []},
{name: "NODE_302_length_58904_cov_15.293395",size: 58904,contig_type: "",structure: []},
{name: "NODE_303_length_58824_cov_26.994453",size: 58824,contig_type: "",structure: []},
{name: "NODE_304_length_58678_cov_28.408338",size: 58678,contig_type: "",structure: []},
{name: "NODE_305_length_58550_cov_38.545790",size: 58550,contig_type: "",structure: []},
{name: "NODE_306_length_58485_cov_39.181448",size: 58485,contig_type: "",structure: []},
{name: "NODE_307_length_58425_cov_13.361144",size: 58425,contig_type: "",structure: []},
{name: "NODE_308_length_58348_cov_21.176676",size: 58348,contig_type: "",structure: []},
{name: "NODE_309_length_58286_cov_9.414418",size: 58286,contig_type: "",structure: []},
{name: "NODE_310_length_58057_cov_16.786438",size: 58057,contig_type: "",structure: []},
{name: "NODE_311_length_57991_cov_19.094138",size: 57991,contig_type: "",structure: []},
{name: "NODE_312_length_57913_cov_9.950914",size: 57913,contig_type: "",structure: []},
{name: "NODE_313_length_57519_cov_20.212342",size: 57519,contig_type: "",structure: []},
{name: "NODE_314_length_57288_cov_8.264463",size: 57288,contig_type: "",structure: []},
{name: "NODE_315_length_57244_cov_10.266695",size: 57244,contig_type: "",structure: []},
{name: "NODE_316_length_57219_cov_13.248513",size: 57219,contig_type: "",structure: []},
{name: "NODE_317_length_57079_cov_26.424453",size: 57079,contig_type: "",structure: []},
{name: "NODE_318_length_57075_cov_6.978937",size: 57075,contig_type: "",structure: []},
{name: "NODE_319_length_56957_cov_30.151418",size: 56957,contig_type: "",structure: []},
{name: "NODE_320_length_56931_cov_12.525758",size: 56931,contig_type: "",structure: []},
{name: "NODE_321_length_56694_cov_12.009234",size: 56694,contig_type: "",structure: []},
{name: "NODE_322_length_56647_cov_30.025498",size: 56647,contig_type: "",structure: []},
{name: "NODE_323_length_56598_cov_10.585218",size: 56598,contig_type: "",structure: []},
{name: "NODE_324_length_56494_cov_7.720105",size: 56494,contig_type: "",structure: []},
{name: "NODE_325_length_56352_cov_9.469261",size: 56352,contig_type: "",structure: []},
{name: "NODE_326_length_56334_cov_78.697418",size: 56334,contig_type: "",structure: []},
{name: "NODE_327_length_56124_cov_8.116392",size: 56124,contig_type: "",structure: []},
{name: "NODE_328_length_56069_cov_79.618649",size: 56069,contig_type: "",structure: []},
{name: "NODE_329_length_55995_cov_7.656847",size: 55995,contig_type: "",structure: []},
{name: "NODE_330_length_55764_cov_21.981206",size: 55764,contig_type: "",structure: []},
{name: "NODE_331_length_55751_cov_22.096793",size: 55751,contig_type: "",structure: []},
{name: "NODE_332_length_55678_cov_22.691926",size: 55678,contig_type: "",structure: []},
{name: "NODE_333_length_55664_cov_20.517758",size: 55664,contig_type: "",structure: []},
{name: "NODE_334_length_55419_cov_20.742974",size: 55419,contig_type: "",structure: []},
{name: "NODE_335_length_55351_cov_17.558648",size: 55351,contig_type: "",structure: []},
{name: "NODE_336_length_55106_cov_26.229714",size: 55106,contig_type: "",structure: []},
{name: "NODE_337_length_55106_cov_20.891791",size: 55106,contig_type: "",structure: []},
{name: "NODE_338_length_54960_cov_23.456042",size: 54960,contig_type: "",structure: []},
{name: "NODE_339_length_54637_cov_724.908999",size: 54637,contig_type: "",structure: []},
{name: "NODE_340_length_54584_cov_8.030241",size: 54584,contig_type: "",structure: []},
{name: "NODE_341_length_54500_cov_21.560749",size: 54500,contig_type: "",structure: []},
{name: "NODE_342_length_54186_cov_19.948200",size: 54186,contig_type: "",structure: []},
{name: "NODE_343_length_54184_cov_29.208114",size: 54184,contig_type: "",structure: []},
{name: "NODE_344_length_54183_cov_6.928780",size: 54183,contig_type: "",structure: []},
{name: "NODE_345_length_54162_cov_18.672224",size: 54162,contig_type: "",structure: []},
{name: "NODE_346_length_54129_cov_13.653050",size: 54129,contig_type: "",structure: []},
{name: "NODE_347_length_54064_cov_30.151512",size: 54064,contig_type: "",structure: []},
{name: "NODE_348_length_53762_cov_23.044966",size: 53762,contig_type: "",structure: []},
{name: "NODE_349_length_53750_cov_27.130031",size: 53750,contig_type: "",structure: []},
{name: "NODE_350_length_53712_cov_31.976834",size: 53712,contig_type: "",structure: []},
{name: "NODE_351_length_53580_cov_70.195423",size: 53580,contig_type: "",structure: []},
{name: "NODE_352_length_53483_cov_13.620686",size: 53483,contig_type: "",structure: []},
{name: "NODE_353_length_53259_cov_16.622397",size: 53259,contig_type: "",structure: []},
{name: "NODE_354_length_53250_cov_10.247862",size: 53250,contig_type: "",structure: []},
{name: "NODE_355_length_53234_cov_17.887794",size: 53234,contig_type: "",structure: []},
{name: "NODE_356_length_53217_cov_9.353636",size: 53217,contig_type: "",structure: []},
{name: "NODE_357_length_53171_cov_13.006156",size: 53171,contig_type: "",structure: []},
{name: "NODE_358_length_53140_cov_19.743280",size: 53140,contig_type: "",structure: []},
{name: "NODE_359_length_53127_cov_28.395538",size: 53127,contig_type: "",structure: []},
{name: "NODE_360_length_53042_cov_11.060543",size: 53042,contig_type: "",structure: []},
{name: "NODE_361_length_52964_cov_16.217543",size: 52964,contig_type: "",structure: []},
{name: "NODE_362_length_52889_cov_25.555211",size: 52889,contig_type: "",structure: []},
{name: "NODE_363_length_52806_cov_6.896343",size: 52806,contig_type: "",structure: []},
{name: "NODE_364_length_52773_cov_10.379737",size: 52773,contig_type: "",structure: []},
{name: "NODE_365_length_52756_cov_11.861008",size: 52756,contig_type: "",structure: []},
{name: "NODE_366_length_52705_cov_15.913257",size: 52705,contig_type: "",structure: []},
{name: "NODE_367_length_52589_cov_8.829672",size: 52589,contig_type: "",structure: []},
{name: "NODE_368_length_52557_cov_7.533961",size: 52557,contig_type: "",structure: []},
{name: "NODE_369_length_52503_cov_14.468292",size: 52503,contig_type: "",structure: []},
{name: "NODE_370_length_52485_cov_6.468034",size: 52485,contig_type: "",structure: []},
{name: "NODE_371_length_52440_cov_9.833941",size: 52440,contig_type: "",structure: []},
{name: "NODE_372_length_52298_cov_13.360278",size: 52298,contig_type: "",structure: []},
{name: "NODE_373_length_52230_cov_30.419703",size: 52230,contig_type: "",structure: []},
{name: "NODE_374_length_52122_cov_28.432462",size: 52122,contig_type: "",structure: []},
{name: "NODE_375_length_52091_cov_654.153471",size: 52091,contig_type: "",structure: []},
{name: "NODE_376_length_52065_cov_19.675985",size: 52065,contig_type: "",structure: []},
{name: "NODE_377_length_52045_cov_20.521293",size: 52045,contig_type: "",structure: []},
{name: "NODE_378_length_51981_cov_17.851866",size: 51981,contig_type: "",structure: []},
{name: "NODE_379_length_51863_cov_28.533219",size: 51863,contig_type: "",structure: []},
{name: "NODE_380_length_51777_cov_56.927980",size: 51777,contig_type: "",structure: []},
{name: "NODE_381_length_51701_cov_8.670352",size: 51701,contig_type: "",structure: []},
{name: "NODE_382_length_51555_cov_22.725534",size: 51555,contig_type: "",structure: []},
{name: "NODE_383_length_51418_cov_14.523937",size: 51418,contig_type: "",structure: []},
{name: "NODE_384_length_51405_cov_7.284109",size: 51405,contig_type: "",structure: []},
{name: "NODE_385_length_51192_cov_6.970706",size: 51192,contig_type: "",structure: []},
{name: "NODE_386_length_51139_cov_14.212552",size: 51139,contig_type: "",structure: []},
{name: "NODE_387_length_51070_cov_25.720886",size: 51070,contig_type: "",structure: []},
{name: "NODE_388_length_50980_cov_14.226431",size: 50980,contig_type: "",structure: []},
{name: "NODE_389_length_50832_cov_20.157709",size: 50832,contig_type: "",structure: []},
{name: "NODE_390_length_50705_cov_29.061836",size: 50705,contig_type: "",structure: []},
{name: "NODE_391_length_50623_cov_12.651499",size: 50623,contig_type: "",structure: []},
{name: "NODE_392_length_50464_cov_8.544923",size: 50464,contig_type: "",structure: []},
{name: "NODE_393_length_50328_cov_8.184851",size: 50328,contig_type: "",structure: []},
{name: "NODE_394_length_50306_cov_17.962449",size: 50306,contig_type: "",structure: []},
{name: "NODE_395_length_50219_cov_21.124691",size: 50219,contig_type: "",structure: []},
{name: "NODE_396_length_50199_cov_25.239690",size: 50199,contig_type: "",structure: []},
{name: "NODE_397_length_50172_cov_7.974121",size: 50172,contig_type: "",structure: []},
{name: "NODE_398_length_50143_cov_54.542984",size: 50143,contig_type: "",structure: []},
{name: "NODE_399_length_50010_cov_25.350195",size: 50010,contig_type: "",structure: []},
{name: "NODE_400_length_49982_cov_18.422216",size: 49982,contig_type: "",structure: []},
{name: "NODE_401_length_49934_cov_21.136691",size: 49934,contig_type: "",structure: []},
{name: "NODE_402_length_49827_cov_248.483445",size: 49827,contig_type: "",structure: []},
{name: "NODE_403_length_49484_cov_9.115843",size: 49484,contig_type: "",structure: []},
{name: "NODE_404_length_49468_cov_24.928116",size: 49468,contig_type: "",structure: []},
{name: "NODE_405_length_49379_cov_7.890013",size: 49379,contig_type: "",structure: []},
{name: "NODE_406_length_49378_cov_69.851814",size: 49378,contig_type: "",structure: []},
{name: "NODE_407_length_49290_cov_33.520443",size: 49290,contig_type: "",structure: []},
{name: "NODE_408_length_49279_cov_10.400191",size: 49279,contig_type: "",structure: []},
{name: "NODE_409_length_49168_cov_27.377049",size: 49168,contig_type: "",structure: []},
{name: "NODE_410_length_49101_cov_13.831016",size: 49101,contig_type: "",structure: []},
{name: "NODE_411_length_49052_cov_28.848317",size: 49052,contig_type: "",structure: []},
{name: "NODE_412_length_48901_cov_18.040044",size: 48901,contig_type: "",structure: []},
{name: "NODE_413_length_48806_cov_14.098870",size: 48806,contig_type: "",structure: []},
{name: "NODE_414_length_48794_cov_19.649459",size: 48794,contig_type: "",structure: []},
{name: "NODE_415_length_48785_cov_20.574903",size: 48785,contig_type: "",structure: []},
{name: "NODE_416_length_48782_cov_18.336507",size: 48782,contig_type: "",structure: []},
{name: "NODE_417_length_48757_cov_12.537740",size: 48757,contig_type: "",structure: []},
{name: "NODE_418_length_48656_cov_26.145306",size: 48656,contig_type: "",structure: []},
{name: "NODE_419_length_48609_cov_33.608415",size: 48609,contig_type: "",structure: []},
{name: "NODE_420_length_48583_cov_33.180762",size: 48583,contig_type: "",structure: []},
{name: "NODE_421_length_48476_cov_17.273951",size: 48476,contig_type: "",structure: []},
{name: "NODE_422_length_48423_cov_10.348040",size: 48423,contig_type: "",structure: []},
{name: "NODE_423_length_48384_cov_24.399760",size: 48384,contig_type: "",structure: []},
{name: "NODE_424_length_48292_cov_15.238531",size: 48292,contig_type: "",structure: []},
{name: "NODE_425_length_48243_cov_25.871088",size: 48243,contig_type: "",structure: []},
{name: "NODE_426_length_48152_cov_649.367195",size: 48152,contig_type: "",structure: []},
{name: "NODE_427_length_48152_cov_35.934487",size: 48152,contig_type: "",structure: []},
{name: "NODE_428_length_48117_cov_9.439744",size: 48117,contig_type: "",structure: []},
{name: "NODE_429_length_48076_cov_8.261448",size: 48076,contig_type: "",structure: []},
{name: "NODE_430_length_47972_cov_17.732391",size: 47972,contig_type: "",structure: []},
{name: "NODE_431_length_47867_cov_11.224609",size: 47867,contig_type: "",structure: []},
{name: "NODE_432_length_47864_cov_10.900019",size: 47864,contig_type: "",structure: []},
{name: "NODE_433_length_47799_cov_19.249330",size: 47799,contig_type: "",structure: []},
{name: "NODE_434_length_47790_cov_11.587221",size: 47790,contig_type: "",structure: []},
{name: "NODE_435_length_47679_cov_11.304006",size: 47679,contig_type: "",structure: []},
{name: "NODE_436_length_47672_cov_8.691455",size: 47672,contig_type: "",structure: []},
{name: "NODE_437_length_47628_cov_12.998655",size: 47628,contig_type: "",structure: []},
{name: "NODE_438_length_47552_cov_22.447123",size: 47552,contig_type: "",structure: []},
{name: "NODE_439_length_47489_cov_17.525193",size: 47489,contig_type: "",structure: []},
{name: "NODE_440_length_47478_cov_9.223794",size: 47478,contig_type: "",structure: []},
{name: "NODE_441_length_47414_cov_12.124939",size: 47414,contig_type: "",structure: []},
{name: "NODE_442_length_47358_cov_9.561169",size: 47358,contig_type: "",structure: []},
{name: "NODE_443_length_47335_cov_21.623985",size: 47335,contig_type: "",structure: []},
{name: "NODE_444_length_47183_cov_5.742022",size: 47183,contig_type: "",structure: []},
{name: "NODE_445_length_47123_cov_23.654500",size: 47123,contig_type: "",structure: []},
{name: "NODE_446_length_47094_cov_23.897341",size: 47094,contig_type: "",structure: []},
{name: "NODE_447_length_47065_cov_28.856222",size: 47065,contig_type: "",structure: []},
{name: "NODE_448_length_47045_cov_17.483677",size: 47045,contig_type: "",structure: []},
{name: "NODE_449_length_46920_cov_5.814937",size: 46920,contig_type: "",structure: []},
{name: "NODE_450_length_46915_cov_12.554844",size: 46915,contig_type: "",structure: []},
{name: "NODE_451_length_46866_cov_15.567153",size: 46866,contig_type: "",structure: []},
{name: "NODE_452_length_46716_cov_12.769958",size: 46716,contig_type: "",structure: []},
{name: "NODE_453_length_46696_cov_21.546279",size: 46696,contig_type: "",structure: []},
{name: "NODE_454_length_46695_cov_36.739408",size: 46695,contig_type: "",structure: []},
{name: "NODE_455_length_46687_cov_8.328337",size: 46687,contig_type: "",structure: []},
{name: "NODE_456_length_46680_cov_11.921437",size: 46680,contig_type: "",structure: []},
{name: "NODE_457_length_46651_cov_668.970555",size: 46651,contig_type: "",structure: []},
{name: "NODE_458_length_46495_cov_14.995435",size: 46495,contig_type: "",structure: []},
{name: "NODE_459_length_46484_cov_11.157703",size: 46484,contig_type: "",structure: []},
{name: "NODE_460_length_46477_cov_25.622485",size: 46477,contig_type: "",structure: []},
{name: "NODE_461_length_46447_cov_16.103251",size: 46447,contig_type: "",structure: []},
{name: "NODE_462_length_46383_cov_21.454304",size: 46383,contig_type: "",structure: []},
{name: "NODE_463_length_46353_cov_11.948572",size: 46353,contig_type: "",structure: []},
{name: "NODE_464_length_46348_cov_21.693733",size: 46348,contig_type: "",structure: []},
{name: "NODE_465_length_46347_cov_24.787695",size: 46347,contig_type: "",structure: []},
{name: "NODE_466_length_46281_cov_7.873296",size: 46281,contig_type: "",structure: []},
{name: "NODE_467_length_46280_cov_9.248718",size: 46280,contig_type: "",structure: []},
{name: "NODE_468_length_46210_cov_22.945185",size: 46210,contig_type: "",structure: []},
{name: "NODE_469_length_46210_cov_20.721417",size: 46210,contig_type: "",structure: []},
{name: "NODE_470_length_46186_cov_7.539355",size: 46186,contig_type: "",structure: []},
{name: "NODE_471_length_46091_cov_664.885003",size: 46091,contig_type: "",structure: []},
{name: "NODE_472_length_46078_cov_24.585294",size: 46078,contig_type: "",structure: []},
{name: "NODE_473_length_45955_cov_12.602898",size: 45955,contig_type: "",structure: []},
{name: "NODE_474_length_45908_cov_32.089634",size: 45908,contig_type: "",structure: []},
{name: "NODE_475_length_45884_cov_23.709813",size: 45884,contig_type: "",structure: []},
{name: "NODE_476_length_45813_cov_28.011124",size: 45813,contig_type: "",structure: []},
{name: "NODE_477_length_45798_cov_12.683820",size: 45798,contig_type: "",structure: []},
{name: "NODE_478_length_45776_cov_14.811793",size: 45776,contig_type: "",structure: []},
{name: "NODE_479_length_45738_cov_13.184861",size: 45738,contig_type: "",structure: []},
{name: "NODE_480_length_45720_cov_6.707763",size: 45720,contig_type: "",structure: []},
{name: "NODE_481_length_45712_cov_9.435289",size: 45712,contig_type: "",structure: []},
{name: "NODE_482_length_45643_cov_30.950513",size: 45643,contig_type: "",structure: []},
{name: "NODE_483_length_45631_cov_18.098056",size: 45631,contig_type: "",structure: []},
{name: "NODE_484_length_45627_cov_8.106513",size: 45627,contig_type: "",structure: []},
{name: "NODE_485_length_45618_cov_16.063297",size: 45618,contig_type: "",structure: []},
{name: "NODE_486_length_45611_cov_8.420186",size: 45611,contig_type: "",structure: []},
{name: "NODE_487_length_45576_cov_76.245249",size: 45576,contig_type: "",structure: []},
{name: "NODE_488_length_45466_cov_7.793024",size: 45466,contig_type: "",structure: []},
{name: "NODE_489_length_45339_cov_8.699497",size: 45339,contig_type: "",structure: []},
{name: "NODE_490_length_45302_cov_21.539815",size: 45302,contig_type: "",structure: []},
{name: "NODE_491_length_45235_cov_22.239973",size: 45235,contig_type: "",structure: []},
{name: "NODE_492_length_45080_cov_28.614814",size: 45080,contig_type: "",structure: []},
{name: "NODE_493_length_45071_cov_7.846499",size: 45071,contig_type: "",structure: []},
{name: "NODE_494_length_45064_cov_469.814482",size: 45064,contig_type: "",structure: []},
{name: "NODE_495_length_45050_cov_15.039049",size: 45050,contig_type: "",structure: []},
{name: "NODE_496_length_45038_cov_34.772625",size: 45038,contig_type: "",structure: []},
{name: "NODE_497_length_45031_cov_8.755114",size: 45031,contig_type: "",structure: []},
{name: "NODE_498_length_45018_cov_5.700242",size: 45018,contig_type: "",structure: []},
{name: "NODE_499_length_44912_cov_17.912009",size: 44912,contig_type: "",structure: []},
{name: "NODE_500_length_44910_cov_9.758488",size: 44910,contig_type: "",structure: []},
{name: "NODE_501_length_44788_cov_70.541748",size: 44788,contig_type: "",structure: []},
{name: "NODE_502_length_44697_cov_53.031898",size: 44697,contig_type: "",structure: []},
{name: "NODE_503_length_44692_cov_78.771624",size: 44692,contig_type: "",structure: []},
{name: "NODE_504_length_44605_cov_654.237172",size: 44605,contig_type: "",structure: []},
{name: "NODE_505_length_44531_cov_33.718995",size: 44531,contig_type: "",structure: []},
{name: "NODE_506_length_44513_cov_17.161343",size: 44513,contig_type: "",structure: []},
{name: "NODE_507_length_44365_cov_12.267118",size: 44365,contig_type: "",structure: []},
{name: "NODE_508_length_44326_cov_16.676786",size: 44326,contig_type: "",structure: []},
{name: "NODE_509_length_44315_cov_32.373836",size: 44315,contig_type: "",structure: []},
{name: "NODE_510_length_44268_cov_8.015357",size: 44268,contig_type: "",structure: []},
{name: "NODE_511_length_44215_cov_7.434375",size: 44215,contig_type: "",structure: []},
{name: "NODE_512_length_44187_cov_32.424884",size: 44187,contig_type: "",structure: []},
{name: "NODE_513_length_44167_cov_33.492043",size: 44167,contig_type: "",structure: []},
{name: "NODE_514_length_43968_cov_45.621433",size: 43968,contig_type: "",structure: []},
{name: "NODE_515_length_43905_cov_22.637742",size: 43905,contig_type: "",structure: []},
{name: "NODE_516_length_43857_cov_21.497626",size: 43857,contig_type: "",structure: []},
{name: "NODE_517_length_43773_cov_25.939247",size: 43773,contig_type: "",structure: []},
{name: "NODE_518_length_43736_cov_27.834940",size: 43736,contig_type: "",structure: []},
{name: "NODE_519_length_43697_cov_26.640690",size: 43697,contig_type: "",structure: []},
{name: "NODE_520_length_43601_cov_31.491641",size: 43601,contig_type: "",structure: []},
{name: "NODE_521_length_43553_cov_9.072486",size: 43553,contig_type: "",structure: []},
{name: "NODE_522_length_43545_cov_23.948701",size: 43545,contig_type: "",structure: []},
{name: "NODE_523_length_43511_cov_9.912095",size: 43511,contig_type: "",structure: []},
{name: "NODE_524_length_43410_cov_12.798731",size: 43410,contig_type: "",structure: []},
{name: "NODE_525_length_43391_cov_25.128207",size: 43391,contig_type: "",structure: []},
{name: "NODE_526_length_43371_cov_22.858782",size: 43371,contig_type: "",structure: []},
{name: "NODE_527_length_43364_cov_13.463668",size: 43364,contig_type: "",structure: []},
{name: "NODE_528_length_43227_cov_11.067706",size: 43227,contig_type: "",structure: []},
{name: "NODE_529_length_43140_cov_17.409586",size: 43140,contig_type: "",structure: []},
{name: "NODE_530_length_43138_cov_9.679177",size: 43138,contig_type: "",structure: []},
{name: "NODE_531_length_43135_cov_21.282799",size: 43135,contig_type: "",structure: []},
{name: "NODE_532_length_43120_cov_14.388947",size: 43120,contig_type: "",structure: []},
{name: "NODE_533_length_43057_cov_31.593903",size: 43057,contig_type: "",structure: []},
{name: "NODE_534_length_43021_cov_24.476423",size: 43021,contig_type: "",structure: []},
{name: "NODE_535_length_42960_cov_13.997063",size: 42960,contig_type: "",structure: []},
{name: "NODE_536_length_42947_cov_748.406369",size: 42947,contig_type: "",structure: []},
{name: "NODE_537_length_42909_cov_13.438535",size: 42909,contig_type: "",structure: []},
{name: "NODE_538_length_42810_cov_684.261443",size: 42810,contig_type: "",structure: []},
{name: "NODE_539_length_42680_cov_8.091754",size: 42680,contig_type: "",structure: []},
{name: "NODE_540_length_42665_cov_8.415466",size: 42665,contig_type: "",structure: []},
{name: "NODE_541_length_42560_cov_11.845759",size: 42560,contig_type: "",structure: []},
{name: "NODE_542_length_42501_cov_35.393135",size: 42501,contig_type: "",structure: []},
{name: "NODE_543_length_42478_cov_18.099451",size: 42478,contig_type: "",structure: []},
{name: "NODE_544_length_42418_cov_24.207941",size: 42418,contig_type: "",structure: []},
{name: "NODE_545_length_42407_cov_16.786433",size: 42407,contig_type: "",structure: []},
{name: "NODE_546_length_42405_cov_21.852727",size: 42405,contig_type: "",structure: []},
{name: "NODE_547_length_42384_cov_9.705639",size: 42384,contig_type: "",structure: []},
{name: "NODE_548_length_42381_cov_21.806880",size: 42381,contig_type: "",structure: []},
{name: "NODE_549_length_42342_cov_19.094450",size: 42342,contig_type: "",structure: []},
{name: "NODE_550_length_42328_cov_8.135666",size: 42328,contig_type: "",structure: []},
{name: "NODE_551_length_42294_cov_23.177088",size: 42294,contig_type: "",structure: []},
{name: "NODE_552_length_42288_cov_65.869888",size: 42288,contig_type: "",structure: []},
{name: "NODE_553_length_42279_cov_26.011368",size: 42279,contig_type: "",structure: []},
{name: "NODE_554_length_42252_cov_8.958907",size: 42252,contig_type: "",structure: []},
{name: "NODE_555_length_42220_cov_10.832231",size: 42220,contig_type: "",structure: []},
{name: "NODE_556_length_42208_cov_6.756126",size: 42208,contig_type: "",structure: []},
{name: "NODE_557_length_42132_cov_25.838035",size: 42132,contig_type: "",structure: []},
{name: "NODE_558_length_42111_cov_12.902463",size: 42111,contig_type: "",structure: []},
{name: "NODE_559_length_42058_cov_21.879366",size: 42058,contig_type: "",structure: []},
{name: "NODE_560_length_42049_cov_12.523480",size: 42049,contig_type: "",structure: []},
{name: "NODE_561_length_42029_cov_23.847048",size: 42029,contig_type: "",structure: []},
{name: "NODE_562_length_42015_cov_5.832745",size: 42015,contig_type: "",structure: []},
{name: "NODE_563_length_41981_cov_12.496708",size: 41981,contig_type: "",structure: []},
{name: "NODE_564_length_41906_cov_10.399202",size: 41906,contig_type: "",structure: []},
{name: "NODE_565_length_41902_cov_40.816785",size: 41902,contig_type: "",structure: []},
{name: "NODE_566_length_41891_cov_23.410364",size: 41891,contig_type: "",structure: []},
{name: "NODE_567_length_41887_cov_29.419727",size: 41887,contig_type: "",structure: []},
{name: "NODE_568_length_41816_cov_14.110342",size: 41816,contig_type: "",structure: []},
{name: "NODE_569_length_41810_cov_30.518597",size: 41810,contig_type: "",structure: []},
{name: "NODE_570_length_41707_cov_8.731129",size: 41707,contig_type: "",structure: []},
{name: "NODE_571_length_41646_cov_67.953331",size: 41646,contig_type: "",structure: []},
{name: "NODE_572_length_41616_cov_13.244965",size: 41616,contig_type: "",structure: []},
{name: "NODE_573_length_41609_cov_54.945372",size: 41609,contig_type: "",structure: []},
{name: "NODE_574_length_41604_cov_169.353799",size: 41604,contig_type: "",structure: []},
{name: "NODE_575_length_41579_cov_19.120798",size: 41579,contig_type: "",structure: []},
{name: "NODE_576_length_41543_cov_26.257737",size: 41543,contig_type: "",structure: []},
{name: "NODE_577_length_41529_cov_12.336066",size: 41529,contig_type: "",structure: []},
{name: "NODE_578_length_41502_cov_7.508408",size: 41502,contig_type: "",structure: []},
{name: "NODE_579_length_41279_cov_725.988938",size: 41279,contig_type: "",structure: []},
{name: "NODE_580_length_41210_cov_19.685700",size: 41210,contig_type: "",structure: []},
{name: "NODE_581_length_41174_cov_17.467448",size: 41174,contig_type: "",structure: []},
{name: "NODE_582_length_41153_cov_11.247920",size: 41153,contig_type: "",structure: []},
{name: "NODE_583_length_41046_cov_20.436291",size: 41046,contig_type: "",structure: []},
{name: "NODE_584_length_41015_cov_13.584766",size: 41015,contig_type: "",structure: []},
{name: "NODE_585_length_40988_cov_12.619109",size: 40988,contig_type: "",structure: []},
{name: "NODE_586_length_40964_cov_8.928940",size: 40964,contig_type: "",structure: []},
{name: "NODE_587_length_40960_cov_19.292018",size: 40960,contig_type: "",structure: []},
{name: "NODE_588_length_40925_cov_35.280352",size: 40925,contig_type: "",structure: []},
{name: "NODE_589_length_40909_cov_63.337960",size: 40909,contig_type: "",structure: []},
{name: "NODE_590_length_40903_cov_7.234381",size: 40903,contig_type: "",structure: []},
{name: "NODE_591_length_40855_cov_67.424314",size: 40855,contig_type: "",structure: []},
{name: "NODE_592_length_40797_cov_13.004050",size: 40797,contig_type: "",structure: []},
{name: "NODE_593_length_40780_cov_734.755801",size: 40780,contig_type: "",structure: []},
{name: "NODE_594_length_40687_cov_10.613703",size: 40687,contig_type: "",structure: []},
{name: "NODE_595_length_40659_cov_23.672372",size: 40659,contig_type: "",structure: []},
{name: "NODE_596_length_40622_cov_15.108857",size: 40622,contig_type: "",structure: []},
{name: "NODE_597_length_40603_cov_7.462390",size: 40603,contig_type: "",structure: []},
{name: "NODE_598_length_40572_cov_8.553619",size: 40572,contig_type: "",structure: []},
{name: "NODE_599_length_40569_cov_11.318137",size: 40569,contig_type: "",structure: []},
{name: "NODE_600_length_40522_cov_11.005387",size: 40522,contig_type: "",structure: []},
{name: "NODE_601_length_40480_cov_50.545826",size: 40480,contig_type: "",structure: []},
{name: "NODE_602_length_40469_cov_12.091404",size: 40469,contig_type: "",structure: []},
{name: "NODE_603_length_40461_cov_13.055685",size: 40461,contig_type: "",structure: []},
{name: "NODE_604_length_40454_cov_32.081487",size: 40454,contig_type: "",structure: []},
{name: "NODE_605_length_40434_cov_10.925555",size: 40434,contig_type: "",structure: []},
{name: "NODE_606_length_40404_cov_29.850653",size: 40404,contig_type: "",structure: []},
{name: "NODE_607_length_40384_cov_27.024647",size: 40384,contig_type: "",structure: []},
{name: "NODE_608_length_40219_cov_36.459900",size: 40219,contig_type: "",structure: []},
{name: "NODE_609_length_40115_cov_55.910185",size: 40115,contig_type: "",structure: []},
{name: "NODE_610_length_40087_cov_6.741457",size: 40087,contig_type: "",structure: []},
{name: "NODE_611_length_40073_cov_14.763157",size: 40073,contig_type: "",structure: []},
{name: "NODE_612_length_40066_cov_20.943116",size: 40066,contig_type: "",structure: []},
{name: "NODE_613_length_40052_cov_22.440833",size: 40052,contig_type: "",structure: []},
{name: "NODE_614_length_40002_cov_25.926678",size: 40002,contig_type: "",structure: []},
{name: "NODE_615_length_39996_cov_13.785534",size: 39996,contig_type: "",structure: []},
{name: "NODE_616_length_39953_cov_10.394180",size: 39953,contig_type: "",structure: []},
{name: "NODE_617_length_39938_cov_9.751523",size: 39938,contig_type: "",structure: []},
{name: "NODE_618_length_39920_cov_8.197517",size: 39920,contig_type: "",structure: []},
{name: "NODE_619_length_39919_cov_14.158664",size: 39919,contig_type: "",structure: []},
{name: "NODE_620_length_39877_cov_20.578876",size: 39877,contig_type: "",structure: []},
{name: "NODE_621_length_39875_cov_9.856379",size: 39875,contig_type: "",structure: []},
{name: "NODE_622_length_39867_cov_44.836230",size: 39867,contig_type: "",structure: []},
{name: "NODE_623_length_39856_cov_6.849652",size: 39856,contig_type: "",structure: []},
{name: "NODE_624_length_39838_cov_25.330141",size: 39838,contig_type: "",structure: []},
{name: "NODE_625_length_39784_cov_20.366961",size: 39784,contig_type: "",structure: []},
{name: "NODE_626_length_39741_cov_23.227612",size: 39741,contig_type: "",structure: []},
{name: "NODE_627_length_39640_cov_699.651838",size: 39640,contig_type: "",structure: []},
{name: "NODE_628_length_39572_cov_10.944530",size: 39572,contig_type: "",structure: []},
{name: "NODE_629_length_39457_cov_693.031039",size: 39457,contig_type: "",structure: []},
{name: "NODE_630_length_39360_cov_15.608345",size: 39360,contig_type: "",structure: []},
{name: "NODE_631_length_39341_cov_16.993840",size: 39341,contig_type: "",structure: []},
{name: "NODE_632_length_39339_cov_8.812086",size: 39339,contig_type: "",structure: []},
{name: "NODE_633_length_39331_cov_10.315307",size: 39331,contig_type: "",structure: []},
{name: "NODE_634_length_39323_cov_14.566161",size: 39323,contig_type: "",structure: []},
{name: "NODE_635_length_39304_cov_21.769727",size: 39304,contig_type: "",structure: []},
{name: "NODE_636_length_39270_cov_9.018590",size: 39270,contig_type: "",structure: []},
{name: "NODE_637_length_39216_cov_21.518833",size: 39216,contig_type: "",structure: []},
{name: "NODE_638_length_39208_cov_13.041529",size: 39208,contig_type: "",structure: []},
{name: "NODE_639_length_39208_cov_7.022604",size: 39208,contig_type: "",structure: []},
{name: "NODE_640_length_39177_cov_22.353561",size: 39177,contig_type: "",structure: []},
{name: "NODE_641_length_39168_cov_10.054841",size: 39168,contig_type: "",structure: []},
{name: "NODE_642_length_39097_cov_7.522719",size: 39097,contig_type: "",structure: []},
{name: "NODE_643_length_39041_cov_23.732314",size: 39041,contig_type: "",structure: []},
{name: "NODE_644_length_39038_cov_71.538209",size: 39038,contig_type: "",structure: []},
{name: "NODE_645_length_39036_cov_12.597573",size: 39036,contig_type: "",structure: []},
{name: "NODE_646_length_39020_cov_22.229745",size: 39020,contig_type: "",structure: []},
{name: "NODE_647_length_39007_cov_8.363165",size: 39007,contig_type: "",structure: []},
{name: "NODE_648_length_38989_cov_9.352160",size: 38989,contig_type: "",structure: []},
{name: "NODE_649_length_38940_cov_34.792851",size: 38940,contig_type: "",structure: []},
{name: "NODE_650_length_38937_cov_17.830513",size: 38937,contig_type: "",structure: []},
{name: "NODE_651_length_38847_cov_10.585946",size: 38847,contig_type: "",structure: []},
{name: "NODE_652_length_38807_cov_15.286024",size: 38807,contig_type: "",structure: []},
{name: "NODE_653_length_38676_cov_45.211077",size: 38676,contig_type: "",structure: []},
{name: "NODE_654_length_38639_cov_15.512803",size: 38639,contig_type: "",structure: []},
{name: "NODE_655_length_38638_cov_10.365731",size: 38638,contig_type: "",structure: []},
{name: "NODE_656_length_38638_cov_7.443693",size: 38638,contig_type: "",structure: []},
{name: "NODE_657_length_38600_cov_48.762200",size: 38600,contig_type: "",structure: []},
{name: "NODE_658_length_38581_cov_45.582645",size: 38581,contig_type: "",structure: []},
{name: "NODE_659_length_38580_cov_29.143076",size: 38580,contig_type: "",structure: []},
{name: "NODE_660_length_38537_cov_15.304532",size: 38537,contig_type: "",structure: []},
{name: "NODE_661_length_38508_cov_28.306686",size: 38508,contig_type: "",structure: []},
{name: "NODE_662_length_38478_cov_22.887385",size: 38478,contig_type: "",structure: []},
{name: "NODE_663_length_38422_cov_10.208799",size: 38422,contig_type: "",structure: []},
{name: "NODE_664_length_38400_cov_9.270387",size: 38400,contig_type: "",structure: []},
{name: "NODE_665_length_38363_cov_9.390075",size: 38363,contig_type: "",structure: []},
{name: "NODE_666_length_38315_cov_8.889911",size: 38315,contig_type: "",structure: []},
{name: "NODE_667_length_38271_cov_7.605296",size: 38271,contig_type: "",structure: []},
{name: "NODE_668_length_38261_cov_23.271580",size: 38261,contig_type: "",structure: []},
{name: "NODE_669_length_38246_cov_18.457778",size: 38246,contig_type: "",structure: []},
{name: "NODE_670_length_38211_cov_13.592515",size: 38211,contig_type: "",structure: []},
{name: "NODE_671_length_38187_cov_6.893449",size: 38187,contig_type: "",structure: []},
{name: "NODE_672_length_38184_cov_9.366493",size: 38184,contig_type: "",structure: []},
{name: "NODE_673_length_38177_cov_13.122606",size: 38177,contig_type: "",structure: []},
{name: "NODE_674_length_38127_cov_11.057102",size: 38127,contig_type: "",structure: []},
{name: "NODE_675_length_38083_cov_17.658620",size: 38083,contig_type: "",structure: []},
{name: "NODE_676_length_38003_cov_10.014204",size: 38003,contig_type: "",structure: []},
{name: "NODE_677_length_37930_cov_7.702125",size: 37930,contig_type: "",structure: []},
{name: "NODE_678_length_37915_cov_11.920840",size: 37915,contig_type: "",structure: []},
{name: "NODE_679_length_37901_cov_8.687629",size: 37901,contig_type: "",structure: []},
{name: "NODE_680_length_37806_cov_18.515112",size: 37806,contig_type: "",structure: []},
{name: "NODE_681_length_37770_cov_73.491661",size: 37770,contig_type: "",structure: []},
{name: "NODE_682_length_37745_cov_11.864792",size: 37745,contig_type: "",structure: []},
{name: "NODE_683_length_37715_cov_22.341344",size: 37715,contig_type: "",structure: []},
{name: "NODE_684_length_37693_cov_11.917158",size: 37693,contig_type: "",structure: []},
{name: "NODE_685_length_37692_cov_50.293196",size: 37692,contig_type: "",structure: []},
{name: "NODE_686_length_37664_cov_13.549496",size: 37664,contig_type: "",structure: []},
{name: "NODE_687_length_37659_cov_8.652723",size: 37659,contig_type: "",structure: []},
{name: "NODE_688_length_37621_cov_12.905553",size: 37621,contig_type: "",structure: []},
{name: "NODE_689_length_37615_cov_13.519782",size: 37615,contig_type: "",structure: []},
{name: "NODE_690_length_37599_cov_14.944092",size: 37599,contig_type: "",structure: []},
{name: "NODE_691_length_37587_cov_22.669189",size: 37587,contig_type: "",structure: []},
{name: "NODE_692_length_37580_cov_696.907901",size: 37580,contig_type: "",structure: []},
{name: "NODE_693_length_37548_cov_6.014376",size: 37548,contig_type: "",structure: []},
{name: "NODE_694_length_37448_cov_20.025780",size: 37448,contig_type: "",structure: []},
{name: "NODE_695_length_37328_cov_16.361817",size: 37328,contig_type: "",structure: []},
{name: "NODE_696_length_37299_cov_10.755853",size: 37299,contig_type: "",structure: []},
{name: "NODE_697_length_37279_cov_11.579868",size: 37279,contig_type: "",structure: []},
{name: "NODE_698_length_37218_cov_27.078734",size: 37218,contig_type: "",structure: []},
{name: "NODE_699_length_37216_cov_15.044294",size: 37216,contig_type: "",structure: []},
{name: "NODE_700_length_37189_cov_22.294178",size: 37189,contig_type: "",structure: []},
{name: "NODE_701_length_37142_cov_8.442554",size: 37142,contig_type: "",structure: []},
{name: "NODE_702_length_37120_cov_10.069958",size: 37120,contig_type: "",structure: []},
{name: "NODE_703_length_37105_cov_51.866100",size: 37105,contig_type: "",structure: []},
{name: "NODE_704_length_37078_cov_11.598439",size: 37078,contig_type: "",structure: []},
{name: "NODE_705_length_37013_cov_10.102143",size: 37013,contig_type: "",structure: []},
{name: "NODE_706_length_37002_cov_46.458819",size: 37002,contig_type: "",structure: []},
{name: "NODE_707_length_36998_cov_7.069404",size: 36998,contig_type: "",structure: []},
{name: "NODE_708_length_36936_cov_10.583200",size: 36936,contig_type: "",structure: []},
{name: "NODE_709_length_36927_cov_22.015974",size: 36927,contig_type: "",structure: []},
{name: "NODE_710_length_36906_cov_11.160755",size: 36906,contig_type: "",structure: []},
{name: "NODE_711_length_36898_cov_8.445648",size: 36898,contig_type: "",structure: []},
{name: "NODE_712_length_36888_cov_18.347297",size: 36888,contig_type: "",structure: []},
{name: "NODE_713_length_36848_cov_13.976626",size: 36848,contig_type: "",structure: []},
{name: "NODE_714_length_36843_cov_66.490078",size: 36843,contig_type: "",structure: []},
{name: "NODE_715_length_36785_cov_6.608685",size: 36785,contig_type: "",structure: []},
{name: "NODE_716_length_36765_cov_10.548951",size: 36765,contig_type: "",structure: []},
{name: "NODE_717_length_36744_cov_7.833983",size: 36744,contig_type: "",structure: []},
{name: "NODE_718_length_36637_cov_28.649363",size: 36637,contig_type: "",structure: []},
{name: "NODE_719_length_36585_cov_6.304791",size: 36585,contig_type: "",structure: []},
{name: "NODE_720_length_36578_cov_14.343154",size: 36578,contig_type: "",structure: []},
{name: "NODE_721_length_36575_cov_7.975164",size: 36575,contig_type: "",structure: []},
{name: "NODE_722_length_36573_cov_41.038967",size: 36573,contig_type: "",structure: []},
{name: "NODE_723_length_36566_cov_23.880064",size: 36566,contig_type: "",structure: []},
{name: "NODE_724_length_36554_cov_19.945697",size: 36554,contig_type: "",structure: []},
{name: "NODE_725_length_36424_cov_19.339272",size: 36424,contig_type: "",structure: []},
{name: "NODE_726_length_36421_cov_48.144118",size: 36421,contig_type: "",structure: []},
{name: "NODE_727_length_36378_cov_53.978278",size: 36378,contig_type: "",structure: []},
{name: "NODE_728_length_36353_cov_64.471596",size: 36353,contig_type: "",structure: []},
{name: "NODE_729_length_36327_cov_19.192628",size: 36327,contig_type: "",structure: []},
{name: "NODE_730_length_36322_cov_5.984504",size: 36322,contig_type: "",structure: []},
{name: "NODE_731_length_36303_cov_6.594378",size: 36303,contig_type: "",structure: []},
{name: "NODE_732_length_36284_cov_12.393331",size: 36284,contig_type: "",structure: []},
{name: "NODE_733_length_36280_cov_20.716080",size: 36280,contig_type: "",structure: []},
{name: "NODE_734_length_36258_cov_24.235312",size: 36258,contig_type: "",structure: []},
{name: "NODE_735_length_36247_cov_22.167938",size: 36247,contig_type: "",structure: []},
{name: "NODE_736_length_36225_cov_54.250788",size: 36225,contig_type: "",structure: []},
{name: "NODE_737_length_36152_cov_9.725850",size: 36152,contig_type: "",structure: []},
{name: "NODE_738_length_36125_cov_11.499030",size: 36125,contig_type: "",structure: []},
{name: "NODE_739_length_36108_cov_7.561479",size: 36108,contig_type: "",structure: []},
{name: "NODE_740_length_36059_cov_32.278997",size: 36059,contig_type: "",structure: []},
{name: "NODE_741_length_36050_cov_19.907209",size: 36050,contig_type: "",structure: []},
{name: "NODE_742_length_36012_cov_22.331563",size: 36012,contig_type: "",structure: []},
{name: "NODE_743_length_36009_cov_37.599905",size: 36009,contig_type: "",structure: []},
{name: "NODE_744_length_35909_cov_14.064791",size: 35909,contig_type: "",structure: []},
{name: "NODE_745_length_35908_cov_8.789195",size: 35908,contig_type: "",structure: []},
{name: "NODE_746_length_35904_cov_13.350331",size: 35904,contig_type: "",structure: []},
{name: "NODE_747_length_35900_cov_9.514884",size: 35900,contig_type: "",structure: []},
{name: "NODE_748_length_35862_cov_15.060966",size: 35862,contig_type: "",structure: []},
{name: "NODE_749_length_35852_cov_22.489343",size: 35852,contig_type: "",structure: []},
{name: "NODE_750_length_35850_cov_7.336611",size: 35850,contig_type: "",structure: []},
{name: "NODE_751_length_35728_cov_11.387884",size: 35728,contig_type: "",structure: []},
{name: "NODE_752_length_35709_cov_17.544848",size: 35709,contig_type: "",structure: []},
{name: "NODE_753_length_35671_cov_18.257160",size: 35671,contig_type: "",structure: []},
{name: "NODE_754_length_35647_cov_24.924927",size: 35647,contig_type: "",structure: []},
{name: "NODE_755_length_35618_cov_24.188735",size: 35618,contig_type: "",structure: []},
{name: "NODE_756_length_35616_cov_15.556958",size: 35616,contig_type: "",structure: []},
{name: "NODE_757_length_35599_cov_24.633497",size: 35599,contig_type: "",structure: []},
{name: "NODE_758_length_35561_cov_6.861967",size: 35561,contig_type: "",structure: []},
{name: "NODE_759_length_35548_cov_12.836362",size: 35548,contig_type: "",structure: []},
{name: "NODE_760_length_35498_cov_11.668313",size: 35498,contig_type: "",structure: []},
{name: "NODE_761_length_35493_cov_15.146707",size: 35493,contig_type: "",structure: []},
{name: "NODE_762_length_35450_cov_17.385167",size: 35450,contig_type: "",structure: []},
{name: "NODE_763_length_35441_cov_18.344854",size: 35441,contig_type: "",structure: []},
{name: "NODE_764_length_35439_cov_14.056834",size: 35439,contig_type: "",structure: []},
{name: "NODE_765_length_35437_cov_14.717314",size: 35437,contig_type: "",structure: []},
{name: "NODE_766_length_35431_cov_20.107333",size: 35431,contig_type: "",structure: []},
{name: "NODE_767_length_35376_cov_18.627445",size: 35376,contig_type: "",structure: []},
{name: "NODE_768_length_35326_cov_13.403986",size: 35326,contig_type: "",structure: []},
{name: "NODE_769_length_35325_cov_20.728693",size: 35325,contig_type: "",structure: []},
{name: "NODE_770_length_35321_cov_26.676374",size: 35321,contig_type: "",structure: []},
{name: "NODE_771_length_35318_cov_35.995066",size: 35318,contig_type: "",structure: []},
{name: "NODE_772_length_35259_cov_10.418134",size: 35259,contig_type: "",structure: []},
{name: "NODE_773_length_35238_cov_27.586249",size: 35238,contig_type: "",structure: []},
{name: "NODE_774_length_35231_cov_13.757306",size: 35231,contig_type: "",structure: []},
{name: "NODE_775_length_35210_cov_6.303940",size: 35210,contig_type: "",structure: []},
{name: "NODE_776_length_35190_cov_13.620521",size: 35190,contig_type: "",structure: []},
{name: "NODE_777_length_35081_cov_17.457574",size: 35081,contig_type: "",structure: []},
{name: "NODE_778_length_35038_cov_33.526684",size: 35038,contig_type: "",structure: []},
{name: "NODE_779_length_35022_cov_18.353877",size: 35022,contig_type: "",structure: []},
{name: "NODE_780_length_35016_cov_71.738223",size: 35016,contig_type: "",structure: []},
{name: "NODE_781_length_35008_cov_21.564415",size: 35008,contig_type: "",structure: []},
{name: "NODE_782_length_34994_cov_26.799078",size: 34994,contig_type: "",structure: []},
{name: "NODE_783_length_34940_cov_21.609689",size: 34940,contig_type: "",structure: []},
{name: "NODE_784_length_34938_cov_19.560875",size: 34938,contig_type: "",structure: []},
{name: "NODE_785_length_34933_cov_15.819944",size: 34933,contig_type: "",structure: []},
{name: "NODE_786_length_34882_cov_11.165820",size: 34882,contig_type: "",structure: []},
{name: "NODE_787_length_34829_cov_6.147812",size: 34829,contig_type: "",structure: []},
{name: "NODE_788_length_34807_cov_9.872612",size: 34807,contig_type: "",structure: []},
{name: "NODE_789_length_34772_cov_46.749172",size: 34772,contig_type: "",structure: []},
{name: "NODE_790_length_34771_cov_35.005531",size: 34771,contig_type: "",structure: []},
{name: "NODE_791_length_34753_cov_14.012421",size: 34753,contig_type: "",structure: []},
{name: "NODE_792_length_34698_cov_27.231389",size: 34698,contig_type: "",structure: []},
{name: "NODE_793_length_34690_cov_12.335326",size: 34690,contig_type: "",structure: []},
{name: "NODE_794_length_34689_cov_7.993619",size: 34689,contig_type: "",structure: []},
{name: "NODE_795_length_34681_cov_34.208918",size: 34681,contig_type: "",structure: []},
{name: "NODE_796_length_34616_cov_16.523654",size: 34616,contig_type: "",structure: []},
{name: "NODE_797_length_34582_cov_14.971095",size: 34582,contig_type: "",structure: []},
{name: "NODE_798_length_34523_cov_29.612597",size: 34523,contig_type: "",structure: []},
{name: "NODE_799_length_34523_cov_15.130382",size: 34523,contig_type: "",structure: []},
{name: "NODE_800_length_34482_cov_10.542394",size: 34482,contig_type: "",structure: []},
{name: "NODE_801_length_34470_cov_672.849136",size: 34470,contig_type: "",structure: []},
{name: "NODE_802_length_34429_cov_12.477163",size: 34429,contig_type: "",structure: []},
{name: "NODE_803_length_34373_cov_10.827437",size: 34373,contig_type: "",structure: []},
{name: "NODE_804_length_34353_cov_6.817774",size: 34353,contig_type: "",structure: []},
{name: "NODE_805_length_34317_cov_15.136945",size: 34317,contig_type: "",structure: []},
{name: "NODE_806_length_34285_cov_9.498773",size: 34285,contig_type: "",structure: []},
{name: "NODE_807_length_34282_cov_13.496304",size: 34282,contig_type: "",structure: []},
{name: "NODE_808_length_34278_cov_11.303451",size: 34278,contig_type: "",structure: []},
{name: "NODE_809_length_34231_cov_19.249034",size: 34231,contig_type: "",structure: []},
{name: "NODE_810_length_34197_cov_32.608107",size: 34197,contig_type: "",structure: []},
{name: "NODE_811_length_34169_cov_7.383479",size: 34169,contig_type: "",structure: []},
{name: "NODE_812_length_34168_cov_14.112098",size: 34168,contig_type: "",structure: []},
{name: "NODE_813_length_34127_cov_21.106216",size: 34127,contig_type: "",structure: []},
{name: "NODE_814_length_34105_cov_7.672070",size: 34105,contig_type: "",structure: []},
{name: "NODE_815_length_34074_cov_51.823216",size: 34074,contig_type: "",structure: []},
{name: "NODE_816_length_34073_cov_8.807249",size: 34073,contig_type: "",structure: []},
{name: "NODE_817_length_34069_cov_22.812930",size: 34069,contig_type: "",structure: []},
{name: "NODE_818_length_34045_cov_21.928214",size: 34045,contig_type: "",structure: []},
{name: "NODE_819_length_34043_cov_30.431093",size: 34043,contig_type: "",structure: []},
{name: "NODE_820_length_34041_cov_23.736568",size: 34041,contig_type: "",structure: []},
{name: "NODE_821_length_34030_cov_27.676851",size: 34030,contig_type: "",structure: []},
{name: "NODE_822_length_34029_cov_7.617266",size: 34029,contig_type: "",structure: []},
{name: "NODE_823_length_34014_cov_9.110869",size: 34014,contig_type: "",structure: []},
{name: "NODE_824_length_34000_cov_9.252821",size: 34000,contig_type: "",structure: []},
{name: "NODE_825_length_33959_cov_20.833117",size: 33959,contig_type: "",structure: []},
{name: "NODE_826_length_33923_cov_11.390162",size: 33923,contig_type: "",structure: []},
{name: "NODE_827_length_33876_cov_17.077526",size: 33876,contig_type: "",structure: []},
{name: "NODE_828_length_33870_cov_8.186663",size: 33870,contig_type: "",structure: []},
{name: "NODE_829_length_33847_cov_17.829102",size: 33847,contig_type: "",structure: []},
{name: "NODE_830_length_33841_cov_8.603652",size: 33841,contig_type: "",structure: []},
{name: "NODE_831_length_33828_cov_21.713381",size: 33828,contig_type: "",structure: []},
{name: "NODE_832_length_33819_cov_7.904484",size: 33819,contig_type: "",structure: []},
{name: "NODE_833_length_33778_cov_13.662930",size: 33778,contig_type: "",structure: []},
{name: "NODE_834_length_33655_cov_31.624137",size: 33655,contig_type: "",structure: []},
{name: "NODE_835_length_33620_cov_8.489856",size: 33620,contig_type: "",structure: []},
{name: "NODE_836_length_33619_cov_12.844208",size: 33619,contig_type: "",structure: []},
{name: "NODE_837_length_33611_cov_18.649124",size: 33611,contig_type: "",structure: []},
{name: "NODE_838_length_33602_cov_11.721078",size: 33602,contig_type: "",structure: []},
{name: "NODE_839_length_33592_cov_7.674032",size: 33592,contig_type: "",structure: []},
{name: "NODE_840_length_33590_cov_16.801968",size: 33590,contig_type: "",structure: []},
{name: "NODE_841_length_33528_cov_9.914080",size: 33528,contig_type: "",structure: []},
{name: "NODE_842_length_33516_cov_14.054362",size: 33516,contig_type: "",structure: []},
{name: "NODE_843_length_33506_cov_12.276763",size: 33506,contig_type: "",structure: []},
{name: "NODE_844_length_33498_cov_31.626050",size: 33498,contig_type: "",structure: []},
{name: "NODE_845_length_33487_cov_12.812814",size: 33487,contig_type: "",structure: []},
{name: "NODE_846_length_33474_cov_6.157994",size: 33474,contig_type: "",structure: []},
{name: "NODE_847_length_33465_cov_23.113050",size: 33465,contig_type: "",structure: []},
{name: "NODE_848_length_33432_cov_25.644276",size: 33432,contig_type: "",structure: []},
{name: "NODE_849_length_33407_cov_8.233059",size: 33407,contig_type: "",structure: []},
{name: "NODE_850_length_33375_cov_11.262365",size: 33375,contig_type: "",structure: []},
{name: "NODE_851_length_33349_cov_44.091398",size: 33349,contig_type: "",structure: []},
{name: "NODE_852_length_33341_cov_13.110046",size: 33341,contig_type: "",structure: []},
{name: "NODE_853_length_33332_cov_68.150434",size: 33332,contig_type: "",structure: []},
{name: "NODE_854_length_33311_cov_26.505262",size: 33311,contig_type: "",structure: []},
{name: "NODE_855_length_33309_cov_21.131774",size: 33309,contig_type: "",structure: []},
{name: "NODE_856_length_33289_cov_20.532076",size: 33289,contig_type: "",structure: []},
{name: "NODE_857_length_33274_cov_6.118185",size: 33274,contig_type: "",structure: []},
{name: "NODE_858_length_33273_cov_20.621260",size: 33273,contig_type: "",structure: []},
{name: "NODE_859_length_33270_cov_16.799639",size: 33270,contig_type: "",structure: []},
{name: "NODE_860_length_33249_cov_11.649786",size: 33249,contig_type: "",structure: []},
{name: "NODE_861_length_33229_cov_7.173600",size: 33229,contig_type: "",structure: []},
{name: "NODE_862_length_33195_cov_17.573446",size: 33195,contig_type: "",structure: []},
{name: "NODE_863_length_33186_cov_20.047629",size: 33186,contig_type: "",structure: []},
{name: "NODE_864_length_33167_cov_18.657586",size: 33167,contig_type: "",structure: []},
{name: "NODE_865_length_33154_cov_39.353545",size: 33154,contig_type: "",structure: []},
{name: "NODE_866_length_33129_cov_23.081514",size: 33129,contig_type: "",structure: []},
{name: "NODE_867_length_33124_cov_70.667483",size: 33124,contig_type: "",structure: []},
{name: "NODE_868_length_33117_cov_8.859143",size: 33117,contig_type: "",structure: []},
{name: "NODE_869_length_33116_cov_12.503705",size: 33116,contig_type: "",structure: []},
{name: "NODE_870_length_33070_cov_13.937059",size: 33070,contig_type: "",structure: []},
{name: "NODE_871_length_33062_cov_12.105917",size: 33062,contig_type: "",structure: []},
{name: "NODE_872_length_33038_cov_14.978898",size: 33038,contig_type: "",structure: []},
{name: "NODE_873_length_33015_cov_12.811893",size: 33015,contig_type: "",structure: []},
{name: "NODE_874_length_33006_cov_6.325665",size: 33006,contig_type: "",structure: []},
{name: "NODE_875_length_32962_cov_24.484547",size: 32962,contig_type: "",structure: []},
{name: "NODE_876_length_32907_cov_11.860069",size: 32907,contig_type: "",structure: []},
{name: "NODE_877_length_32902_cov_12.808141",size: 32902,contig_type: "",structure: []},
{name: "NODE_878_length_32902_cov_9.616312",size: 32902,contig_type: "",structure: []},
{name: "NODE_879_length_32889_cov_27.177651",size: 32889,contig_type: "",structure: []},
{name: "NODE_880_length_32887_cov_71.864096",size: 32887,contig_type: "",structure: []},
{name: "NODE_881_length_32856_cov_7.167342",size: 32856,contig_type: "",structure: []},
{name: "NODE_882_length_32854_cov_13.252813",size: 32854,contig_type: "",structure: []},
{name: "NODE_883_length_32844_cov_7.252676",size: 32844,contig_type: "",structure: []},
{name: "NODE_884_length_32839_cov_9.042917",size: 32839,contig_type: "",structure: []},
{name: "NODE_885_length_32831_cov_29.294697",size: 32831,contig_type: "",structure: []},
{name: "NODE_886_length_32811_cov_10.296404",size: 32811,contig_type: "",structure: []},
{name: "NODE_887_length_32802_cov_8.739671",size: 32802,contig_type: "",structure: []},
{name: "NODE_888_length_32792_cov_7.469041",size: 32792,contig_type: "",structure: []},
{name: "NODE_889_length_32777_cov_20.736630",size: 32777,contig_type: "",structure: []},
{name: "NODE_890_length_32729_cov_23.440473",size: 32729,contig_type: "",structure: []},
{name: "NODE_891_length_32721_cov_24.280230",size: 32721,contig_type: "",structure: []},
{name: "NODE_892_length_32707_cov_20.639777",size: 32707,contig_type: "",structure: []},
{name: "NODE_893_length_32647_cov_639.901325",size: 32647,contig_type: "",structure: []},
{name: "NODE_894_length_32612_cov_8.504531",size: 32612,contig_type: "",structure: []},
{name: "NODE_895_length_32608_cov_6.625902",size: 32608,contig_type: "",structure: []},
{name: "NODE_896_length_32608_cov_5.912573",size: 32608,contig_type: "",structure: []},
{name: "NODE_897_length_32586_cov_8.490363",size: 32586,contig_type: "",structure: []},
{name: "NODE_898_length_32568_cov_12.306708",size: 32568,contig_type: "",structure: []},
{name: "NODE_899_length_32567_cov_8.750677",size: 32567,contig_type: "",structure: []},
{name: "NODE_900_length_32554_cov_48.583710",size: 32554,contig_type: "",structure: []},
{name: "NODE_901_length_32532_cov_7.419897",size: 32532,contig_type: "",structure: []},
{name: "NODE_902_length_32512_cov_24.074036",size: 32512,contig_type: "",structure: []},
{name: "NODE_903_length_32511_cov_42.386492",size: 32511,contig_type: "",structure: []},
{name: "NODE_904_length_32500_cov_85.030020",size: 32500,contig_type: "",structure: []},
{name: "NODE_905_length_32485_cov_7.421523",size: 32485,contig_type: "",structure: []},
{name: "NODE_906_length_32478_cov_11.837492",size: 32478,contig_type: "",structure: []},
{name: "NODE_907_length_32443_cov_9.183247",size: 32443,contig_type: "",structure: []},
{name: "NODE_908_length_32402_cov_6.984728",size: 32402,contig_type: "",structure: []},
{name: "NODE_909_length_32397_cov_636.042112",size: 32397,contig_type: "",structure: []},
{name: "NODE_910_length_32355_cov_13.125913",size: 32355,contig_type: "",structure: []},
{name: "NODE_911_length_32351_cov_9.459159",size: 32351,contig_type: "",structure: []},
{name: "NODE_912_length_32340_cov_19.957565",size: 32340,contig_type: "",structure: []},
{name: "NODE_913_length_32332_cov_13.777272",size: 32332,contig_type: "",structure: []},
{name: "NODE_914_length_32284_cov_12.712960",size: 32284,contig_type: "",structure: []},
{name: "NODE_915_length_32239_cov_10.529611",size: 32239,contig_type: "",structure: []},
{name: "NODE_916_length_32227_cov_10.194641",size: 32227,contig_type: "",structure: []},
{name: "NODE_917_length_32223_cov_7.877736",size: 32223,contig_type: "",structure: []},
{name: "NODE_918_length_32222_cov_10.197127",size: 32222,contig_type: "",structure: []},
{name: "NODE_919_length_32190_cov_15.749183",size: 32190,contig_type: "",structure: []},
{name: "NODE_920_length_32168_cov_17.518232",size: 32168,contig_type: "",structure: []},
{name: "NODE_921_length_32154_cov_39.905947",size: 32154,contig_type: "",structure: []},
{name: "NODE_922_length_32153_cov_24.770733",size: 32153,contig_type: "",structure: []},
{name: "NODE_923_length_32136_cov_26.240204",size: 32136,contig_type: "",structure: []},
{name: "NODE_924_length_32132_cov_12.500577",size: 32132,contig_type: "",structure: []},
{name: "NODE_925_length_32106_cov_7.834483",size: 32106,contig_type: "",structure: []},
{name: "NODE_926_length_32072_cov_9.248899",size: 32072,contig_type: "",structure: []},
{name: "NODE_927_length_32061_cov_11.791227",size: 32061,contig_type: "",structure: []},
{name: "NODE_928_length_32037_cov_9.787130",size: 32037,contig_type: "",structure: []},
{name: "NODE_929_length_32037_cov_6.644206",size: 32037,contig_type: "",structure: []},
{name: "NODE_930_length_32006_cov_18.340083",size: 32006,contig_type: "",structure: []},
{name: "NODE_931_length_32005_cov_6.257089",size: 32005,contig_type: "",structure: []},
{name: "NODE_932_length_32000_cov_19.028768",size: 32000,contig_type: "",structure: []},
{name: "NODE_933_length_31977_cov_11.557202",size: 31977,contig_type: "",structure: []},
{name: "NODE_934_length_31968_cov_7.666030",size: 31968,contig_type: "",structure: []},
{name: "NODE_935_length_31963_cov_6.676037",size: 31963,contig_type: "",structure: []},
{name: "NODE_936_length_31957_cov_19.872955",size: 31957,contig_type: "",structure: []},
{name: "NODE_937_length_31920_cov_7.079931",size: 31920,contig_type: "",structure: []},
{name: "NODE_938_length_31911_cov_12.248085",size: 31911,contig_type: "",structure: []},
{name: "NODE_939_length_31894_cov_25.987562",size: 31894,contig_type: "",structure: []},
{name: "NODE_940_length_31878_cov_11.794551",size: 31878,contig_type: "",structure: []},
{name: "NODE_941_length_31865_cov_5.790380",size: 31865,contig_type: "",structure: []},
{name: "NODE_942_length_31841_cov_24.626691",size: 31841,contig_type: "",structure: []},
{name: "NODE_943_length_31836_cov_24.089424",size: 31836,contig_type: "",structure: []},
{name: "NODE_944_length_31803_cov_27.620480",size: 31803,contig_type: "",structure: []},
{name: "NODE_945_length_31789_cov_22.582120",size: 31789,contig_type: "",structure: []},
{name: "NODE_946_length_31778_cov_33.230527",size: 31778,contig_type: "",structure: []},
{name: "NODE_947_length_31762_cov_9.590532",size: 31762,contig_type: "",structure: []},
{name: "NODE_948_length_31756_cov_14.494748",size: 31756,contig_type: "",structure: []},
{name: "NODE_949_length_31751_cov_9.385317",size: 31751,contig_type: "",structure: []},
{name: "NODE_950_length_31747_cov_25.743216",size: 31747,contig_type: "",structure: []},
{name: "NODE_951_length_31727_cov_12.704881",size: 31727,contig_type: "",structure: []},
{name: "NODE_952_length_31720_cov_19.985852",size: 31720,contig_type: "",structure: []},
{name: "NODE_953_length_31651_cov_26.948823",size: 31651,contig_type: "",structure: []},
{name: "NODE_954_length_31621_cov_8.913610",size: 31621,contig_type: "",structure: []},
{name: "NODE_955_length_31619_cov_8.856039",size: 31619,contig_type: "",structure: []},
{name: "NODE_956_length_31585_cov_12.776435",size: 31585,contig_type: "",structure: []},
{name: "NODE_957_length_31582_cov_8.722270",size: 31582,contig_type: "",structure: []},
{name: "NODE_958_length_31581_cov_6.772188",size: 31581,contig_type: "",structure: []},
{name: "NODE_959_length_31557_cov_46.404927",size: 31557,contig_type: "",structure: []},
{name: "NODE_960_length_31549_cov_16.530768",size: 31549,contig_type: "",structure: []},
{name: "NODE_961_length_31518_cov_14.063980",size: 31518,contig_type: "",structure: []},
{name: "NODE_962_length_31513_cov_22.249412",size: 31513,contig_type: "",structure: []},
{name: "NODE_963_length_31463_cov_13.470963",size: 31463,contig_type: "",structure: []},
{name: "NODE_964_length_31461_cov_53.441954",size: 31461,contig_type: "",structure: []},
{name: "NODE_965_length_31444_cov_17.097932",size: 31444,contig_type: "",structure: []},
{name: "NODE_966_length_31401_cov_27.126268",size: 31401,contig_type: "",structure: []},
{name: "NODE_967_length_31396_cov_14.417121",size: 31396,contig_type: "",structure: []},
{name: "NODE_968_length_31379_cov_18.073809",size: 31379,contig_type: "",structure: []},
{name: "NODE_969_length_31350_cov_6.794184",size: 31350,contig_type: "",structure: []},
{name: "NODE_970_length_31303_cov_9.167915",size: 31303,contig_type: "",structure: []},
{name: "NODE_971_length_31291_cov_16.902132",size: 31291,contig_type: "",structure: []},
{name: "NODE_972_length_31279_cov_7.011369",size: 31279,contig_type: "",structure: []},
{name: "NODE_973_length_31272_cov_13.893808",size: 31272,contig_type: "",structure: []},
{name: "NODE_974_length_31255_cov_9.789006",size: 31255,contig_type: "",structure: []},
{name: "NODE_975_length_31253_cov_6.928201",size: 31253,contig_type: "",structure: []},
{name: "NODE_976_length_31235_cov_17.305516",size: 31235,contig_type: "",structure: []},
{name: "NODE_977_length_31230_cov_45.145662",size: 31230,contig_type: "",structure: []},
{name: "NODE_978_length_31220_cov_40.078389",size: 31220,contig_type: "",structure: []},
{name: "NODE_979_length_31214_cov_11.579062",size: 31214,contig_type: "",structure: []},
{name: "NODE_980_length_31208_cov_13.257022",size: 31208,contig_type: "",structure: []},
{name: "NODE_981_length_31202_cov_75.229107",size: 31202,contig_type: "",structure: []},
{name: "NODE_982_length_31179_cov_18.269342",size: 31179,contig_type: "",structure: []},
{name: "NODE_983_length_31135_cov_13.158398",size: 31135,contig_type: "",structure: []},
{name: "NODE_984_length_31127_cov_19.587893",size: 31127,contig_type: "",structure: []},
{name: "NODE_985_length_31126_cov_5.563258",size: 31126,contig_type: "",structure: []},
{name: "NODE_986_length_31078_cov_17.974825",size: 31078,contig_type: "",structure: []},
{name: "NODE_987_length_31057_cov_19.986194",size: 31057,contig_type: "",structure: []},
{name: "NODE_988_length_31003_cov_14.352430",size: 31003,contig_type: "",structure: []},
{name: "NODE_989_length_31002_cov_11.349081",size: 31002,contig_type: "",structure: []},
{name: "NODE_990_length_30988_cov_8.866647",size: 30988,contig_type: "",structure: []},
{name: "NODE_991_length_30969_cov_12.849583",size: 30969,contig_type: "",structure: []},
{name: "NODE_992_length_30934_cov_16.369507",size: 30934,contig_type: "",structure: []},
{name: "NODE_993_length_30928_cov_22.226573",size: 30928,contig_type: "",structure: []},
{name: "NODE_994_length_30915_cov_8.658004",size: 30915,contig_type: "",structure: []},
{name: "NODE_995_length_30899_cov_9.673064",size: 30899,contig_type: "",structure: []},
{name: "NODE_996_length_30895_cov_15.291148",size: 30895,contig_type: "",structure: []},
{name: "NODE_997_length_30881_cov_31.159573",size: 30881,contig_type: "",structure: []},
{name: "NODE_998_length_30869_cov_9.879860",size: 30869,contig_type: "",structure: []},
{name: "NODE_999_length_30864_cov_8.383816",size: 30864,contig_type: "",structure: []},
{name: "NODE_1000_length_30861_cov_17.961533",size: 30861,contig_type: "",structure: []},
{name: "255913 hidden contigs shorter than 30861 bp (total length: 616 965 831 bp)", size: 616965831, contig_type:"small_contigs"}];

var contigLines = [{assembly: "final_assembly", corr_end: 337568305, label: "N50", size: 3183},{assembly: "final_assembly", corr_end: 506356314, label: "N75", size: 1609}];

var contigs_total_len = 674983205;
var minContigSize = 500;var links_to_chromosomes;
links_to_chromosomes = {};
</script>
    <script type="text/javascript">
(function() {

    if (!Array.prototype.map) {

      Array.prototype.map = function(callback, thisArg) {

        var T, A, k;

        if (this == null) {
          throw new TypeError(' this is null or not defined');
        }

        // 1. Let O be the result of calling ToObject passing the |this|
        //    value as the argument.
        var O = Object(this);

        // 2. Let lenValue be the result of calling the Get internal
        //    method of O with the argument "length".
        // 3. Let len be ToUint32(lenValue).
        var len = O.length >>> 0;

        // 4. If IsCallable(callback) is false, throw a TypeError exception.
        // See: http://es5.github.com/#x9.11
        if (typeof callback !== 'function') {
          throw new TypeError(callback + ' is not a function');
        }

        // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.
        if (arguments.length > 1) {
          T = thisArg;
        }

        // 6. Let A be a new array created as if by the expression new Array(len)
        //    where Array is the standard built-in constructor with that name and
        //    len is the value of len.
        A = new Array(len);

        // 7. Let k be 0
        k = 0;

        // 8. Repeat, while k < len
        while (k < len) {

          var kValue, mappedValue;

          // a. Let Pk be ToString(k).
          //   This is implicit for LHS operands of the in operator
          // b. Let kPresent be the result of calling the HasProperty internal
          //    method of O with argument Pk.
          //   This step can be combined with c
          // c. If kPresent is true, then
          if (k in O) {

            // i. Let kValue be the result of calling the Get internal
            //    method of O with argument Pk.
            kValue = O[k];

            // ii. Let mappedValue be the result of calling the Call internal
            //     method of callback with T as the this value and argument
            //     list containing kValue, k, and O.
            mappedValue = callback.call(T, kValue, k, O);

            // iii. Call the DefineOwnProperty internal method of A with arguments
            // Pk, Property Descriptor
            // { Value: mappedValue,
            //   Writable: true,
            //   Enumerable: true,
            //   Configurable: true },
            // and false.

            // In browsers that support Object.defineProperty, use the following:
            // Object.defineProperty(A, k, {
            //   value: mappedValue,
            //   writable: true,
            //   enumerable: true,
            //   configurable: true
            // });

            // For best browser support, use the following:
            A[k] = mappedValue;
          }
          // d. Increase k by 1.
          k++;
        }

        // 9. return A
        return A;
      };
    }

    if (!Array.prototype.filter) {
      Array.prototype.filter = function(fun/*, thisArg*/) {
        'use strict';

        if (this === void 0 || this === null) {
          throw new TypeError();
        }

        var t = Object(this);
        var len = t.length >>> 0;
        if (typeof fun !== 'function') {
          throw new TypeError();
        }

        var res = [];
        var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
        for (var i = 0; i < len; i++) {
          if (i in t) {
            var val = t[i];

            // NOTE: Technically this should Object.defineProperty at
            //       the next index, as push can be affected by
            //       properties on Object.prototype and Array.prototype.
            //       But that method's new, and collisions should be
            //       rare, so use the more-compatible alternative.
            if (fun.call(thisArg, val, i, t)) {
              res.push(val);
            }
          }
        }

        return res;
      };
    }

  // Шаги алгоритма ECMA-262, 5-е издание, 15.4.4.18
  // Ссылка (en): http://es5.github.io/#x15.4.4.18
  // Ссылка (ru): http://es5.javascript.ru/x15.4.html#x15.4.4.18
  if (!Array.prototype.forEach) {

    Array.prototype.forEach = function (callback, thisArg) {

      var T, k;

      if (this == null) {
        throw new TypeError(' this is null or not defined');
      }

      // 1. Положим O равным результату вызова ToObject passing the |this| value as the argument.
      var O = Object(this);

      // 2. Положим lenValue равным результату вызова внутреннего метода Get объекта O с аргументом "length".
      // 3. Положим len равным ToUint32(lenValue).
      var len = O.length >>> 0;

      // 4. Если IsCallable(callback) равен false, выкинем исключение TypeError.
      // Смотрите: http://es5.github.com/#x9.11
      if (typeof callback !== 'function') {
          throw new TypeError(callback + ' is not a function');
      }

      // 5. Если thisArg присутствует, положим T равным thisArg; иначе положим T равным undefined.
      if (arguments.length > 1) {
        T = thisArg;
      }

      // 6. Положим k равным 0
      k = 0;

      // 7. Пока k < len, будем повторять
      while (k < len) {

        var kValue;

        // a. Положим Pk равным ToString(k).
        //   Это неявное преобразование для левостороннего операнда в операторе in
        // b. Положим kPresent равным результату вызова внутреннего метода HasProperty объекта O с аргументом Pk.
        //   Этот шаг может быть объединён с шагом c
        // c. Если kPresent равен true, то
        if (k in O) {

          // i. Положим kValue равным результату вызова внутреннего метода Get объекта O с аргументом Pk.
          kValue = O[k];

          // ii. Вызовем внутренний метод Call функции callback с объектом T в качестве значения this и
          // списком аргументов, содержащим kValue, k и O.
          callback.call(T, kValue, k, O);
        }
        // d. Увеличим k на 1.
        k++;
      }
      // 8. Вернём undefined.
    };
  }

  function d3_class(ctor, properties) {
    try {
      for (var key in properties) {
        Object.defineProperty(ctor.prototype, key, {
          value: properties[key],
          enumerable: false
        });
      }
    } catch (e) {
      ctor.prototype = properties;
    }
  }
  function d3_arrayCopy(pseudoarray) {
    var i = -1, n = pseudoarray.length, array = [];
    while (++i < n) array.push(pseudoarray[i]);
    return array;
  }
  function d3_arraySlice(pseudoarray) {
    return Array.prototype.slice.call(pseudoarray);
  }
  function d3_Map() {}
  function d3_identity(d) {
    return d;
  }
  function d3_this() {
    return this;
  }
  function d3_true() {
    return true;
  }
  function d3_functor(v) {
    return typeof v === "function" ? v : function() {
      return v;
    };
  }
  function d3_rebind(target, source, method) {
    return function() {
      var value = method.apply(source, arguments);
      return arguments.length ? target : value;
    };
  }
  function d3_number(x) {
    return x != null && !isNaN(x);
  }
  function d3_zipLength(d) {
    return d.length;
  }
  function d3_splitter(d) {
    return d == null;
  }
  function d3_collapse(s) {
    return s.trim().replace(/\s+/g, " ");
  }
  function d3_range_integerScale(x) {
    var k = 1;
    while (x * k % 1) k *= 10;
    return k;
  }
  function d3_dispatch() {}
  function d3_dispatch_event(dispatch) {
    function event() {
      var z = listeners, i = -1, n = z.length, l;
      while (++i < n) if (l = z[i].on) l.apply(this, arguments);
      return dispatch;
    }
    var listeners = [], listenerByName = new d3_Map;
    event.on = function(name, listener) {
      var l = listenerByName.get(name), i;
      if (arguments.length < 2) return l && l.on;
      if (l) {
        l.on = null;
        listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
        listenerByName.remove(name);
      }
      if (listener) listeners.push(listenerByName.set(name, {
        on: listener
      }));
      return dispatch;
    };
    return event;
  }
  function d3_format_precision(x, p) {
    return p - (x ? 1 + Math.floor(Math.log(x + Math.pow(10, 1 + Math.floor(Math.log(x) / Math.LN10) - p)) / Math.LN10) : 1);
  }
  function d3_format_typeDefault(x) {
    return x + "";
  }
  function d3_format_group(value) {
    var i = value.lastIndexOf("."), f = i >= 0 ? value.substring(i) : (i = value.length, ""), t = [];
    while (i > 0) t.push(value.substring(i -= 3, i + 3));
    return t.reverse().join(",") + f;
  }
  function d3_formatPrefix(d, i) {
    var k = Math.pow(10, Math.abs(8 - i) * 3);
    return {
      scale: i > 8 ? function(d) {
        return d / k;
      } : function(d) {
        return d * k;
      },
      symbol: d
    };
  }
  function d3_ease_clamp(f) {
    return function(t) {
      return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
    };
  }
  function d3_ease_reverse(f) {
    return function(t) {
      return 1 - f(1 - t);
    };
  }
  function d3_ease_reflect(f) {
    return function(t) {
      return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));
    };
  }
  function d3_ease_identity(t) {
    return t;
  }
  function d3_ease_poly(e) {
    return function(t) {
      return Math.pow(t, e);
    };
  }
  function d3_ease_sin(t) {
    return 1 - Math.cos(t * Math.PI / 2);
  }
  function d3_ease_exp(t) {
    return Math.pow(2, 10 * (t - 1));
  }
  function d3_ease_circle(t) {
    return 1 - Math.sqrt(1 - t * t);
  }
  function d3_ease_elastic(a, p) {
    var s;
    if (arguments.length < 2) p = .45;
    if (arguments.length < 1) {
      a = 1;
      s = p / 4;
    } else s = p / (2 * Math.PI) * Math.asin(1 / a);
    return function(t) {
      return 1 + a * Math.pow(2, 10 * -t) * Math.sin((t - s) * 2 * Math.PI / p);
    };
  }
  function d3_ease_back(s) {
    if (!s) s = 1.70158;
    return function(t) {
      return t * t * ((s + 1) * t - s);
    };
  }
  function d3_ease_bounce(t) {
    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
  }
  function d3_eventCancel() {
    d3.event.stopPropagation();
    d3.event.preventDefault();
  }
  function d3_eventSource() {
    var e = d3.event, s;
    while (s = e.sourceEvent) e = s;
    return e;
  }
  function d3_eventDispatch(target) {
    var dispatch = new d3_dispatch, i = 0, n = arguments.length;
    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
    dispatch.of = function(thiz, argumentz) {
      return function(e1) {
        try {
          var e0 = e1.sourceEvent = d3.event;
          e1.target = target;
          d3.event = e1;
          dispatch[e1.type].apply(thiz, argumentz);
        } finally {
          d3.event = e0;
        }
      };
    };
    return dispatch;
  }
  function d3_transform(m) {
    var r0 = [ m.a, m.b ], r1 = [ m.c, m.d ], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
    if (r0[0] * r1[1] < r1[0] * r0[1]) {
      r0[0] *= -1;
      r0[1] *= -1;
      kx *= -1;
      kz *= -1;
    }
    this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_transformDegrees;
    this.translate = [ m.e, m.f ];
    this.scale = [ kx, ky ];
    this.skew = ky ? Math.atan2(kz, ky) * d3_transformDegrees : 0;
  }
  function d3_transformDot(a, b) {
    return a[0] * b[0] + a[1] * b[1];
  }
  function d3_transformNormalize(a) {
    var k = Math.sqrt(d3_transformDot(a, a));
    if (k) {
      a[0] /= k;
      a[1] /= k;
    }
    return k;
  }
  function d3_transformCombine(a, b, k) {
    a[0] += k * b[0];
    a[1] += k * b[1];
    return a;
  }
  function d3_interpolateByName(name) {
    return name == "transform" ? d3.interpolateTransform : d3.interpolate;
  }
  function d3_uninterpolateNumber(a, b) {
    b = b - (a = +a) ? 1 / (b - a) : 0;
    return function(x) {
      return (x - a) * b;
    };
  }
  function d3_uninterpolateClamp(a, b) {
    b = b - (a = +a) ? 1 / (b - a) : 0;
    return function(x) {
      return Math.max(0, Math.min(1, (x - a) * b));
    };
  }
  function d3_Color() {}
  function d3_rgb(r, g, b) {
    return new d3_Rgb(r, g, b);
  }
  function d3_Rgb(r, g, b) {
    this.r = r;
    this.g = g;
    this.b = b;
  }
  function d3_rgb_hex(v) {
    return v < 16 ? "0" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);
  }
  function d3_rgb_parse(format, rgb, hsl) {
    var r = 0, g = 0, b = 0, m1, m2, name;
    m1 = /([a-z]+)\((.*)\)/i.exec(format);
    if (m1) {
      m2 = m1[2].split(",");
      switch (m1[1]) {
       case "hsl":
        {
          return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);
        }
       case "rgb":
        {
          return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));
        }
      }
    }
    if (name = d3_rgb_names.get(format)) return rgb(name.r, name.g, name.b);
    if (format != null && format.charAt(0) === "#") {
      if (format.length === 4) {
        r = format.charAt(1);
        r += r;
        g = format.charAt(2);
        g += g;
        b = format.charAt(3);
        b += b;
      } else if (format.length === 7) {
        r = format.substring(1, 3);
        g = format.substring(3, 5);
        b = format.substring(5, 7);
      }
      r = parseInt(r, 16);
      g = parseInt(g, 16);
      b = parseInt(b, 16);
    }
    return rgb(r, g, b);
  }
  function d3_rgb_hsl(r, g, b) {
    var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2;
    if (d) {
      s = l < .5 ? d / (max + min) : d / (2 - max - min);
      if (r == max) h = (g - b) / d + (g < b ? 6 : 0); else if (g == max) h = (b - r) / d + 2; else h = (r - g) / d + 4;
      h *= 60;
    } else {
      s = h = 0;
    }
    return d3_hsl(h, s, l);
  }
  function d3_rgb_lab(r, g, b) {
    r = d3_rgb_xyz(r);
    g = d3_rgb_xyz(g);
    b = d3_rgb_xyz(b);
    var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X), y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y), z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);
    return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));
  }
  function d3_rgb_xyz(r) {
    return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);
  }
  function d3_rgb_parseNumber(c) {
    var f = parseFloat(c);
    return c.charAt(c.length - 1) === "%" ? Math.round(f * 2.55) : f;
  }
  function d3_hsl(h, s, l) {
    return new d3_Hsl(h, s, l);
  }
  function d3_Hsl(h, s, l) {
    this.h = h;
    this.s = s;
    this.l = l;
  }
  function d3_hsl_rgb(h, s, l) {
    function v(h) {
      if (h > 360) h -= 360; else if (h < 0) h += 360;
      if (h < 60) return m1 + (m2 - m1) * h / 60;
      if (h < 180) return m2;
      if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;
      return m1;
    }
    function vv(h) {
      return Math.round(v(h) * 255);
    }
    var m1, m2;
    h = h % 360;
    if (h < 0) h += 360;
    s = s < 0 ? 0 : s > 1 ? 1 : s;
    l = l < 0 ? 0 : l > 1 ? 1 : l;
    m2 = l <= .5 ? l * (1 + s) : l + s - l * s;
    m1 = 2 * l - m2;
    return d3_rgb(vv(h + 120), vv(h), vv(h - 120));
  }
  function d3_hcl(h, c, l) {
    return new d3_Hcl(h, c, l);
  }
  function d3_Hcl(h, c, l) {
    this.h = h;
    this.c = c;
    this.l = l;
  }
  function d3_hcl_lab(h, c, l) {
    return d3_lab(l, Math.cos(h *= Math.PI / 180) * c, Math.sin(h) * c);
  }
  function d3_lab(l, a, b) {
    return new d3_Lab(l, a, b);
  }
  function d3_Lab(l, a, b) {
    this.l = l;
    this.a = a;
    this.b = b;
  }
  function d3_lab_rgb(l, a, b) {
    var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200;
    x = d3_lab_xyz(x) * d3_lab_X;
    y = d3_lab_xyz(y) * d3_lab_Y;
    z = d3_lab_xyz(z) * d3_lab_Z;
    return d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z));
  }
  function d3_lab_hcl(l, a, b) {
    return d3_hcl(Math.atan2(b, a) / Math.PI * 180, Math.sqrt(a * a + b * b), l);
  }
  function d3_lab_xyz(x) {
    return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037;
  }
  function d3_xyz_lab(x) {
    return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;
  }
  function d3_xyz_rgb(r) {
    return Math.round(255 * (r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055));
  }
  function d3_selection(groups) {
    d3_arraySubclass(groups, d3_selectionPrototype);
    return groups;
  }
  function d3_selection_selector(selector) {
    return function() {
      return d3_select(selector, this);
    };
  }
  function d3_selection_selectorAll(selector) {
    return function() {
      return d3_selectAll(selector, this);
    };
  }
  function d3_selection_attr(name, value) {
    function attrNull() {
      this.removeAttribute(name);
    }
    function attrNullNS() {
      this.removeAttributeNS(name.space, name.local);
    }
    function attrConstant() {
      this.setAttribute(name, value);
    }
    function attrConstantNS() {
      this.setAttributeNS(name.space, name.local, value);
    }
    function attrFunction() {
      var x = value.apply(this, arguments);
      if (x == null) this.removeAttribute(name); else this.setAttribute(name, x);
    }
    function attrFunctionNS() {
      var x = value.apply(this, arguments);
      if (x == null) this.removeAttributeNS(name.space, name.local); else this.setAttributeNS(name.space, name.local, x);
    }
    name = d3.ns.qualify(name);
    return value == null ? name.local ? attrNullNS : attrNull : typeof value === "function" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;
  }
  function d3_selection_classedRe(name) {
    return new RegExp("(?:^|\\s+)" + d3.requote(name) + "(?:\\s+|$)", "g");
  }
  function d3_selection_classed(name, value) {
    function classedConstant() {
      var i = -1;
      while (++i < n) name[i](this, value);
    }
    function classedFunction() {
      var i = -1, x = value.apply(this, arguments);
      while (++i < n) name[i](this, x);
    }
    name = name.trim().split(/\s+/).map(d3_selection_classedName);
    var n = name.length;
    return typeof value === "function" ? classedFunction : classedConstant;
  }
  function d3_selection_classedName(name) {
    var re = d3_selection_classedRe(name);
    return function(node, value) {
      if (c = node.classList) return value ? c.add(name) : c.remove(name);
      var c = node.className, cb = c.baseVal != null, cv = cb ? c.baseVal : c;
      if (value) {
        re.lastIndex = 0;
        if (!re.test(cv)) {
          cv = d3_collapse(cv + " " + name);
          if (cb) c.baseVal = cv; else node.className = cv;
        }
      } else if (cv) {
        cv = d3_collapse(cv.replace(re, " "));
        if (cb) c.baseVal = cv; else node.className = cv;
      }
    };
  }
  function d3_selection_style(name, value, priority) {
    function styleNull() {
      this.style.removeProperty(name);
    }
    function styleConstant() {
      this.style.setProperty(name, value, priority);
    }
    function styleFunction() {
      var x = value.apply(this, arguments);
      if (x == null) this.style.removeProperty(name); else this.style.setProperty(name, x, priority);
    }
    return value == null ? styleNull : typeof value === "function" ? styleFunction : styleConstant;
  }
  function d3_selection_property(name, value) {
    function propertyNull() {
      delete this[name];
    }
    function propertyConstant() {
      this[name] = value;
    }
    function propertyFunction() {
      var x = value.apply(this, arguments);
      if (x == null) delete this[name]; else this[name] = x;
    }
    return value == null ? propertyNull : typeof value === "function" ? propertyFunction : propertyConstant;
  }
  function d3_selection_dataNode(data) {
    return {
      __data__: data
    };
  }
  function d3_selection_filter(selector) {
    return function() {
      return d3_selectMatches(this, selector);
    };
  }
  function d3_selection_sortComparator(comparator) {
    if (!arguments.length) comparator = d3.ascending;
    return function(a, b) {
      return comparator(a && a.__data__, b && b.__data__);
    };
  }
  function d3_selection_on(type, listener, capture) {
    function onRemove() {
      var wrapper = this[name];
      if (wrapper) {
        this.removeEventListener(type, wrapper, wrapper.$);
        delete this[name];
      }
    }
    function onAdd() {
      function wrapper(e) {
        var o = d3.event;
        d3.event = e;
        args[0] = node.__data__;
        try {
          listener.apply(node, args);
        } finally {
          d3.event = o;
        }
      }
      var node = this, args = arguments;
      onRemove.call(this);
      this.addEventListener(type, this[name] = wrapper, wrapper.$ = capture);
      wrapper._ = listener;
    }
    var name = "__on" + type, i = type.indexOf(".");
    if (i > 0) type = type.substring(0, i);
    return listener ? onAdd : onRemove;
  }
  function d3_selection_each(groups, callback) {
    for (var j = 0, m = groups.length; j < m; j++) {
      for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {
        if (node = group[i]) callback(node, i, j);
      }
    }
    return groups;
  }
  function d3_selection_enter(selection) {
    d3_arraySubclass(selection, d3_selection_enterPrototype);
    return selection;
  }
  function d3_transition(groups, id, time) {
    d3_arraySubclass(groups, d3_transitionPrototype);
    var tweens = new d3_Map, event = d3.dispatch("start", "end"), ease = d3_transitionEase;
    groups.id = id;
    groups.time = time;
    groups.tween = function(name, tween) {
      if (arguments.length < 2) return tweens.get(name);
      if (tween == null) tweens.remove(name); else tweens.set(name, tween);
      return groups;
    };
    groups.ease = function(value) {
      if (!arguments.length) return ease;
      ease = typeof value === "function" ? value : d3.ease.apply(d3, arguments);
      return groups;
    };
    groups.each = function(type, listener) {
      if (arguments.length < 2) return d3_transition_each.call(groups, type);
      event.on(type, listener);
      return groups;
    };
    d3.timer(function(elapsed) {
      return d3_selection_each(groups, function(node, i, j) {
        function start(elapsed) {
          if (lock.active > id) return stop();
          lock.active = id;
          tweens.forEach(function(key, value) {
            if (value = value.call(node, d, i)) {
              tweened.push(value);
            }
          });
          event.start.call(node, d, i);
          if (!tick(elapsed)) d3.timer(tick, 0, time);
          return 1;
        }
        function tick(elapsed) {
          if (lock.active !== id) return stop();
          var t = (elapsed - delay) / duration, e = ease(t), n = tweened.length;
          while (n > 0) {
            tweened[--n].call(node, e);
          }
          if (t >= 1) {
            stop();
            d3_transitionId = id;
            event.end.call(node, d, i);
            d3_transitionId = 0;
            return 1;
          }
        }
        function stop() {
          if (!--lock.count) delete node.__transition__;
          return 1;
        }
        var tweened = [], delay = node.delay, duration = node.duration, lock = (node = node.node).__transition__ || (node.__transition__ = {
          active: 0,
          count: 0
        }), d = node.__data__;
        ++lock.count;
        delay <= elapsed ? start(elapsed) : d3.timer(start, delay, time);
      });
    }, 0, time);
    return groups;
  }
  function d3_transition_each(callback) {
    var id = d3_transitionId, ease = d3_transitionEase, delay = d3_transitionDelay, duration = d3_transitionDuration;
    d3_transitionId = this.id;
    d3_transitionEase = this.ease();
    d3_selection_each(this, function(node, i, j) {
      d3_transitionDelay = node.delay;
      d3_transitionDuration = node.duration;
      callback.call(node = node.node, node.__data__, i, j);
    });
    d3_transitionId = id;
    d3_transitionEase = ease;
    d3_transitionDelay = delay;
    d3_transitionDuration = duration;
    return this;
  }
  function d3_tweenNull(d, i, a) {
    return a != "" && d3_tweenRemove;
  }
  function d3_tweenByName(b, name) {
    return d3.tween(b, d3_interpolateByName(name));
  }
  function d3_timer_step() {
    var elapsed, now = Date.now(), t1 = d3_timer_queue;
    while (t1) {
      elapsed = now - t1.then;
      if (elapsed >= t1.delay) t1.flush = t1.callback(elapsed);
      t1 = t1.next;
    }
    var delay = d3_timer_flush() - now;
    if (delay > 24) {
      if (isFinite(delay)) {
        clearTimeout(d3_timer_timeout);
        d3_timer_timeout = setTimeout(d3_timer_step, delay);
      }
      d3_timer_interval = 0;
    } else {
      d3_timer_interval = 1;
      d3_timer_frame(d3_timer_step);
    }
  }
  function d3_timer_flush() {
    var t0 = null, t1 = d3_timer_queue, then = Infinity;
    while (t1) {
      if (t1.flush) {
        delete d3_timer_byId[t1.callback.id];
        t1 = t0 ? t0.next = t1.next : d3_timer_queue = t1.next;
      } else {
        then = Math.min(then, t1.then + t1.delay);
        t1 = (t0 = t1).next;
      }
    }
    return then;
  }
  function d3_mousePoint(container, e) {
    var svg = container.ownerSVGElement || container;
    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      if (d3_mouse_bug44083 < 0 && (window.scrollX || window.scrollY)) {
        svg = d3.select(document.body).append("svg").style("position", "absolute").style("top", 0).style("left", 0);
        var ctm = svg[0][0].getScreenCTM();
        d3_mouse_bug44083 = !(ctm.f || ctm.e);
        svg.remove();
      }
      if (d3_mouse_bug44083) {
        point.x = e.pageX;
        point.y = e.pageY;
      } else {
        point.x = e.clientX;
        point.y = e.clientY;
      }
      point = point.matrixTransform(container.getScreenCTM().inverse());
      return [ point.x, point.y ];
    }
    var rect = container.getBoundingClientRect();
    return [ e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop ];
  }
  function d3_noop() {}
  function d3_scaleExtent(domain) {
    var start = domain[0], stop = domain[domain.length - 1];
    return start < stop ? [ start, stop ] : [ stop, start ];
  }
  function d3_scaleRange(scale) {
    return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
  }
  function d3_scale_nice(domain, nice) {
    var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx;
    if (x1 < x0) {
      dx = i0, i0 = i1, i1 = dx;
      dx = x0, x0 = x1, x1 = dx;
    }
    if (nice = nice(x1 - x0)) {
      domain[i0] = nice.floor(x0);
      domain[i1] = nice.ceil(x1);
    }
    return domain;
  }
  function d3_scale_niceDefault() {
    return Math;
  }
  function d3_scale_linear(domain, range, interpolate, clamp) {
    function rescale() {
      var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
      output = linear(domain, range, uninterpolate, interpolate);
      input = linear(range, domain, uninterpolate, d3.interpolate);
      return scale;
    }
    function scale(x) {
      return output(x);
    }
    var output, input;
    scale.invert = function(y) {
      return input(y);
    };
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(Number);
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.rangeRound = function(x) {
      return scale.range(x).interpolate(d3.interpolateRound);
    };
    scale.clamp = function(x) {
      if (!arguments.length) return clamp;
      clamp = x;
      return rescale();
    };
    scale.interpolate = function(x) {
      if (!arguments.length) return interpolate;
      interpolate = x;
      return rescale();
    };
    scale.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    scale.tickFormat = function(m) {
      return d3_scale_linearTickFormat(domain, m);
    };
    scale.nice = function() {
      d3_scale_nice(domain, d3_scale_linearNice);
      return rescale();
    };
    scale.copy = function() {
      return d3_scale_linear(domain, range, interpolate, clamp);
    };
    return rescale();
  }
  function d3_scale_linearRebind(scale, linear) {
    return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
  }
  function d3_scale_linearNice(dx) {
    dx = Math.pow(10, Math.round(Math.log(dx) / Math.LN10) - 1);
    return dx && {
      floor: function(x) {
        return Math.floor(x / dx) * dx;
      },
      ceil: function(x) {
        return Math.ceil(x / dx) * dx;
      }
    };
  }
  function d3_scale_linearTickRange(domain, m) {
    var extent = d3_scaleExtent(domain), span = extent[1] - extent[0], step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)), err = m / span * step;
    if (err <= .15) step *= 10; else if (err <= .35) step *= 5; else if (err <= .75) step *= 2;
    extent[0] = Math.ceil(extent[0] / step) * step;
    extent[1] = Math.floor(extent[1] / step) * step + step * .5;
    extent[2] = step;
    return extent;
  }
  function d3_scale_linearTicks(domain, m) {
    return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));
  }
  function d3_scale_linearTickFormat(domain, m) {
    return d3.format(",." + Math.max(0, -Math.floor(Math.log(d3_scale_linearTickRange(domain, m)[2]) / Math.LN10 + .01)) + "f");
  }
  function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
    var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]);
    return function(x) {
      return i(u(x));
    };
  }
  function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
    var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1;
    if (domain[k] < domain[0]) {
      domain = domain.slice().reverse();
      range = range.slice().reverse();
    }
    while (++j <= k) {
      u.push(uninterpolate(domain[j - 1], domain[j]));
      i.push(interpolate(range[j - 1], range[j]));
    }
    return function(x) {
      var j = d3.bisect(domain, x, 1, k) - 1;
      return i[j](u[j](x));
    };
  }
  function d3_scale_log(linear, log) {
    function scale(x) {
      return linear(log(x));
    }
    var pow = log.pow;
    scale.invert = function(x) {
      return pow(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return linear.domain().map(pow);
      log = x[0] < 0 ? d3_scale_logn : d3_scale_logp;
      pow = log.pow;
      linear.domain(x.map(log));
      return scale;
    };
    scale.nice = function() {
      linear.domain(d3_scale_nice(linear.domain(), d3_scale_niceDefault));
      return scale;
    };
    scale.ticks = function() {
      var extent = d3_scaleExtent(linear.domain()), ticks = [];
      if (extent.every(isFinite)) {
        var i = Math.floor(extent[0]), j = Math.ceil(extent[1]), u = pow(extent[0]), v = pow(extent[1]);
        if (log === d3_scale_logn) {
          ticks.push(pow(i));
          for (; i++ < j; ) for (var k = 9; k > 0; k--) ticks.push(pow(i) * k);
        } else {
          for (; i < j; i++) for (var k = 1; k < 10; k++) ticks.push(pow(i) * k);
          ticks.push(pow(i));
        }
        for (i = 0; ticks[i] < u; i++) {}
        for (j = ticks.length; ticks[j - 1] > v; j--) {}
        ticks = ticks.slice(i, j);
      }
      return ticks;
    };
    scale.tickFormat = function(n, format) {
      if (arguments.length < 2) format = d3_scale_logFormat;
      if (arguments.length < 1) return format;
      var k = Math.max(.1, n / scale.ticks().length), f = log === d3_scale_logn ? (e = -1e-12, Math.floor) : (e = 1e-12, Math.ceil), e;
      return function(d) {
        return d / pow(f(log(d) + e)) <= k ? format(d) : "";
      };
    };
    scale.copy = function() {
      return d3_scale_log(linear.copy(), log);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  function d3_scale_logp(x) {
    return Math.log(x < 0 ? 0 : x) / Math.LN10;
  }
  function d3_scale_logn(x) {
    return -Math.log(x > 0 ? 0 : -x) / Math.LN10;
  }
  function d3_scale_pow(linear, exponent) {
    function scale(x) {
      return linear(powp(x));
    }
    var powp = d3_scale_powPow(exponent), powb = d3_scale_powPow(1 / exponent);
    scale.invert = function(x) {
      return powb(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return linear.domain().map(powb);
      linear.domain(x.map(powp));
      return scale;
    };
    scale.ticks = function(m) {
      return d3_scale_linearTicks(scale.domain(), m);
    };
    scale.tickFormat = function(m) {
      return d3_scale_linearTickFormat(scale.domain(), m);
    };
    scale.nice = function() {
      return scale.domain(d3_scale_nice(scale.domain(), d3_scale_linearNice));
    };
    scale.exponent = function(x) {
      if (!arguments.length) return exponent;
      var domain = scale.domain();
      powp = d3_scale_powPow(exponent = x);
      powb = d3_scale_powPow(1 / exponent);
      return scale.domain(domain);
    };
    scale.copy = function() {
      return d3_scale_pow(linear.copy(), exponent);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  function d3_scale_powPow(e) {
    return function(x) {
      return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);
    };
  }
  function d3_scale_ordinal(domain, ranger) {
    function scale(x) {
      return range[((index.get(x) || index.set(x, domain.push(x))) - 1) % range.length];
    }
    function steps(start, step) {
      return d3.range(domain.length).map(function(i) {
        return start + step * i;
      });
    }
    var index, range, rangeBand;
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = [];
      index = new d3_Map;
      var i = -1, n = x.length, xi;
      while (++i < n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi));
      return scale[ranger.t].apply(scale, ranger.a);
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      rangeBand = 0;
      ranger = {
        t: "range",
        a: arguments
      };
      return scale;
    };
    scale.rangePoints = function(x, padding) {
      if (arguments.length < 2) padding = 0;
      var start = x[0], stop = x[1], step = (stop - start) / (Math.max(1, domain.length - 1) + padding);
      range = steps(domain.length < 2 ? (start + stop) / 2 : start + step * padding / 2, step);
      rangeBand = 0;
      ranger = {
        t: "rangePoints",
        a: arguments
      };
      return scale;
    };
    scale.rangeBands = function(x, padding, outerPadding) {
      if (arguments.length < 2) padding = 0;
      if (arguments.length < 3) outerPadding = padding;
      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 * outerPadding);
      range = steps(start + step * outerPadding, step);
      if (reverse) range.reverse();
      rangeBand = step * (1 - padding);
      ranger = {
        t: "rangeBands",
        a: arguments
      };
      return scale;
    };
    scale.rangeRoundBands = function(x, padding, outerPadding) {
      if (arguments.length < 2) padding = 0;
      if (arguments.length < 3) outerPadding = padding;
      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding)), error = stop - start - (domain.length - padding) * step;
      range = steps(start + Math.round(error / 2), step);
      if (reverse) range.reverse();
      rangeBand = Math.round(step * (1 - padding));
      ranger = {
        t: "rangeRoundBands",
        a: arguments
      };
      return scale;
    };
    scale.rangeBand = function() {
      return rangeBand;
    };
    scale.rangeExtent = function() {
      return d3_scaleExtent(ranger.a[0]);
    };
    scale.copy = function() {
      return d3_scale_ordinal(domain, ranger);
    };
    return scale.domain(domain);
  }
  function d3_scale_quantile(domain, range) {
    function rescale() {
      var k = 0, n = domain.length, q = range.length;
      thresholds = [];
      while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);
      return scale;
    }
    function scale(x) {
      if (isNaN(x = +x)) return NaN;
      return range[d3.bisect(thresholds, x)];
    }
    var thresholds;
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = x.filter(function(d) {
        return !isNaN(d);
      }).sort(d3.ascending);
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.quantiles = function() {
      return thresholds;
    };
    scale.copy = function() {
      return d3_scale_quantile(domain, range);
    };
    return rescale();
  }
  function d3_scale_quantize(x0, x1, range) {
    function scale(x) {
      return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
    }
    function rescale() {
      kx = range.length / (x1 - x0);
      i = range.length - 1;
      return scale;
    }
    var kx, i;
    scale.domain = function(x) {
      if (!arguments.length) return [ x0, x1 ];
      x0 = +x[0];
      x1 = +x[x.length - 1];
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.copy = function() {
      return d3_scale_quantize(x0, x1, range);
    };
    return rescale();
  }
  function d3_scale_threshold(domain, range) {
    function scale(x) {
      return range[d3.bisect(domain, x)];
    }
    scale.domain = function(_) {
      if (!arguments.length) return domain;
      domain = _;
      return scale;
    };
    scale.range = function(_) {
      if (!arguments.length) return range;
      range = _;
      return scale;
    };
    scale.copy = function() {
      return d3_scale_threshold(domain, range);
    };
    return scale;
  }
  function d3_scale_identity(domain) {
    function identity(x) {
      return +x;
    }
    identity.invert = identity;
    identity.domain = identity.range = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(identity);
      return identity;
    };
    identity.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    identity.tickFormat = function(m) {
      return d3_scale_linearTickFormat(domain, m);
    };
    identity.copy = function() {
      return d3_scale_identity(domain);
    };
    return identity;
  }
  function d3_svg_arcInnerRadius(d) {
    return d.innerRadius;
  }
  function d3_svg_arcOuterRadius(d) {
    return d.outerRadius;
  }
  function d3_svg_arcStartAngle(d) {
    return d.startAngle;
  }
  function d3_svg_arcEndAngle(d) {
    return d.endAngle;
  }
  function d3_svg_line(projection) {
    function line(data) {
      function segment() {
        segments.push("M", interpolate(projection(points), tension));
      }
      var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y);
      while (++i < n) {
        if (defined.call(this, d = data[i], i)) {
          points.push([ +fx.call(this, d, i), +fy.call(this, d, i) ]);
        } else if (points.length) {
          segment();
          points = [];
        }
      }
      if (points.length) segment();
      return segments.length ? segments.join("") : null;
    }
    var x = d3_svg_lineX, y = d3_svg_lineY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = .7;
    line.x = function(_) {
      if (!arguments.length) return x;
      x = _;
      return line;
    };
    line.y = function(_) {
      if (!arguments.length) return y;
      y = _;
      return line;
    };
    line.defined = function(_) {
      if (!arguments.length) return defined;
      defined = _;
      return line;
    };
    line.interpolate = function(_) {
      if (!arguments.length) return interpolateKey;
      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
      return line;
    };
    line.tension = function(_) {
      if (!arguments.length) return tension;
      tension = _;
      return line;
    };
    return line;
  }
  function d3_svg_lineX(d) {
    return d[0];
  }
  function d3_svg_lineY(d) {
    return d[1];
  }
  function d3_svg_lineLinear(points) {
    return points.join("L");
  }
  function d3_svg_lineLinearClosed(points) {
    return d3_svg_lineLinear(points) + "Z";
  }
  function d3_svg_lineStepBefore(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("V", (p = points[i])[1], "H", p[0]);
    return path.join("");
  }
  function d3_svg_lineStepAfter(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("H", (p = points[i])[0], "V", p[1]);
    return path.join("");
  }
  function d3_svg_lineCardinalOpen(points, tension) {
    return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, points.length - 1), d3_svg_lineCardinalTangents(points, tension));
  }
  function d3_svg_lineCardinalClosed(points, tension) {
    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), points), d3_svg_lineCardinalTangents([ points[points.length - 2] ].concat(points, [ points[1] ]), tension));
  }
  function d3_svg_lineCardinal(points, tension, closed) {
    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));
  }
  function d3_svg_lineHermite(points, tangents) {
    if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {
      return d3_svg_lineLinear(points);
    }
    var quad = points.length != tangents.length, path = "", p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;
    if (quad) {
      path += "Q" + (p[0] - t0[0] * 2 / 3) + "," + (p[1] - t0[1] * 2 / 3) + "," + p[0] + "," + p[1];
      p0 = points[1];
      pi = 2;
    }
    if (tangents.length > 1) {
      t = tangents[1];
      p = points[pi];
      pi++;
      path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1]) + "," + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
      for (var i = 2; i < tangents.length; i++, pi++) {
        p = points[pi];
        t = tangents[i];
        path += "S" + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
      }
    }
    if (quad) {
      var lp = points[pi];
      path += "Q" + (p[0] + t[0] * 2 / 3) + "," + (p[1] + t[1] * 2 / 3) + "," + lp[0] + "," + lp[1];
    }
    return path;
  }
  function d3_svg_lineCardinalTangents(points, tension) {
    var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;
    while (++i < n) {
      p0 = p1;
      p1 = p2;
      p2 = points[i];
      tangents.push([ a * (p2[0] - p0[0]), a * (p2[1] - p0[1]) ]);
    }
    return tangents;
  }
  function d3_svg_lineBasis(points) {
    if (points.length < 3) return d3_svg_lineLinear(points);
    var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [ x0, x0, x0, (pi = points[1])[0] ], py = [ y0, y0, y0, pi[1] ], path = [ x0, ",", y0 ];
    d3_svg_lineBasisBezier(path, px, py);
    while (++i < n) {
      pi = points[i];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    i = -1;
    while (++i < 2) {
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    return path.join("");
  }
  function d3_svg_lineBasisOpen(points) {
    if (points.length < 4) return d3_svg_lineLinear(points);
    var path = [], i = -1, n = points.length, pi, px = [ 0 ], py = [ 0 ];
    while (++i < 3) {
      pi = points[i];
      px.push(pi[0]);
      py.push(pi[1]);
    }
    path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
    --i;
    while (++i < n) {
      pi = points[i];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    return path.join("");
  }
  function d3_svg_lineBasisClosed(points) {
    var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = [];
    while (++i < 4) {
      pi = points[i % n];
      px.push(pi[0]);
      py.push(pi[1]);
    }
    path = [ d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
    --i;
    while (++i < m) {
      pi = points[i % n];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    return path.join("");
  }
  function d3_svg_lineBundle(points, tension) {
    var n = points.length - 1;
    if (n) {
      var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t;
      while (++i <= n) {
        p = points[i];
        t = i / n;
        p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
        p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
      }
    }
    return d3_svg_lineBasis(points);
  }
  function d3_svg_lineDot4(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
  }
  function d3_svg_lineBasisBezier(path, x, y) {
    path.push("C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
  }
  function d3_svg_lineSlope(p0, p1) {
    return (p1[1] - p0[1]) / (p1[0] - p0[0]);
  }
  function d3_svg_lineFiniteDifferences(points) {
    var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1);
    while (++i < j) {
      m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;
    }
    m[i] = d;
    return m;
  }
  function d3_svg_lineMonotoneTangents(points) {
    var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1;
    while (++i < j) {
      d = d3_svg_lineSlope(points[i], points[i + 1]);
      if (Math.abs(d) < 1e-6) {
        m[i] = m[i + 1] = 0;
      } else {
        a = m[i] / d;
        b = m[i + 1] / d;
        s = a * a + b * b;
        if (s > 9) {
          s = d * 3 / Math.sqrt(s);
          m[i] = s * a;
          m[i + 1] = s * b;
        }
      }
    }
    i = -1;
    while (++i <= j) {
      s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
      tangents.push([ s || 0, m[i] * s || 0 ]);
    }
    return tangents;
  }
  function d3_svg_lineMonotone(points) {
    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
  }
  function d3_svg_lineRadial(points) {
    var point, i = -1, n = points.length, r, a;
    while (++i < n) {
      point = points[i];
      r = point[0];
      a = point[1] + d3_svg_arcOffset;
      point[0] = r * Math.cos(a);
      point[1] = r * Math.sin(a);
    }
    return points;
  }
  function d3_svg_area(projection) {
    function area(data) {
      function segment() {
        segments.push("M", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), "Z");
      }
      var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function() {
        return x;
      } : d3_functor(x1), fy1 = y0 === y1 ? function() {
        return y;
      } : d3_functor(y1), x, y;
      while (++i < n) {
        if (defined.call(this, d = data[i], i)) {
          points0.push([ x = +fx0.call(this, d, i), y = +fy0.call(this, d, i) ]);
          points1.push([ +fx1.call(this, d, i), +fy1.call(this, d, i) ]);
        } else if (points0.length) {
          segment();
          points0 = [];
          points1 = [];
        }
      }
      if (points0.length) segment();
      return segments.length ? segments.join("") : null;
    }
    var x0 = d3_svg_lineX, x1 = d3_svg_lineX, y0 = 0, y1 = d3_svg_lineY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = "L", tension = .7;
    area.x = function(_) {
      if (!arguments.length) return x1;
      x0 = x1 = _;
      return area;
    };
    area.x0 = function(_) {
      if (!arguments.length) return x0;
      x0 = _;
      return area;
    };
    area.x1 = function(_) {
      if (!arguments.length) return x1;
      x1 = _;
      return area;
    };
    area.y = function(_) {
      if (!arguments.length) return y1;
      y0 = y1 = _;
      return area;
    };
    area.y0 = function(_) {
      if (!arguments.length) return y0;
      y0 = _;
      return area;
    };
    area.y1 = function(_) {
      if (!arguments.length) return y1;
      y1 = _;
      return area;
    };
    area.defined = function(_) {
      if (!arguments.length) return defined;
      defined = _;
      return area;
    };
    area.interpolate = function(_) {
      if (!arguments.length) return interpolateKey;
      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
      interpolateReverse = interpolate.reverse || interpolate;
      L = interpolate.closed ? "M" : "L";
      return area;
    };
    area.tension = function(_) {
      if (!arguments.length) return tension;
      tension = _;
      return area;
    };
    return area;
  }
  function d3_svg_chordSource(d) {
    return d.source;
  }
  function d3_svg_chordTarget(d) {
    return d.target;
  }
  function d3_svg_chordRadius(d) {
    return d.radius;
  }
  function d3_svg_chordStartAngle(d) {
    return d.startAngle;
  }
  function d3_svg_chordEndAngle(d) {
    return d.endAngle;
  }
  function d3_svg_diagonalProjection(d) {
    return [ d.x, d.y ];
  }
  function d3_svg_diagonalRadialProjection(projection) {
    return function() {
      var d = projection.apply(this, arguments), r = d[0], a = d[1] + d3_svg_arcOffset;
      return [ r * Math.cos(a), r * Math.sin(a) ];
    };
  }
  function d3_svg_symbolSize() {
    return 64;
  }
  function d3_svg_symbolType() {
    return "circle";
  }
  function d3_svg_symbolCircle(size) {
    var r = Math.sqrt(size / Math.PI);
    return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + -r + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
  }
  function d3_svg_axisX(selection, x) {
    selection.attr("transform", function(d) {
      return "translate(" + x(d) + ",0)";
    });
  }
  function d3_svg_axisY(selection, y) {
    selection.attr("transform", function(d) {
      return "translate(0," + y(d) + ")";
    });
  }
  function d3_svg_axisSubdivide(scale, ticks, m) {
    subticks = [];
    if (m && ticks.length > 1) {
      var extent = d3_scaleExtent(scale.domain()), subticks, i = -1, n = ticks.length, d = (ticks[1] - ticks[0]) / ++m, j, v;
      while (++i < n) {
        for (j = m; --j > 0; ) {
          if ((v = +ticks[i] - j * d) >= extent[0]) {
            subticks.push(v);
          }
        }
      }
      for (--i, j = 0; ++j < m && (v = +ticks[i] + j * d) < extent[1]; ) {
        subticks.push(v);
      }
    }
    return subticks;
  }
  function d3_behavior_zoomDelta() {
    if (!d3_behavior_zoomDiv) {
      d3_behavior_zoomDiv = d3.select("body").append("div").style("visibility", "hidden").style("top", 0).style("height", 0).style("width", 0).style("overflow-y", "scroll").append("div").style("height", "2000px").node().parentNode;
    }
    var e = d3.event, delta;
    try {
      d3_behavior_zoomDiv.scrollTop = 1e3;
      d3_behavior_zoomDiv.dispatchEvent(e);
      delta = 1e3 - d3_behavior_zoomDiv.scrollTop;
    } catch (error) {
      delta = e.wheelDelta || -e.detail * 5;
    }
    return delta;
  }
  function d3_layout_bundlePath(link) {
    var start = link.source, end = link.target, lca = d3_layout_bundleLeastCommonAncestor(start, end), points = [ start ];
    while (start !== lca) {
      start = start.parent;
      points.push(start);
    }
    var k = points.length;
    while (end !== lca) {
      points.splice(k, 0, end);
      end = end.parent;
    }
    return points;
  }
  function d3_layout_bundleAncestors(node) {
    var ancestors = [], parent = node.parent;
    while (parent != null) {
      ancestors.push(node);
      node = parent;
      parent = parent.parent;
    }
    ancestors.push(node);
    return ancestors;
  }
  function d3_layout_bundleLeastCommonAncestor(a, b) {
    if (a === b) return a;
    var aNodes = d3_layout_bundleAncestors(a), bNodes = d3_layout_bundleAncestors(b), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null;
    while (aNode === bNode) {
      sharedNode = aNode;
      aNode = aNodes.pop();
      bNode = bNodes.pop();
    }
    return sharedNode;
  }
  function d3_layout_forceDragstart(d) {
    d.fixed |= 2;
  }
  function d3_layout_forceDragend(d) {
    d.fixed &= 1;
  }
  function d3_layout_forceMouseover(d) {
    d.fixed |= 4;
  }
  function d3_layout_forceMouseout(d) {
    d.fixed &= 3;
  }
  function d3_layout_forceAccumulate(quad, alpha, charges) {
    var cx = 0, cy = 0;
    quad.charge = 0;
    if (!quad.leaf) {
      var nodes = quad.nodes, n = nodes.length, i = -1, c;
      while (++i < n) {
        c = nodes[i];
        if (c == null) continue;
        d3_layout_forceAccumulate(c, alpha, charges);
        quad.charge += c.charge;
        cx += c.charge * c.cx;
        cy += c.charge * c.cy;
      }
    }
    if (quad.point) {
      if (!quad.leaf) {
        quad.point.x += Math.random() - .5;
        quad.point.y += Math.random() - .5;
      }
      var k = alpha * charges[quad.point.index];
      quad.charge += quad.pointCharge = k;
      cx += k * quad.point.x;
      cy += k * quad.point.y;
    }
    quad.cx = cx / quad.charge;
    quad.cy = cy / quad.charge;
  }
  function d3_layout_forceLinkDistance(link) {
    return 20;
  }
  function d3_layout_forceLinkStrength(link) {
    return 1;
  }
  function d3_layout_stackX(d) {
    return d.x;
  }
  function d3_layout_stackY(d) {
    return d.y;
  }
  function d3_layout_stackOut(d, y0, y) {
    d.y0 = y0;
    d.y = y;
  }
  function d3_layout_stackOrderDefault(data) {
    return d3.range(data.length);
  }
  function d3_layout_stackOffsetZero(data) {
    var j = -1, m = data[0].length, y0 = [];
    while (++j < m) y0[j] = 0;
    return y0;
  }
  function d3_layout_stackMaxIndex(array) {
    var i = 1, j = 0, v = array[0][1], k, n = array.length;
    for (; i < n; ++i) {
      if ((k = array[i][1]) > v) {
        j = i;
        v = k;
      }
    }
    return j;
  }
  function d3_layout_stackReduceSum(d) {
    return d.reduce(d3_layout_stackSum, 0);
  }
  function d3_layout_stackSum(p, d) {
    return p + d[1];
  }
  function d3_layout_histogramBinSturges(range, values) {
    return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));
  }
  function d3_layout_histogramBinFixed(range, n) {
    var x = -1, b = +range[0], m = (range[1] - b) / n, f = [];
    while (++x <= n) f[x] = m * x + b;
    return f;
  }
  function d3_layout_histogramRange(values) {
    return [ d3.min(values), d3.max(values) ];
  }
  function d3_layout_hierarchyRebind(object, hierarchy) {
    d3.rebind(object, hierarchy, "sort", "children", "value");
    object.links = d3_layout_hierarchyLinks;
    object.nodes = function(d) {
      d3_layout_hierarchyInline = true;
      return (object.nodes = object)(d);
    };
    return object;
  }
  function d3_layout_hierarchyChildren(d) {
    return d.children;
  }
  function d3_layout_hierarchyValue(d) {
    return d.value;
  }
  function d3_layout_hierarchySort(a, b) {
    return b.value - a.value;
  }
  function d3_layout_hierarchyLinks(nodes) {
    return d3.merge(nodes.map(function(parent) {
      return (parent.children || []).map(function(child) {
        return {
          source: parent,
          target: child
        };
      });
    }));
  }
  function d3_layout_packSort(a, b) {
    return a.value - b.value;
  }
  function d3_layout_packInsert(a, b) {
    var c = a._pack_next;
    a._pack_next = b;
    b._pack_prev = a;
    b._pack_next = c;
    c._pack_prev = b;
  }
  function d3_layout_packSplice(a, b) {
    a._pack_next = b;
    b._pack_prev = a;
  }
  function d3_layout_packIntersects(a, b) {
    var dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r;
    return dr * dr - dx * dx - dy * dy > .001;
  }
  function d3_layout_packSiblings(node) {
    function bound(node) {
      xMin = Math.min(node.x - node.r, xMin);
      xMax = Math.max(node.x + node.r, xMax);
      yMin = Math.min(node.y - node.r, yMin);
      yMax = Math.max(node.y + node.r, yMax);
    }
    if (!(nodes = node.children) || !(n = nodes.length)) return;
    var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n;
    nodes.forEach(d3_layout_packLink);
    a = nodes[0];
    a.x = -a.r;
    a.y = 0;
    bound(a);
    if (n > 1) {
      b = nodes[1];
      b.x = b.r;
      b.y = 0;
      bound(b);
      if (n > 2) {
        c = nodes[2];
        d3_layout_packPlace(a, b, c);
        bound(c);
        d3_layout_packInsert(a, c);
        a._pack_prev = c;
        d3_layout_packInsert(c, b);
        b = a._pack_next;
        for (i = 3; i < n; i++) {
          d3_layout_packPlace(a, b, c = nodes[i]);
          var isect = 0, s1 = 1, s2 = 1;
          for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {
            if (d3_layout_packIntersects(j, c)) {
              isect = 1;
              break;
            }
          }
          if (isect == 1) {
            for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {
              if (d3_layout_packIntersects(k, c)) {
                break;
              }
            }
          }
          if (isect) {
            if (s1 < s2 || s1 == s2 && b.r < a.r) d3_layout_packSplice(a, b = j); else d3_layout_packSplice(a = k, b);
            i--;
          } else {
            d3_layout_packInsert(a, c);
            b = c;
            bound(c);
          }
        }
      }
    }
    var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0;
    for (i = 0; i < n; i++) {
      c = nodes[i];
      c.x -= cx;
      c.y -= cy;
      cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));
    }
    node.r = cr;
    nodes.forEach(d3_layout_packUnlink);
  }
  function d3_layout_packLink(node) {
    node._pack_next = node._pack_prev = node;
  }
  function d3_layout_packUnlink(node) {
    delete node._pack_next;
    delete node._pack_prev;
  }
  function d3_layout_packTransform(node, x, y, k) {
    var children = node.children;
    node.x = x += k * node.x;
    node.y = y += k * node.y;
    node.r *= k;
    if (children) {
      var i = -1, n = children.length;
      while (++i < n) d3_layout_packTransform(children[i], x, y, k);
    }
  }
  function d3_layout_packPlace(a, b, c) {
    var db = a.r + c.r, dx = b.x - a.x, dy = b.y - a.y;
    if (db && (dx || dy)) {
      var da = b.r + c.r, dc = dx * dx + dy * dy;
      da *= da;
      db *= db;
      var x = .5 + (db - da) / (2 * dc), y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
      c.x = a.x + x * dx + y * dy;
      c.y = a.y + x * dy - y * dx;
    } else {
      c.x = a.x + db;
      c.y = a.y;
    }
  }
  function d3_layout_clusterY(children) {
    return 1 + d3.max(children, function(child) {
      return child.y;
    });
  }
  function d3_layout_clusterX(children) {
    return children.reduce(function(x, child) {
      return x + child.x;
    }, 0) / children.length;
  }
  function d3_layout_clusterLeft(node) {
    var children = node.children;
    return children && children.length ? d3_layout_clusterLeft(children[0]) : node;
  }
  function d3_layout_clusterRight(node) {
    var children = node.children, n;
    return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;
  }
  function d3_layout_treeSeparation(a, b) {
    return a.parent == b.parent ? 1 : 2;
  }
  function d3_layout_treeLeft(node) {
    var children = node.children;
    return children && children.length ? children[0] : node._tree.thread;
  }
  function d3_layout_treeRight(node) {
    var children = node.children, n;
    return children && (n = children.length) ? children[n - 1] : node._tree.thread;
  }
  function d3_layout_treeSearch(node, compare) {
    var children = node.children;
    if (children && (n = children.length)) {
      var child, n, i = -1;
      while (++i < n) {
        if (compare(child = d3_layout_treeSearch(children[i], compare), node) > 0) {
          node = child;
        }
      }
    }
    return node;
  }
  function d3_layout_treeRightmost(a, b) {
    return a.x - b.x;
  }
  function d3_layout_treeLeftmost(a, b) {
    return b.x - a.x;
  }
  function d3_layout_treeDeepest(a, b) {
    return a.depth - b.depth;
  }
  function d3_layout_treeVisitAfter(node, callback) {
    function visit(node, previousSibling) {
      var children = node.children;
      if (children && (n = children.length)) {
        var child, previousChild = null, i = -1, n;
        while (++i < n) {
          child = children[i];
          visit(child, previousChild);
          previousChild = child;
        }
      }
      callback(node, previousSibling);
    }
    visit(node, null);
  }
  function d3_layout_treeShift(node) {
    var shift = 0, change = 0, children = node.children, i = children.length, child;
    while (--i >= 0) {
      child = children[i]._tree;
      child.prelim += shift;
      child.mod += shift;
      shift += child.shift + (change += child.change);
    }
  }
  function d3_layout_treeMove(ancestor, node, shift) {
    ancestor = ancestor._tree;
    node = node._tree;
    var change = shift / (node.number - ancestor.number);
    ancestor.change += change;
    node.change -= change;
    node.shift += shift;
    node.prelim += shift;
    node.mod += shift;
  }
  function d3_layout_treeAncestor(vim, node, ancestor) {
    return vim._tree.ancestor.parent == node.parent ? vim._tree.ancestor : ancestor;
  }
  function d3_layout_treemapPadNull(node) {
    return {
      x: node.x,
      y: node.y,
      dx: node.dx,
      dy: node.dy
    };
  }
  function d3_layout_treemapPad(node, padding) {
    var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];
    if (dx < 0) {
      x += dx / 2;
      dx = 0;
    }
    if (dy < 0) {
      y += dy / 2;
      dy = 0;
    }
    return {
      x: x,
      y: y,
      dx: dx,
      dy: dy
    };
  }
  function d3_dsv(delimiter, mimeType) {
    function dsv(url, callback) {
      d3.text(url, mimeType, function(text) {
        callback(text && dsv.parse(text));
      });
    }
    function formatRow(row) {
      return row.map(formatValue).join(delimiter);
    }
    function formatValue(text) {
      return reFormat.test(text) ? '"' + text.replace(/\"/g, '""') + '"' : text;
    }
    var reParse = new RegExp("\r\n|[" + delimiter + "\r\n]", "g"), reFormat = new RegExp('["' + delimiter + "\n]"), delimiterCode = delimiter.charCodeAt(0);
    dsv.parse = function(text) {
      var header;
      return dsv.parseRows(text, function(row, i) {
        if (i) {
          var o = {}, j = -1, m = header.length;
          while (++j < m) o[header[j]] = row[j];
          return o;
        } else {
          header = row;
          return null;
        }
      });
    };
    dsv.parseRows = function(text, f) {
      function token() {
        if (reParse.lastIndex >= text.length) return EOF;
        if (eol) {
          eol = false;
          return EOL;
        }
        var j = reParse.lastIndex;
        if (text.charCodeAt(j) === 34) {
          var i = j;
          while (i++ < text.length) {
            if (text.charCodeAt(i) === 34) {
              if (text.charCodeAt(i + 1) !== 34) break;
              i++;
            }
          }
          reParse.lastIndex = i + 2;
          var c = text.charCodeAt(i + 1);
          if (c === 13) {
            eol = true;
            if (text.charCodeAt(i + 2) === 10) reParse.lastIndex++;
          } else if (c === 10) {
            eol = true;
          }
          return text.substring(j + 1, i).replace(/""/g, '"');
        }
        var m = reParse.exec(text);
        if (m) {
          eol = m[0].charCodeAt(0) !== delimiterCode;
          return text.substring(j, m.index);
        }
        reParse.lastIndex = text.length;
        return text.substring(j);
      }
      var EOL = {}, EOF = {}, rows = [], n = 0, t, eol;
      reParse.lastIndex = 0;
      while ((t = token()) !== EOF) {
        var a = [];
        while (t !== EOL && t !== EOF) {
          a.push(t);
          t = token();
        }
        if (f && !(a = f(a, n++))) continue;
        rows.push(a);
      }
      return rows;
    };
    dsv.format = function(rows) {
      return rows.map(formatRow).join("\n");
    };
    return dsv;
  }
  function d3_geo_type(types, defaultValue) {
    return function(object) {
      return object && types.hasOwnProperty(object.type) ? types[object.type](object) : defaultValue;
    };
  }
  function d3_path_circle(radius) {
    return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + +2 * radius + "z";
  }
  function d3_geo_bounds(o, f) {
    if (d3_geo_boundsTypes.hasOwnProperty(o.type)) d3_geo_boundsTypes[o.type](o, f);
  }
  function d3_geo_boundsFeature(o, f) {
    d3_geo_bounds(o.geometry, f);
  }
  function d3_geo_boundsFeatureCollection(o, f) {
    for (var a = o.features, i = 0, n = a.length; i < n; i++) {
      d3_geo_bounds(a[i].geometry, f);
    }
  }
  function d3_geo_boundsGeometryCollection(o, f) {
    for (var a = o.geometries, i = 0, n = a.length; i < n; i++) {
      d3_geo_bounds(a[i], f);
    }
  }
  function d3_geo_boundsLineString(o, f) {
    for (var a = o.coordinates, i = 0, n = a.length; i < n; i++) {
      f.apply(null, a[i]);
    }
  }
  function d3_geo_boundsMultiLineString(o, f) {
    for (var a = o.coordinates, i = 0, n = a.length; i < n; i++) {
      for (var b = a[i], j = 0, m = b.length; j < m; j++) {
        f.apply(null, b[j]);
      }
    }
  }
  function d3_geo_boundsMultiPolygon(o, f) {
    for (var a = o.coordinates, i = 0, n = a.length; i < n; i++) {
      for (var b = a[i][0], j = 0, m = b.length; j < m; j++) {
        f.apply(null, b[j]);
      }
    }
  }
  function d3_geo_boundsPoint(o, f) {
    f.apply(null, o.coordinates);
  }
  function d3_geo_boundsPolygon(o, f) {
    for (var a = o.coordinates[0], i = 0, n = a.length; i < n; i++) {
      f.apply(null, a[i]);
    }
  }
  function d3_geo_greatArcSource(d) {
    return d.source;
  }
  function d3_geo_greatArcTarget(d) {
    return d.target;
  }
  function d3_geo_greatArcInterpolator() {
    function interpolate(t) {
      var B = Math.sin(t *= d) * k, A = Math.sin(d - t) * k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;
      return [ Math.atan2(y, x) / d3_geo_radians, Math.atan2(z, Math.sqrt(x * x + y * y)) / d3_geo_radians ];
    }
    var x0, y0, cy0, sy0, kx0, ky0, x1, y1, cy1, sy1, kx1, ky1, d, k;
    interpolate.distance = function() {
      if (d == null) k = 1 / Math.sin(d = Math.acos(Math.max(-1, Math.min(1, sy0 * sy1 + cy0 * cy1 * Math.cos(x1 - x0)))));
      return d;
    };
    interpolate.source = function(_) {
      var cx0 = Math.cos(x0 = _[0] * d3_geo_radians), sx0 = Math.sin(x0);
      cy0 = Math.cos(y0 = _[1] * d3_geo_radians);
      sy0 = Math.sin(y0);
      kx0 = cy0 * cx0;
      ky0 = cy0 * sx0;
      d = null;
      return interpolate;
    };
    interpolate.target = function(_) {
      var cx1 = Math.cos(x1 = _[0] * d3_geo_radians), sx1 = Math.sin(x1);
      cy1 = Math.cos(y1 = _[1] * d3_geo_radians);
      sy1 = Math.sin(y1);
      kx1 = cy1 * cx1;
      ky1 = cy1 * sx1;
      d = null;
      return interpolate;
    };
    return interpolate;
  }
  function d3_geo_greatArcInterpolate(a, b) {
    var i = d3_geo_greatArcInterpolator().source(a).target(b);
    i.distance();
    return i;
  }
  function d3_geom_contourStart(grid) {
    var x = 0, y = 0;
    while (true) {
      if (grid(x, y)) {
        return [ x, y ];
      }
      if (x === 0) {
        x = y + 1;
        y = 0;
      } else {
        x = x - 1;
        y = y + 1;
      }
    }
  }
  function d3_geom_hullCCW(i1, i2, i3, v) {
    var t, a, b, c, d, e, f;
    t = v[i1];
    a = t[0];
    b = t[1];
    t = v[i2];
    c = t[0];
    d = t[1];
    t = v[i3];
    e = t[0];
    f = t[1];
    return (f - b) * (c - a) - (d - b) * (e - a) > 0;
  }
  function d3_geom_polygonInside(p, a, b) {
    return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
  }
  function d3_geom_polygonIntersect(c, d, a, b) {
    var x1 = c[0], x2 = d[0], x3 = a[0], x4 = b[0], y1 = c[1], y2 = d[1], y3 = a[1], y4 = b[1], x13 = x1 - x3, x21 = x2 - x1, x43 = x4 - x3, y13 = y1 - y3, y21 = y2 - y1, y43 = y4 - y3, ua = (x43 * y13 - y43 * x13) / (y43 * x21 - x43 * y21);
    return [ x1 + ua * x21, y1 + ua * y21 ];
  }
  function d3_voronoi_tessellate(vertices, callback) {
    var Sites = {
      list: vertices.map(function(v, i) {
        return {
          index: i,
          x: v[0],
          y: v[1]
        };
      }).sort(function(a, b) {
        return a.y < b.y ? -1 : a.y > b.y ? 1 : a.x < b.x ? -1 : a.x > b.x ? 1 : 0;
      }),
      bottomSite: null
    };
    var EdgeList = {
      list: [],
      leftEnd: null,
      rightEnd: null,
      init: function() {
        EdgeList.leftEnd = EdgeList.createHalfEdge(null, "l");
        EdgeList.rightEnd = EdgeList.createHalfEdge(null, "l");
        EdgeList.leftEnd.r = EdgeList.rightEnd;
        EdgeList.rightEnd.l = EdgeList.leftEnd;
        EdgeList.list.unshift(EdgeList.leftEnd, EdgeList.rightEnd);
      },
      createHalfEdge: function(edge, side) {
        return {
          edge: edge,
          side: side,
          vertex: null,
          l: null,
          r: null
        };
      },
      insert: function(lb, he) {
        he.l = lb;
        he.r = lb.r;
        lb.r.l = he;
        lb.r = he;
      },
      leftBound: function(p) {
        var he = EdgeList.leftEnd;
        do {
          he = he.r;
        } while (he != EdgeList.rightEnd && Geom.rightOf(he, p));
        he = he.l;
        return he;
      },
      del: function(he) {
        he.l.r = he.r;
        he.r.l = he.l;
        he.edge = null;
      },
      right: function(he) {
        return he.r;
      },
      left: function(he) {
        return he.l;
      },
      leftRegion: function(he) {
        return he.edge == null ? Sites.bottomSite : he.edge.region[he.side];
      },
      rightRegion: function(he) {
        return he.edge == null ? Sites.bottomSite : he.edge.region[d3_voronoi_opposite[he.side]];
      }
    };
    var Geom = {
      bisect: function(s1, s2) {
        var newEdge = {
          region: {
            l: s1,
            r: s2
          },
          ep: {
            l: null,
            r: null
          }
        };
        var dx = s2.x - s1.x, dy = s2.y - s1.y, adx = dx > 0 ? dx : -dx, ady = dy > 0 ? dy : -dy;
        newEdge.c = s1.x * dx + s1.y * dy + (dx * dx + dy * dy) * .5;
        if (adx > ady) {
          newEdge.a = 1;
          newEdge.b = dy / dx;
          newEdge.c /= dx;
        } else {
          newEdge.b = 1;
          newEdge.a = dx / dy;
          newEdge.c /= dy;
        }
        return newEdge;
      },
      intersect: function(el1, el2) {
        var e1 = el1.edge, e2 = el2.edge;
        if (!e1 || !e2 || e1.region.r == e2.region.r) {
          return null;
        }
        var d = e1.a * e2.b - e1.b * e2.a;
        if (Math.abs(d) < 1e-10) {
          return null;
        }
        var xint = (e1.c * e2.b - e2.c * e1.b) / d, yint = (e2.c * e1.a - e1.c * e2.a) / d, e1r = e1.region.r, e2r = e2.region.r, el, e;
        if (e1r.y < e2r.y || e1r.y == e2r.y && e1r.x < e2r.x) {
          el = el1;
          e = e1;
        } else {
          el = el2;
          e = e2;
        }
        var rightOfSite = xint >= e.region.r.x;
        if (rightOfSite && el.side === "l" || !rightOfSite && el.side === "r") {
          return null;
        }
        return {
          x: xint,
          y: yint
        };
      },
      rightOf: function(he, p) {
        var e = he.edge, topsite = e.region.r, rightOfSite = p.x > topsite.x;
        if (rightOfSite && he.side === "l") {
          return 1;
        }
        if (!rightOfSite && he.side === "r") {
          return 0;
        }
        if (e.a === 1) {
          var dyp = p.y - topsite.y, dxp = p.x - topsite.x, fast = 0, above = 0;
          if (!rightOfSite && e.b < 0 || rightOfSite && e.b >= 0) {
            above = fast = dyp >= e.b * dxp;
          } else {
            above = p.x + p.y * e.b > e.c;
            if (e.b < 0) {
              above = !above;
            }
            if (!above) {
              fast = 1;
            }
          }
          if (!fast) {
            var dxs = topsite.x - e.region.l.x;
            above = e.b * (dxp * dxp - dyp * dyp) < dxs * dyp * (1 + 2 * dxp / dxs + e.b * e.b);
            if (e.b < 0) {
              above = !above;
            }
          }
        } else {
          var yl = e.c - e.a * p.x, t1 = p.y - yl, t2 = p.x - topsite.x, t3 = yl - topsite.y;
          above = t1 * t1 > t2 * t2 + t3 * t3;
        }
        return he.side === "l" ? above : !above;
      },
      endPoint: function(edge, side, site) {
        edge.ep[side] = site;
        if (!edge.ep[d3_voronoi_opposite[side]]) return;
        callback(edge);
      },
      distance: function(s, t) {
        var dx = s.x - t.x, dy = s.y - t.y;
        return Math.sqrt(dx * dx + dy * dy);
      }
    };
    var EventQueue = {
      list: [],
      insert: function(he, site, offset) {
        he.vertex = site;
        he.ystar = site.y + offset;
        for (var i = 0, list = EventQueue.list, l = list.length; i < l; i++) {
          var next = list[i];
          if (he.ystar > next.ystar || he.ystar == next.ystar && site.x > next.vertex.x) {
            continue;
          } else {
            break;
          }
        }
        list.splice(i, 0, he);
      },
      del: function(he) {
        for (var i = 0, ls = EventQueue.list, l = ls.length; i < l && ls[i] != he; ++i) {}
        ls.splice(i, 1);
      },
      empty: function() {
        return EventQueue.list.length === 0;
      },
      nextEvent: function(he) {
        for (var i = 0, ls = EventQueue.list, l = ls.length; i < l; ++i) {
          if (ls[i] == he) return ls[i + 1];
        }
        return null;
      },
      min: function() {
        var elem = EventQueue.list[0];
        return {
          x: elem.vertex.x,
          y: elem.ystar
        };
      },
      extractMin: function() {
        return EventQueue.list.shift();
      }
    };
    EdgeList.init();
    Sites.bottomSite = Sites.list.shift();
    var newSite = Sites.list.shift(), newIntStar;
    var lbnd, rbnd, llbnd, rrbnd, bisector;
    var bot, top, temp, p, v;
    var e, pm;
    while (true) {
      if (!EventQueue.empty()) {
        newIntStar = EventQueue.min();
      }
      if (newSite && (EventQueue.empty() || newSite.y < newIntStar.y || newSite.y == newIntStar.y && newSite.x < newIntStar.x)) {
        lbnd = EdgeList.leftBound(newSite);
        rbnd = EdgeList.right(lbnd);
        bot = EdgeList.rightRegion(lbnd);
        e = Geom.bisect(bot, newSite);
        bisector = EdgeList.createHalfEdge(e, "l");
        EdgeList.insert(lbnd, bisector);
        p = Geom.intersect(lbnd, bisector);
        if (p) {
          EventQueue.del(lbnd);
          EventQueue.insert(lbnd, p, Geom.distance(p, newSite));
        }
        lbnd = bisector;
        bisector = EdgeList.createHalfEdge(e, "r");
        EdgeList.insert(lbnd, bisector);
        p = Geom.intersect(bisector, rbnd);
        if (p) {
          EventQueue.insert(bisector, p, Geom.distance(p, newSite));
        }
        newSite = Sites.list.shift();
      } else if (!EventQueue.empty()) {
        lbnd = EventQueue.extractMin();
        llbnd = EdgeList.left(lbnd);
        rbnd = EdgeList.right(lbnd);
        rrbnd = EdgeList.right(rbnd);
        bot = EdgeList.leftRegion(lbnd);
        top = EdgeList.rightRegion(rbnd);
        v = lbnd.vertex;
        Geom.endPoint(lbnd.edge, lbnd.side, v);
        Geom.endPoint(rbnd.edge, rbnd.side, v);
        EdgeList.del(lbnd);
        EventQueue.del(rbnd);
        EdgeList.del(rbnd);
        pm = "l";
        if (bot.y > top.y) {
          temp = bot;
          bot = top;
          top = temp;
          pm = "r";
        }
        e = Geom.bisect(bot, top);
        bisector = EdgeList.createHalfEdge(e, pm);
        EdgeList.insert(llbnd, bisector);
        Geom.endPoint(e, d3_voronoi_opposite[pm], v);
        p = Geom.intersect(llbnd, bisector);
        if (p) {
          EventQueue.del(llbnd);
          EventQueue.insert(llbnd, p, Geom.distance(p, bot));
        }
        p = Geom.intersect(bisector, rrbnd);
        if (p) {
          EventQueue.insert(bisector, p, Geom.distance(p, bot));
        }
      } else {
        break;
      }
    }
    for (lbnd = EdgeList.right(EdgeList.leftEnd); lbnd != EdgeList.rightEnd; lbnd = EdgeList.right(lbnd)) {
      callback(lbnd.edge);
    }
  }
  function d3_geom_quadtreeNode() {
    return {
      leaf: true,
      nodes: [],
      point: null
    };
  }
  function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
    if (!f(node, x1, y1, x2, y2)) {
      var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, children = node.nodes;
      if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);
      if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);
      if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);
      if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);
    }
  }
  function d3_geom_quadtreePoint(p) {
    return {
      x: p[0],
      y: p[1]
    };
  }
  function d3_time_utc() {
    this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);
  }
  function d3_time_formatAbbreviate(name) {
    return name.substring(0, 3);
  }
  function d3_time_parse(date, template, string, j) {
    var c, p, i = 0, n = template.length, m = string.length;
    while (i < n) {
      if (j >= m) return -1;
      c = template.charCodeAt(i++);
      if (c == 37) {
        p = d3_time_parsers[template.charAt(i++)];
        if (!p || (j = p(date, string, j)) < 0) return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }
    return j;
  }
  function d3_time_formatRe(names) {
    return new RegExp("^(?:" + names.map(d3.requote).join("|") + ")", "i");
  }
  function d3_time_formatLookup(names) {
    var map = new d3_Map, i = -1, n = names.length;
    while (++i < n) map.set(names[i].toLowerCase(), i);
    return map;
  }
  function d3_time_parseWeekdayAbbrev(date, string, i) {
    d3_time_dayAbbrevRe.lastIndex = 0;
    var n = d3_time_dayAbbrevRe.exec(string.substring(i));
    return n ? i += n[0].length : -1;
  }
  function d3_time_parseWeekday(date, string, i) {
    d3_time_dayRe.lastIndex = 0;
    var n = d3_time_dayRe.exec(string.substring(i));
    return n ? i += n[0].length : -1;
  }
  function d3_time_parseMonthAbbrev(date, string, i) {
    d3_time_monthAbbrevRe.lastIndex = 0;
    var n = d3_time_monthAbbrevRe.exec(string.substring(i));
    return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i += n[0].length) : -1;
  }
  function d3_time_parseMonth(date, string, i) {
    d3_time_monthRe.lastIndex = 0;
    var n = d3_time_monthRe.exec(string.substring(i));
    return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i += n[0].length) : -1;
  }
  function d3_time_parseLocaleFull(date, string, i) {
    return d3_time_parse(date, d3_time_formats.c.toString(), string, i);
  }
  function d3_time_parseLocaleDate(date, string, i) {
    return d3_time_parse(date, d3_time_formats.x.toString(), string, i);
  }
  function d3_time_parseLocaleTime(date, string, i) {
    return d3_time_parse(date, d3_time_formats.X.toString(), string, i);
  }
  function d3_time_parseFullYear(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 4));
    return n ? (date.y = +n[0], i += n[0].length) : -1;
  }
  function d3_time_parseYear(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 2));
    return n ? (date.y = d3_time_expandYear(+n[0]), i += n[0].length) : -1;
  }
  function d3_time_expandYear(d) {
    return d + (d > 68 ? 1900 : 2e3);
  }
  function d3_time_parseMonthNumber(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 2));
    return n ? (date.m = n[0] - 1, i += n[0].length) : -1;
  }
  function d3_time_parseDay(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 2));
    return n ? (date.d = +n[0], i += n[0].length) : -1;
  }
  function d3_time_parseHour24(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 2));
    return n ? (date.H = +n[0], i += n[0].length) : -1;
  }
  function d3_time_parseMinutes(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 2));
    return n ? (date.M = +n[0], i += n[0].length) : -1;
  }
  function d3_time_parseSeconds(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 2));
    return n ? (date.S = +n[0], i += n[0].length) : -1;
  }
  function d3_time_parseMilliseconds(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 3));
    return n ? (date.L = +n[0], i += n[0].length) : -1;
  }
  function d3_time_parseAmPm(date, string, i) {
    var n = d3_time_amPmLookup.get(string.substring(i, i += 2).toLowerCase());
    return n == null ? -1 : (date.p = n, i);
  }
  function d3_time_zone(d) {
    var z = d.getTimezoneOffset(), zs = z > 0 ? "-" : "+", zh = ~~(Math.abs(z) / 60), zm = Math.abs(z) % 60;
    return zs + d3_time_zfill2(zh) + d3_time_zfill2(zm);
  }
  function d3_time_formatIsoNative(date) {
    return date.toISOString();
  }
  function d3_time_interval(local, step, number) {
    function round(date) {
      var d0 = local(date), d1 = offset(d0, 1);
      return date - d0 < d1 - date ? d0 : d1;
    }
    function ceil(date) {
      step(date = local(new d3_time(date - 1)), 1);
      return date;
    }
    function offset(date, k) {
      step(date = new d3_time(+date), k);
      return date;
    }
    function range(t0, t1, dt) {
      var time = ceil(t0), times = [];
      if (dt > 1) {
        while (time < t1) {
          if (!(number(time) % dt)) times.push(new Date(+time));
          step(time, 1);
        }
      } else {
        while (time < t1) times.push(new Date(+time)), step(time, 1);
      }
      return times;
    }
    function range_utc(t0, t1, dt) {
      try {
        d3_time = d3_time_utc;
        var utc = new d3_time_utc;
        utc._ = t0;
        return range(utc, t1, dt);
      } finally {
        d3_time = Date;
      }
    }
    local.floor = local;
    local.round = round;
    local.ceil = ceil;
    local.offset = offset;
    local.range = range;
    var utc = local.utc = d3_time_interval_utc(local);
    utc.floor = utc;
    utc.round = d3_time_interval_utc(round);
    utc.ceil = d3_time_interval_utc(ceil);
    utc.offset = d3_time_interval_utc(offset);
    utc.range = range_utc;
    return local;
  }
  function d3_time_interval_utc(method) {
    return function(date, k) {
      try {
        d3_time = d3_time_utc;
        var utc = new d3_time_utc;
        utc._ = date;
        return method(utc, k)._;
      } finally {
        d3_time = Date;
      }
    };
  }
  function d3_time_scale(linear, methods, format) {
    function scale(x) {
      return linear(x);
    }
    scale.invert = function(x) {
      return d3_time_scaleDate(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return linear.domain().map(d3_time_scaleDate);
      linear.domain(x);
      return scale;
    };
    scale.nice = function(m) {
      return scale.domain(d3_scale_nice(scale.domain(), function() {
        return m;
      }));
    };
    scale.ticks = function(m, k) {
      var extent = d3_time_scaleExtent(scale.domain());
      if (typeof m !== "function") {
        var span = extent[1] - extent[0], target = span / m, i = d3.bisect(d3_time_scaleSteps, target);
        if (i == d3_time_scaleSteps.length) return methods.year(extent, m);
        if (!i) return linear.ticks(m).map(d3_time_scaleDate);
        if (Math.log(target / d3_time_scaleSteps[i - 1]) < Math.log(d3_time_scaleSteps[i] / target)) --i;
        m = methods[i];
        k = m[1];
        m = m[0].range;
      }
      return m(extent[0], new Date(+extent[1] + 1), k);
    };
    scale.tickFormat = function() {
      return format;
    };
    scale.copy = function() {
      return d3_time_scale(linear.copy(), methods, format);
    };
    return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
  }
  function d3_time_scaleExtent(domain) {
    var start = domain[0], stop = domain[domain.length - 1];
    return start < stop ? [ start, stop ] : [ stop, start ];
  }
  function d3_time_scaleDate(t) {
    return new Date(t);
  }
  function d3_time_scaleFormat(formats) {
    return function(date) {
      var i = formats.length - 1, f = formats[i];
      while (!f[1](date)) f = formats[--i];
      return f[0](date);
    };
  }
  function d3_time_scaleSetYear(y) {
    var d = new Date(y, 0, 1);
    d.setFullYear(y);
    return d;
  }
  function d3_time_scaleGetYear(d) {
    var y = d.getFullYear(), d0 = d3_time_scaleSetYear(y), d1 = d3_time_scaleSetYear(y + 1);
    return y + (d - d0) / (d1 - d0);
  }
  function d3_time_scaleUTCSetYear(y) {
    var d = new Date(Date.UTC(y, 0, 1));
    d.setUTCFullYear(y);
    return d;
  }
  function d3_time_scaleUTCGetYear(d) {
    var y = d.getUTCFullYear(), d0 = d3_time_scaleUTCSetYear(y), d1 = d3_time_scaleUTCSetYear(y + 1);
    return y + (d - d0) / (d1 - d0);
  }
  if (!Date.now) Date.now = function() {
    return +(new Date);
  };
  try {
    document.createElement("div").style.setProperty("opacity", 0, "");
  } catch (error) {
    var d3_style_prototype = CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;
    d3_style_prototype.setProperty = function(name, value, priority) {
      d3_style_setProperty.call(this, name, value + "", priority);
    };
  }
  d3 = {
    version: "2.10.3"
  };
  var d3_array = d3_arraySlice;
  try {
    d3_array(document.documentElement.childNodes)[0].nodeType;
  } catch (e) {
    d3_array = d3_arrayCopy;
  }
  var d3_arraySubclass = [].__proto__ ? function(array, prototype) {
    array.__proto__ = prototype;
  } : function(array, prototype) {
    for (var property in prototype) array[property] = prototype[property];
  };
  d3.map = function(object) {
    var map = new d3_Map;
    for (var key in object) map.set(key, object[key]);
    return map;
  };
  d3_class(d3_Map, {
    has: function(key) {
      return d3_map_prefix + key in this;
    },
    get: function(key) {
      return this[d3_map_prefix + key];
    },
    set: function(key, value) {
      return this[d3_map_prefix + key] = value;
    },
    remove: function(key) {
      key = d3_map_prefix + key;
      return key in this && delete this[key];
    },
    keys: function() {
      var keys = [];
      this.forEach(function(key) {
        keys.push(key);
      });
      return keys;
    },
    values: function() {
      var values = [];
      this.forEach(function(key, value) {
        values.push(value);
      });
      return values;
    },
    entries: function() {
      var entries = [];
      this.forEach(function(key, value) {
        entries.push({
          key: key,
          value: value
        });
      });
      return entries;
    },
    forEach: function(f) {
      for (var key in this) {
        if (key.charCodeAt(0) === d3_map_prefixCode) {
          f.call(this, key.substring(1), this[key]);
        }
      }
    }
  });
  var d3_map_prefix = "\0", d3_map_prefixCode = d3_map_prefix.charCodeAt(0);
  d3.functor = d3_functor;
  d3.rebind = function(target, source) {
    var i = 1, n = arguments.length, method;
    while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);
    return target;
  };
  d3.ascending = function(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  };
  d3.descending = function(a, b) {
    return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
  };
  d3.mean = function(array, f) {
    var n = array.length, a, m = 0, i = -1, j = 0;
    if (arguments.length === 1) {
      while (++i < n) if (d3_number(a = array[i])) m += (a - m) / ++j;
    } else {
      while (++i < n) if (d3_number(a = f.call(array, array[i], i))) m += (a - m) / ++j;
    }
    return j ? m : undefined;
  };
  d3.median = function(array, f) {
    if (arguments.length > 1) array = array.map(f);
    array = array.filter(d3_number);
    return array.length ? d3.quantile(array.sort(d3.ascending), .5) : undefined;
  };
  d3.min = function(array, f) {
    var i = -1, n = array.length, a, b;
    if (arguments.length === 1) {
      while (++i < n && ((a = array[i]) == null || a != a)) a = undefined;
      while (++i < n) if ((b = array[i]) != null && a > b) a = b;
    } else {
      while (++i < n && ((a = f.call(array, array[i], i)) == null || a != a)) a = undefined;
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;
    }
    return a;
  };
  d3.max = function(array, f) {
    var i = -1, n = array.length, a, b;
    if (arguments.length === 1) {
      while (++i < n && ((a = array[i]) == null || a != a)) a = undefined;
      while (++i < n) if ((b = array[i]) != null && b > a) a = b;
    } else {
      while (++i < n && ((a = f.call(array, array[i], i)) == null || a != a)) a = undefined;
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;
    }
    return a;
  };
  d3.extent = function(array, f) {
    var i = -1, n = array.length, a, b, c;
    if (arguments.length === 1) {
      while (++i < n && ((a = c = array[i]) == null || a != a)) a = c = undefined;
      while (++i < n) if ((b = array[i]) != null) {
        if (a > b) a = b;
        if (c < b) c = b;
      }
    } else {
      while (++i < n && ((a = c = f.call(array, array[i], i)) == null || a != a)) a = undefined;
      while (++i < n) if ((b = f.call(array, array[i], i)) != null) {
        if (a > b) a = b;
        if (c < b) c = b;
      }
    }
    return [ a, c ];
  };
  d3.random = {
    normal: function(µ, σ) {
      var n = arguments.length;
      if (n < 2) σ = 1;
      if (n < 1) µ = 0;
      return function() {
        var x, y, r;
        do {
          x = Math.random() * 2 - 1;
          y = Math.random() * 2 - 1;
          r = x * x + y * y;
        } while (!r || r > 1);
        return µ + σ * x * Math.sqrt(-2 * Math.log(r) / r);
      };
    },
    logNormal: function(µ, σ) {
      var n = arguments.length;
      if (n < 2) σ = 1;
      if (n < 1) µ = 0;
      var random = d3.random.normal();
      return function() {
        return Math.exp(µ + σ * random());
      };
    },
    irwinHall: function(m) {
      return function() {
        for (var s = 0, j = 0; j < m; j++) s += Math.random();
        return s / m;
      };
    }
  };
  d3.sum = function(array, f) {
    var s = 0, n = array.length, a, i = -1;
    if (arguments.length === 1) {
      while (++i < n) if (!isNaN(a = +array[i])) s += a;
    } else {
      while (++i < n) if (!isNaN(a = +f.call(array, array[i], i))) s += a;
    }
    return s;
  };
  d3.quantile = function(values, p) {
    var H = (values.length - 1) * p + 1, h = Math.floor(H), v = values[h - 1], e = H - h;
    return e ? v + e * (values[h] - v) : v;
  };
  d3.transpose = function(matrix) {
    return d3.zip.apply(d3, matrix);
  };
  d3.zip = function() {
    if (!(n = arguments.length)) return [];
    for (var i = -1, m = d3.min(arguments, d3_zipLength), zips = new Array(m); ++i < m; ) {
      for (var j = -1, n, zip = zips[i] = new Array(n); ++j < n; ) {
        zip[j] = arguments[j][i];
      }
    }
    return zips;
  };
  d3.bisector = function(f) {
    return {
      left: function(a, x, lo, hi) {
        if (arguments.length < 3) lo = 0;
        if (arguments.length < 4) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (f.call(a, a[mid], mid) < x) lo = mid + 1; else hi = mid;
        }
        return lo;
      },
      right: function(a, x, lo, hi) {
        if (arguments.length < 3) lo = 0;
        if (arguments.length < 4) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (x < f.call(a, a[mid], mid)) hi = mid; else lo = mid + 1;
        }
        return lo;
      }
    };
  };
  var d3_bisector = d3.bisector(function(d) {
    return d;
  });
  d3.bisectLeft = d3_bisector.left;
  d3.bisect = d3.bisectRight = d3_bisector.right;
  d3.first = function(array, f) {
    var i = 0, n = array.length, a = array[0], b;
    if (arguments.length === 1) f = d3.ascending;
    while (++i < n) {
      if (f.call(array, a, b = array[i]) > 0) {
        a = b;
      }
    }
    return a;
  };
  d3.last = function(array, f) {
    var i = 0, n = array.length, a = array[0], b;
    if (arguments.length === 1) f = d3.ascending;
    while (++i < n) {
      if (f.call(array, a, b = array[i]) <= 0) {
        a = b;
      }
    }
    return a;
  };
  d3.nest = function() {
    function map(array, depth) {
      if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;
      var i = -1, n = array.length, key = keys[depth++], keyValue, object, valuesByKey = new d3_Map, values, o = {};
      while (++i < n) {
        if (values = valuesByKey.get(keyValue = key(object = array[i]))) {
          values.push(object);
        } else {
          valuesByKey.set(keyValue, [ object ]);
        }
      }
      valuesByKey.forEach(function(keyValue, values) {
        o[keyValue] = map(values, depth);
      });
      return o;
    }
    function entries(map, depth) {
      if (depth >= keys.length) return map;
      var a = [], sortKey = sortKeys[depth++], key;
      for (key in map) {
        a.push({
          key: key,
          values: entries(map[key], depth)
        });
      }
      if (sortKey) a.sort(function(a, b) {
        return sortKey(a.key, b.key);
      });
      return a;
    }
    var nest = {}, keys = [], sortKeys = [], sortValues, rollup;
    nest.map = function(array) {
      return map(array, 0);
    };
    nest.entries = function(array) {
      return entries(map(array, 0), 0);
    };
    nest.key = function(d) {
      keys.push(d);
      return nest;
    };
    nest.sortKeys = function(order) {
      sortKeys[keys.length - 1] = order;
      return nest;
    };
    nest.sortValues = function(order) {
      sortValues = order;
      return nest;
    };
    nest.rollup = function(f) {
      rollup = f;
      return nest;
    };
    return nest;
  };
  d3.keys = function(map) {
    var keys = [];
    for (var key in map) keys.push(key);
    return keys;
  };
  d3.values = function(map) {
    var values = [];
    for (var key in map) values.push(map[key]);
    return values;
  };
  d3.entries = function(map) {
    var entries = [];
    for (var key in map) entries.push({
      key: key,
      value: map[key]
    });
    return entries;
  };
  d3.permute = function(array, indexes) {
    var permutes = [], i = -1, n = indexes.length;
    while (++i < n) permutes[i] = array[indexes[i]];
    return permutes;
  };
  d3.merge = function(arrays) {
    return Array.prototype.concat.apply([], arrays);
  };
  d3.split = function(array, f) {
    var arrays = [], values = [], value, i = -1, n = array.length;
    if (arguments.length < 2) f = d3_splitter;
    while (++i < n) {
      if (f.call(values, value = array[i], i)) {
        values = [];
      } else {
        if (!values.length) arrays.push(values);
        values.push(value);
      }
    }
    return arrays;
  };
  d3.range = function(start, stop, step) {
    if (arguments.length < 3) {
      step = 1;
      if (arguments.length < 2) {
        stop = start;
        start = 0;
      }
    }
    if ((stop - start) / step === Infinity) throw new Error("infinite range");
    var range = [], k = d3_range_integerScale(Math.abs(step)), i = -1, j;
    start *= k, stop *= k, step *= k;
    if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k); else while ((j = start + step * ++i) < stop) range.push(j / k);
    return range;
  };
  d3.requote = function(s) {
    return s.replace(d3_requote_re, "\\$&");
  };
  var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
  d3.round = function(x, n) {
    return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
  };
  d3.xhr = function(url, mime, callback) {
    var req = new XMLHttpRequest;
    if (arguments.length < 3) callback = mime, mime = null; else if (mime && req.overrideMimeType) req.overrideMimeType(mime);
    req.open("GET", url, true);
    if (mime) req.setRequestHeader("Accept", mime);
    req.onreadystatechange = function() {
      if (req.readyState === 4) {
        var s = req.status;
        callback(!s && req.response || s >= 200 && s < 300 || s === 304 ? req : null);
      }
    };
    req.send(null);
  };
  d3.text = function(url, mime, callback) {
    function ready(req) {
      callback(req && req.responseText);
    }
    if (arguments.length < 3) {
      callback = mime;
      mime = null;
    }
    d3.xhr(url, mime, ready);
  };
  d3.json = function(url, callback) {
    d3.text(url, "application/json", function(text) {
      callback(text ? JSON.parse(text) : null);
    });
  };
  d3.html = function(url, callback) {
    d3.text(url, "text/html", function(text) {
      if (text != null) {
        var range = document.createRange();
        range.selectNode(document.body);
        text = range.createContextualFragment(text);
      }
      callback(text);
    });
  };
  d3.xml = function(url, mime, callback) {
    function ready(req) {
      callback(req && req.responseXML);
    }
    if (arguments.length < 3) {
      callback = mime;
      mime = null;
    }
    d3.xhr(url, mime, ready);
  };
  var d3_nsPrefix = {
    svg: "http://www.w3.org/2000/svg",
    xhtml: "http://www.w3.org/1999/xhtml",
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
  };
  d3.ns = {
    prefix: d3_nsPrefix,
    qualify: function(name) {
      var i = name.indexOf(":"), prefix = name;
      if (i >= 0) {
        prefix = name.substring(0, i);
        name = name.substring(i + 1);
      }
      return d3_nsPrefix.hasOwnProperty(prefix) ? {
        space: d3_nsPrefix[prefix],
        local: name
      } : name;
    }
  };
  d3.dispatch = function() {
    var dispatch = new d3_dispatch, i = -1, n = arguments.length;
    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
    return dispatch;
  };
  d3_dispatch.prototype.on = function(type, listener) {
    var i = type.indexOf("."), name = "";
    if (i > 0) {
      name = type.substring(i + 1);
      type = type.substring(0, i);
    }
    return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
  };
  d3.format = function(specifier) {
    var match = d3_format_re.exec(specifier), fill = match[1] || " ", sign = match[3] || "", zfill = match[5], width = +match[6], comma = match[7], precision = match[8], type = match[9], scale = 1, suffix = "", integer = false;
    if (precision) precision = +precision.substring(1);
    if (zfill) {
      fill = "0";
      if (comma) width -= Math.floor((width - 1) / 4);
    }
    switch (type) {
     case "n":
      comma = true;
      type = "g";
      break;
     case "%":
      scale = 100;
      suffix = "%";
      type = "f";
      break;
     case "p":
      scale = 100;
      suffix = "%";
      type = "r";
      break;
     case "d":
      integer = true;
      precision = 0;
      break;
     case "s":
      scale = -1;
      type = "r";
      break;
    }
    if (type == "r" && !precision) type = "g";
    type = d3_format_types.get(type) || d3_format_typeDefault;
    return function(value) {
      if (integer && value % 1) return "";
      var negative = value < 0 && (value = -value) ? "-" : sign;
      if (scale < 0) {
        var prefix = d3.formatPrefix(value, precision);
        value = prefix.scale(value);
        suffix = prefix.symbol;
      } else {
        value *= scale;
      }
      value = type(value, precision);
      if (zfill) {
        var length = value.length + negative.length;
        if (length < width) value = (new Array(width - length + 1)).join(fill) + value;
        if (comma) value = d3_format_group(value);
        value = negative + value;
      } else {
        if (comma) value = d3_format_group(value);
        value = negative + value;
        var length = value.length;
        if (length < width) value = (new Array(width - length + 1)).join(fill) + value;
      }
      return value + suffix;
    };
  };
  var d3_format_re = /(?:([^{])?([<>=^]))?([+\- ])?(#)?(0)?([0-9]+)?(,)?(\.[0-9]+)?([a-zA-Z%])?/;
  var d3_format_types = d3.map({
    g: function(x, p) {
      return x.toPrecision(p);
    },
    e: function(x, p) {
      return x.toExponential(p);
    },
    f: function(x, p) {
      return x.toFixed(p);
    },
    r: function(x, p) {
      return d3.round(x, p = d3_format_precision(x, p)).toFixed(Math.max(0, Math.min(20, p)));
    }
  });
  var d3_formatPrefixes = [ "y", "z", "a", "f", "p", "n", "μ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y" ].map(d3_formatPrefix);
  d3.formatPrefix = function(value, precision) {
    var i = 0;
    if (value) {
      if (value < 0) value *= -1;
      if (precision) value = d3.round(value, d3_format_precision(value, precision));
      i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);
      i = Math.max(-24, Math.min(24, Math.floor((i <= 0 ? i + 1 : i - 1) / 3) * 3));
    }
    return d3_formatPrefixes[8 + i / 3];
  };
  var d3_ease_quad = d3_ease_poly(2), d3_ease_cubic = d3_ease_poly(3), d3_ease_default = function() {
    return d3_ease_identity;
  };
  var d3_ease = d3.map({
    linear: d3_ease_default,
    poly: d3_ease_poly,
    quad: function() {
      return d3_ease_quad;
    },
    cubic: function() {
      return d3_ease_cubic;
    },
    sin: function() {
      return d3_ease_sin;
    },
    exp: function() {
      return d3_ease_exp;
    },
    circle: function() {
      return d3_ease_circle;
    },
    elastic: d3_ease_elastic,
    back: d3_ease_back,
    bounce: function() {
      return d3_ease_bounce;
    }
  });
  var d3_ease_mode = d3.map({
    "in": d3_ease_identity,
    out: d3_ease_reverse,
    "in-out": d3_ease_reflect,
    "out-in": function(f) {
      return d3_ease_reflect(d3_ease_reverse(f));
    }
  });
  d3.ease = function(name) {
    var i = name.indexOf("-"), t = i >= 0 ? name.substring(0, i) : name, m = i >= 0 ? name.substring(i + 1) : "in";
    t = d3_ease.get(t) || d3_ease_default;
    m = d3_ease_mode.get(m) || d3_ease_identity;
    return d3_ease_clamp(m(t.apply(null, Array.prototype.slice.call(arguments, 1))));
  };
  d3.event = null;
  d3.transform = function(string) {
    var g = document.createElementNS(d3.ns.prefix.svg, "g");
    return (d3.transform = function(string) {
      g.setAttribute("transform", string);
      var t = g.transform.baseVal.consolidate();
      return new d3_transform(t ? t.matrix : d3_transformIdentity);
    })(string);
  };
  d3_transform.prototype.toString = function() {
    return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")";
  };
  var d3_transformDegrees = 180 / Math.PI, d3_transformIdentity = {
    a: 1,
    b: 0,
    c: 0,
    d: 1,
    e: 0,
    f: 0
  };
  d3.interpolate = function(a, b) {
    var i = d3.interpolators.length, f;
    while (--i >= 0 && !(f = d3.interpolators[i](a, b))) ;
    return f;
  };
  d3.interpolateNumber = function(a, b) {
    b -= a;
    return function(t) {
      return a + b * t;
    };
  };
  d3.interpolateRound = function(a, b) {
    b -= a;
    return function(t) {
      return Math.round(a + b * t);
    };
  };
  d3.interpolateString = function(a, b) {
    var m, i, j, s0 = 0, s1 = 0, s = [], q = [], n, o;
    d3_interpolate_number.lastIndex = 0;
    for (i = 0; m = d3_interpolate_number.exec(b); ++i) {
      if (m.index) s.push(b.substring(s0, s1 = m.index));
      q.push({
        i: s.length,
        x: m[0]
      });
      s.push(null);
      s0 = d3_interpolate_number.lastIndex;
    }
    if (s0 < b.length) s.push(b.substring(s0));
    for (i = 0, n = q.length; (m = d3_interpolate_number.exec(a)) && i < n; ++i) {
      o = q[i];
      if (o.x == m[0]) {
        if (o.i) {
          if (s[o.i + 1] == null) {
            s[o.i - 1] += o.x;
            s.splice(o.i, 1);
            for (j = i + 1; j < n; ++j) q[j].i--;
          } else {
            s[o.i - 1] += o.x + s[o.i + 1];
            s.splice(o.i, 2);
            for (j = i + 1; j < n; ++j) q[j].i -= 2;
          }
        } else {
          if (s[o.i + 1] == null) {
            s[o.i] = o.x;
          } else {
            s[o.i] = o.x + s[o.i + 1];
            s.splice(o.i + 1, 1);
            for (j = i + 1; j < n; ++j) q[j].i--;
          }
        }
        q.splice(i, 1);
        n--;
        i--;
      } else {
        o.x = d3.interpolateNumber(parseFloat(m[0]), parseFloat(o.x));
      }
    }
    while (i < n) {
      o = q.pop();
      if (s[o.i + 1] == null) {
        s[o.i] = o.x;
      } else {
        s[o.i] = o.x + s[o.i + 1];
        s.splice(o.i + 1, 1);
      }
      n--;
    }
    if (s.length === 1) {
      return s[0] == null ? q[0].x : function() {
        return b;
      };
    }
    return function(t) {
      for (i = 0; i < n; ++i) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
  d3.interpolateTransform = function(a, b) {
    var s = [], q = [], n, A = d3.transform(a), B = d3.transform(b), ta = A.translate, tb = B.translate, ra = A.rotate, rb = B.rotate, wa = A.skew, wb = B.skew, ka = A.scale, kb = B.scale;
    if (ta[0] != tb[0] || ta[1] != tb[1]) {
      s.push("translate(", null, ",", null, ")");
      q.push({
        i: 1,
        x: d3.interpolateNumber(ta[0], tb[0])
      }, {
        i: 3,
        x: d3.interpolateNumber(ta[1], tb[1])
      });
    } else if (tb[0] || tb[1]) {
      s.push("translate(" + tb + ")");
    } else {
      s.push("");
    }
    if (ra != rb) {
      if (ra - rb > 180) rb += 360; else if (rb - ra > 180) ra += 360;
      q.push({
        i: s.push(s.pop() + "rotate(", null, ")") - 2,
        x: d3.interpolateNumber(ra, rb)
      });
    } else if (rb) {
      s.push(s.pop() + "rotate(" + rb + ")");
    }
    if (wa != wb) {
      q.push({
        i: s.push(s.pop() + "skewX(", null, ")") - 2,
        x: d3.interpolateNumber(wa, wb)
      });
    } else if (wb) {
      s.push(s.pop() + "skewX(" + wb + ")");
    }
    if (ka[0] != kb[0] || ka[1] != kb[1]) {
      n = s.push(s.pop() + "scale(", null, ",", null, ")");
      q.push({
        i: n - 4,
        x: d3.interpolateNumber(ka[0], kb[0])
      }, {
        i: n - 2,
        x: d3.interpolateNumber(ka[1], kb[1])
      });
    } else if (kb[0] != 1 || kb[1] != 1) {
      s.push(s.pop() + "scale(" + kb + ")");
    }
    n = q.length;
    return function(t) {
      var i = -1, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
  d3.interpolateRgb = function(a, b) {
    a = d3.rgb(a);
    b = d3.rgb(b);
    var ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab;
    return function(t) {
      return "#" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));
    };
  };
  d3.interpolateHsl = function(a, b) {
    a = d3.hsl(a);
    b = d3.hsl(b);
    var h0 = a.h, s0 = a.s, l0 = a.l, h1 = b.h - h0, s1 = b.s - s0, l1 = b.l - l0;
    if (h1 > 180) h1 -= 360; else if (h1 < -180) h1 += 360;
    return function(t) {
      return d3_hsl_rgb(h0 + h1 * t, s0 + s1 * t, l0 + l1 * t) + "";
    };
  };
  d3.interpolateLab = function(a, b) {
    a = d3.lab(a);
    b = d3.lab(b);
    var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab;
    return function(t) {
      return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + "";
    };
  };
  d3.interpolateHcl = function(a, b) {
    a = d3.hcl(a);
    b = d3.hcl(b);
    var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al;
    if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
    return function(t) {
      return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + "";
    };
  };
  d3.interpolateArray = function(a, b) {
    var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i;
    for (i = 0; i < n0; ++i) x.push(d3.interpolate(a[i], b[i]));
    for (; i < na; ++i) c[i] = a[i];
    for (; i < nb; ++i) c[i] = b[i];
    return function(t) {
      for (i = 0; i < n0; ++i) c[i] = x[i](t);
      return c;
    };
  };
  d3.interpolateObject = function(a, b) {
    var i = {}, c = {}, k;
    for (k in a) {
      if (k in b) {
        i[k] = d3_interpolateByName(k)(a[k], b[k]);
      } else {
        c[k] = a[k];
      }
    }
    for (k in b) {
      if (!(k in a)) {
        c[k] = b[k];
      }
    }
    return function(t) {
      for (k in i) c[k] = i[k](t);
      return c;
    };
  };
  var d3_interpolate_number = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
  d3.interpolators = [ d3.interpolateObject, function(a, b) {
    return b instanceof Array && d3.interpolateArray(a, b);
  }, function(a, b) {
    return (typeof a === "string" || typeof b === "string") && d3.interpolateString(a + "", b + "");
  }, function(a, b) {
    return (typeof b === "string" ? d3_rgb_names.has(b) || /^(#|rgb\(|hsl\()/.test(b) : b instanceof d3_Color) && d3.interpolateRgb(a, b);
  }, function(a, b) {
    return !isNaN(a = +a) && !isNaN(b = +b) && d3.interpolateNumber(a, b);
  } ];
  d3_Color.prototype.toString = function() {
    return this.rgb() + "";
  };
  d3.rgb = function(r, g, b) {
    return arguments.length === 1 ? r instanceof d3_Rgb ? d3_rgb(r.r, r.g, r.b) : d3_rgb_parse("" + r, d3_rgb, d3_hsl_rgb) : d3_rgb(~~r, ~~g, ~~b);
  };
  var d3_rgbPrototype = d3_Rgb.prototype = new d3_Color;
  d3_rgbPrototype.brighter = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    var r = this.r, g = this.g, b = this.b, i = 30;
    if (!r && !g && !b) return d3_rgb(i, i, i);
    if (r && r < i) r = i;
    if (g && g < i) g = i;
    if (b && b < i) b = i;
    return d3_rgb(Math.min(255, Math.floor(r / k)), Math.min(255, Math.floor(g / k)), Math.min(255, Math.floor(b / k)));
  };
  d3_rgbPrototype.darker = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return d3_rgb(Math.floor(k * this.r), Math.floor(k * this.g), Math.floor(k * this.b));
  };
  d3_rgbPrototype.hsl = function() {
    return d3_rgb_hsl(this.r, this.g, this.b);
  };
  d3_rgbPrototype.toString = function() {
    return "#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);
  };
  var d3_rgb_names = d3.map({
    aliceblue: "#f0f8ff",
    antiquewhite: "#faebd7",
    aqua: "#00ffff",
    aquamarine: "#7fffd4",
    azure: "#f0ffff",
    beige: "#f5f5dc",
    bisque: "#ffe4c4",
    black: "#000000",
    blanchedalmond: "#ffebcd",
    blue: "#0000ff",
    blueviolet: "#8a2be2",
    brown: "#a52a2a",
    burlywood: "#deb887",
    cadetblue: "#5f9ea0",
    chartreuse: "#7fff00",
    chocolate: "#d2691e",
    coral: "#ff7f50",
    cornflowerblue: "#6495ed",
    cornsilk: "#fff8dc",
    crimson: "#dc143c",
    cyan: "#00ffff",
    darkblue: "#00008b",
    darkcyan: "#008b8b",
    darkgoldenrod: "#b8860b",
    darkgray: "#a9a9a9",
    darkgreen: "#006400",
    darkgrey: "#a9a9a9",
    darkkhaki: "#bdb76b",
    darkmagenta: "#8b008b",
    darkolivegreen: "#556b2f",
    darkorange: "#ff8c00",
    darkorchid: "#9932cc",
    darkred: "#8b0000",
    darksalmon: "#e9967a",
    darkseagreen: "#8fbc8f",
    darkslateblue: "#483d8b",
    darkslategray: "#2f4f4f",
    darkslategrey: "#2f4f4f",
    darkturquoise: "#00ced1",
    darkviolet: "#9400d3",
    deeppink: "#ff1493",
    deepskyblue: "#00bfff",
    dimgray: "#696969",
    dimgrey: "#696969",
    dodgerblue: "#1e90ff",
    firebrick: "#b22222",
    floralwhite: "#fffaf0",
    forestgreen: "#228b22",
    fuchsia: "#ff00ff",
    gainsboro: "#dcdcdc",
    ghostwhite: "#f8f8ff",
    gold: "#ffd700",
    goldenrod: "#daa520",
    gray: "#808080",
    green: "#008000",
    greenyellow: "#adff2f",
    grey: "#808080",
    honeydew: "#f0fff0",
    hotpink: "#ff69b4",
    indianred: "#cd5c5c",
    indigo: "#4b0082",
    ivory: "#fffff0",
    khaki: "#f0e68c",
    lavender: "#e6e6fa",
    lavenderblush: "#fff0f5",
    lawngreen: "#7cfc00",
    lemonchiffon: "#fffacd",
    lightblue: "#add8e6",
    lightcoral: "#f08080",
    lightcyan: "#e0ffff",
    lightgoldenrodyellow: "#fafad2",
    lightgray: "#d3d3d3",
    lightgreen: "#90ee90",
    lightgrey: "#d3d3d3",
    lightpink: "#ffb6c1",
    lightsalmon: "#ffa07a",
    lightseagreen: "#20b2aa",
    lightskyblue: "#87cefa",
    lightslategray: "#778899",
    lightslategrey: "#778899",
    lightsteelblue: "#b0c4de",
    lightyellow: "#ffffe0",
    lime: "#00ff00",
    limegreen: "#32cd32",
    linen: "#faf0e6",
    magenta: "#ff00ff",
    maroon: "#800000",
    mediumaquamarine: "#66cdaa",
    mediumblue: "#0000cd",
    mediumorchid: "#ba55d3",
    mediumpurple: "#9370db",
    mediumseagreen: "#3cb371",
    mediumslateblue: "#7b68ee",
    mediumspringgreen: "#00fa9a",
    mediumturquoise: "#48d1cc",
    mediumvioletred: "#c71585",
    midnightblue: "#191970",
    mintcream: "#f5fffa",
    mistyrose: "#ffe4e1",
    moccasin: "#ffe4b5",
    navajowhite: "#ffdead",
    navy: "#000080",
    oldlace: "#fdf5e6",
    olive: "#808000",
    olivedrab: "#6b8e23",
    orange: "#ffa500",
    orangered: "#ff4500",
    orchid: "#da70d6",
    palegoldenrod: "#eee8aa",
    palegreen: "#98fb98",
    paleturquoise: "#afeeee",
    palevioletred: "#db7093",
    papayawhip: "#ffefd5",
    peachpuff: "#ffdab9",
    peru: "#cd853f",
    pink: "#ffc0cb",
    plum: "#dda0dd",
    powderblue: "#b0e0e6",
    purple: "#800080",
    red: "#ff0000",
    rosybrown: "#bc8f8f",
    royalblue: "#4169e1",
    saddlebrown: "#8b4513",
    salmon: "#fa8072",
    sandybrown: "#f4a460",
    seagreen: "#2e8b57",
    seashell: "#fff5ee",
    sienna: "#a0522d",
    silver: "#c0c0c0",
    skyblue: "#87ceeb",
    slateblue: "#6a5acd",
    slategray: "#708090",
    slategrey: "#708090",
    snow: "#fffafa",
    springgreen: "#00ff7f",
    steelblue: "#4682b4",
    tan: "#d2b48c",
    teal: "#008080",
    thistle: "#d8bfd8",
    tomato: "#ff6347",
    turquoise: "#40e0d0",
    violet: "#ee82ee",
    wheat: "#f5deb3",
    white: "#ffffff",
    whitesmoke: "#f5f5f5",
    yellow: "#ffff00",
    yellowgreen: "#9acd32"
  });
  d3_rgb_names.forEach(function(key, value) {
    d3_rgb_names.set(key, d3_rgb_parse(value, d3_rgb, d3_hsl_rgb));
  });
  d3.hsl = function(h, s, l) {
    return arguments.length === 1 ? h instanceof d3_Hsl ? d3_hsl(h.h, h.s, h.l) : d3_rgb_parse("" + h, d3_rgb_hsl, d3_hsl) : d3_hsl(+h, +s, +l);
  };
  var d3_hslPrototype = d3_Hsl.prototype = new d3_Color;
  d3_hslPrototype.brighter = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return d3_hsl(this.h, this.s, this.l / k);
  };
  d3_hslPrototype.darker = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return d3_hsl(this.h, this.s, k * this.l);
  };
  d3_hslPrototype.rgb = function() {
    return d3_hsl_rgb(this.h, this.s, this.l);
  };
  d3.hcl = function(h, c, l) {
    return arguments.length === 1 ? h instanceof d3_Hcl ? d3_hcl(h.h, h.c, h.l) : h instanceof d3_Lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : d3_hcl(+h, +c, +l);
  };
  var d3_hclPrototype = d3_Hcl.prototype = new d3_Color;
  d3_hclPrototype.brighter = function(k) {
    return d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));
  };
  d3_hclPrototype.darker = function(k) {
    return d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));
  };
  d3_hclPrototype.rgb = function() {
    return d3_hcl_lab(this.h, this.c, this.l).rgb();
  };
  d3.lab = function(l, a, b) {
    return arguments.length === 1 ? l instanceof d3_Lab ? d3_lab(l.l, l.a, l.b) : l instanceof d3_Hcl ? d3_hcl_lab(l.l, l.c, l.h) : d3_rgb_lab((l = d3.rgb(l)).r, l.g, l.b) : d3_lab(+l, +a, +b);
  };
  var d3_lab_K = 18;
  var d3_lab_X = .95047, d3_lab_Y = 1, d3_lab_Z = 1.08883;
  var d3_labPrototype = d3_Lab.prototype = new d3_Color;
  d3_labPrototype.brighter = function(k) {
    return d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
  };
  d3_labPrototype.darker = function(k) {
    return d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
  };
  d3_labPrototype.rgb = function() {
    return d3_lab_rgb(this.l, this.a, this.b);
  };
  var d3_select = function(s, n) {
    return n.querySelector(s);
  }, d3_selectAll = function(s, n) {
    return n.querySelectorAll(s);
  }, d3_selectRoot = document.documentElement, d3_selectMatcher = d3_selectRoot.matchesSelector || d3_selectRoot.webkitMatchesSelector || d3_selectRoot.mozMatchesSelector || d3_selectRoot.msMatchesSelector || d3_selectRoot.oMatchesSelector, d3_selectMatches = function(n, s) {
    return d3_selectMatcher.call(n, s);
  };
  if (typeof Sizzle === "function") {
    d3_select = function(s, n) {
      return Sizzle(s, n)[0] || null;
    };
    d3_selectAll = function(s, n) {
      return Sizzle.uniqueSort(Sizzle(s, n));
    };
    d3_selectMatches = Sizzle.matchesSelector;
  }
  var d3_selectionPrototype = [];
  d3.selection = function() {
    return d3_selectionRoot;
  };
  d3.selection.prototype = d3_selectionPrototype;
  d3_selectionPrototype.select = function(selector) {
    var subgroups = [], subgroup, subnode, group, node;
    if (typeof selector !== "function") selector = d3_selection_selector(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      subgroup.parentNode = (group = this[j]).parentNode;
      for (var i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroup.push(subnode = selector.call(node, node.__data__, i));
          if (subnode && "__data__" in node) subnode.__data__ = node.__data__;
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_selection(subgroups);
  };
  d3_selectionPrototype.selectAll = function(selector) {
    var subgroups = [], subgroup, node;
    if (typeof selector !== "function") selector = d3_selection_selectorAll(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i)));
          subgroup.parentNode = node;
        }
      }
    }
    return d3_selection(subgroups);
  };
  d3_selectionPrototype.attr = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") {
        var node = this.node();
        name = d3.ns.qualify(name);
        return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);
      }
      for (value in name) this.each(d3_selection_attr(value, name[value]));
      return this;
    }
    return this.each(d3_selection_attr(name, value));
  };
  d3_selectionPrototype.classed = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") {
        var node = this.node(), n = (name = name.trim().split(/^|\s+/g)).length, i = -1;
        if (value = node.classList) {
          while (++i < n) if (!value.contains(name[i])) return false;
        } else {
          value = node.className;
          if (value.baseVal != null) value = value.baseVal;
          while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;
        }
        return true;
      }
      for (value in name) this.each(d3_selection_classed(value, name[value]));
      return this;
    }
    return this.each(d3_selection_classed(name, value));
  };
  d3_selectionPrototype.style = function(name, value, priority) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof name !== "string") {
        if (n < 2) value = "";
        for (priority in name) this.each(d3_selection_style(priority, name[priority], value));
        return this;
      }
      if (n < 2) return window.getComputedStyle(this.node(), null).getPropertyValue(name);
      priority = "";
    }
    return this.each(d3_selection_style(name, value, priority));
  };
  d3_selectionPrototype.property = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") return this.node()[name];
      for (value in name) this.each(d3_selection_property(value, name[value]));
      return this;
    }
    return this.each(d3_selection_property(name, value));
  };
  d3_selectionPrototype.text = function(value) {
    return arguments.length < 1 ? this.node().textContent : this.each(typeof value === "function" ? function() {
      var v = value.apply(this, arguments);
      this.textContent = v == null ? "" : v;
    } : value == null ? function() {
      this.textContent = "";
    } : function() {
      this.textContent = value;
    });
  };
  d3_selectionPrototype.html = function(value) {
    return arguments.length < 1 ? this.node().innerHTML : this.each(typeof value === "function" ? function() {
      var v = value.apply(this, arguments);
      this.innerHTML = v == null ? "" : v;
    } : value == null ? function() {
      this.innerHTML = "";
    } : function() {
      this.innerHTML = value;
    });
  };
  d3_selectionPrototype.append = function(name) {
    function append() {
      return this.appendChild(document.createElementNS(this.namespaceURI, name));
    }
    function appendNS() {
      return this.appendChild(document.createElementNS(name.space, name.local));
    }
    name = d3.ns.qualify(name);
    return this.select(name.local ? appendNS : append);
  };
  d3_selectionPrototype.insert = function(name, before) {
    function insert() {
      return this.insertBefore(document.createElementNS(this.namespaceURI, name), d3_select(before, this));
    }
    function insertNS() {
      return this.insertBefore(document.createElementNS(name.space, name.local), d3_select(before, this));
    }
    name = d3.ns.qualify(name);
    return this.select(name.local ? insertNS : insert);
  };
  d3_selectionPrototype.remove = function() {
    return this.each(function() {
      var parent = this.parentNode;
      if (parent) parent.removeChild(this);
    });
  };
  d3_selectionPrototype.data = function(value, key) {
    function bind(group, groupData) {
      var i, n = group.length, m = groupData.length, n0 = Math.min(n, m), n1 = Math.max(n, m), updateNodes = [], enterNodes = [], exitNodes = [], node, nodeData;
      if (key) {
        var nodeByKeyValue = new d3_Map, keyValues = [], keyValue, j = groupData.length;
        for (i = -1; ++i < n; ) {
          keyValue = key.call(node = group[i], node.__data__, i);
          if (nodeByKeyValue.has(keyValue)) {
            exitNodes[j++] = node;
          } else {
            nodeByKeyValue.set(keyValue, node);
          }
          keyValues.push(keyValue);
        }
        for (i = -1; ++i < m; ) {
          keyValue = key.call(groupData, nodeData = groupData[i], i);
          if (nodeByKeyValue.has(keyValue)) {
            updateNodes[i] = node = nodeByKeyValue.get(keyValue);
            node.__data__ = nodeData;
            enterNodes[i] = exitNodes[i] = null;
          } else {
            enterNodes[i] = d3_selection_dataNode(nodeData);
            updateNodes[i] = exitNodes[i] = null;
          }
          nodeByKeyValue.remove(keyValue);
        }
        for (i = -1; ++i < n; ) {
          if (nodeByKeyValue.has(keyValues[i])) {
            exitNodes[i] = group[i];
          }
        }
      } else {
        for (i = -1; ++i < n0; ) {
          node = group[i];
          nodeData = groupData[i];
          if (node) {
            node.__data__ = nodeData;
            updateNodes[i] = node;
            enterNodes[i] = exitNodes[i] = null;
          } else {
            enterNodes[i] = d3_selection_dataNode(nodeData);
            updateNodes[i] = exitNodes[i] = null;
          }
        }
        for (; i < m; ++i) {
          enterNodes[i] = d3_selection_dataNode(groupData[i]);
          updateNodes[i] = exitNodes[i] = null;
        }
        for (; i < n1; ++i) {
          exitNodes[i] = group[i];
          enterNodes[i] = updateNodes[i] = null;
        }
      }
      enterNodes.update = updateNodes;
      enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;
      enter.push(enterNodes);
      update.push(updateNodes);
      exit.push(exitNodes);
    }
    var i = -1, n = this.length, group, node;
    if (!arguments.length) {
      value = new Array(n = (group = this[0]).length);
      while (++i < n) {
        if (node = group[i]) {
          value[i] = node.__data__;
        }
      }
      return value;
    }
    var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]);
    if (typeof value === "function") {
      while (++i < n) {
        bind(group = this[i], value.call(group, group.parentNode.__data__, i));
      }
    } else {
      while (++i < n) {
        bind(group = this[i], value);
      }
    }
    update.enter = function() {
      return enter;
    };
    update.exit = function() {
      return exit;
    };
    return update;
  };
  d3_selectionPrototype.datum = d3_selectionPrototype.map = function(value) {
    return arguments.length < 1 ? this.property("__data__") : this.property("__data__", value);
  };
  d3_selectionPrototype.filter = function(filter) {
    var subgroups = [], subgroup, group, node;
    if (typeof filter !== "function") filter = d3_selection_filter(filter);
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      subgroup.parentNode = (group = this[j]).parentNode;
      for (var i = 0, n = group.length; i < n; i++) {
        if ((node = group[i]) && filter.call(node, node.__data__, i)) {
          subgroup.push(node);
        }
      }
    }
    return d3_selection(subgroups);
  };
  d3_selectionPrototype.order = function() {
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
        if (node = group[i]) {
          if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
          next = node;
        }
      }
    }
    return this;
  };
  d3_selectionPrototype.sort = function(comparator) {
    comparator = d3_selection_sortComparator.apply(this, arguments);
    for (var j = -1, m = this.length; ++j < m; ) this[j].sort(comparator);
    return this.order();
  };
  d3_selectionPrototype.on = function(type, listener, capture) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof type !== "string") {
        if (n < 2) listener = false;
        for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));
        return this;
      }
      if (n < 2) return (n = this.node()["__on" + type]) && n._;
      capture = false;
    }
    return this.each(d3_selection_on(type, listener, capture));
  };
  d3_selectionPrototype.each = function(callback) {
    return d3_selection_each(this, function(node, i, j) {
      callback.call(node, node.__data__, i, j);
    });
  };
  d3_selectionPrototype.call = function(callback) {
    callback.apply(this, (arguments[0] = this, arguments));
    return this;
  };
  d3_selectionPrototype.empty = function() {
    return !this.node();
  };
  d3_selectionPrototype.node = function(callback) {
    for (var j = 0, m = this.length; j < m; j++) {
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        var node = group[i];
        if (node) return node;
      }
    }
    return null;
  };
  d3_selectionPrototype.transition = function() {
    var subgroups = [], subgroup, node;
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        subgroup.push((node = group[i]) ? {
          node: node,
          delay: d3_transitionDelay,
          duration: d3_transitionDuration
        } : null);
      }
    }
    return d3_transition(subgroups, d3_transitionId || ++d3_transitionNextId, Date.now());
  };
  var d3_selectionRoot = d3_selection([ [ document ] ]);
  d3_selectionRoot[0].parentNode = d3_selectRoot;
  d3.select = function(selector) {
    return typeof selector === "string" ? d3_selectionRoot.select(selector) : d3_selection([ [ selector ] ]);
  };
  d3.selectAll = function(selector) {
    return typeof selector === "string" ? d3_selectionRoot.selectAll(selector) : d3_selection([ d3_array(selector) ]);
  };
  var d3_selection_enterPrototype = [];
  d3.selection.enter = d3_selection_enter;
  d3.selection.enter.prototype = d3_selection_enterPrototype;
  d3_selection_enterPrototype.append = d3_selectionPrototype.append;
  d3_selection_enterPrototype.insert = d3_selectionPrototype.insert;
  d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
  d3_selection_enterPrototype.node = d3_selectionPrototype.node;
  d3_selection_enterPrototype.select = function(selector) {
    var subgroups = [], subgroup, subnode, upgroup, group, node;
    for (var j = -1, m = this.length; ++j < m; ) {
      upgroup = (group = this[j]).update;
      subgroups.push(subgroup = []);
      subgroup.parentNode = group.parentNode;
      for (var i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i));
          subnode.__data__ = node.__data__;
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_selection(subgroups);
  };
  var d3_transitionPrototype = [], d3_transitionNextId = 0, d3_transitionId = 0, d3_transitionDefaultDelay = 0, d3_transitionDefaultDuration = 250, d3_transitionDefaultEase = d3.ease("cubic-in-out"), d3_transitionDelay = d3_transitionDefaultDelay, d3_transitionDuration = d3_transitionDefaultDuration, d3_transitionEase = d3_transitionDefaultEase;
  d3_transitionPrototype.call = d3_selectionPrototype.call;
  d3.transition = function(selection) {
    return arguments.length ? d3_transitionId ? selection.transition() : selection : d3_selectionRoot.transition();
  };
  d3.transition.prototype = d3_transitionPrototype;
  d3_transitionPrototype.select = function(selector) {
    var subgroups = [], subgroup, subnode, node;
    if (typeof selector !== "function") selector = d3_selection_selector(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if ((node = group[i]) && (subnode = selector.call(node.node, node.node.__data__, i))) {
          if ("__data__" in node.node) subnode.__data__ = node.node.__data__;
          subgroup.push({
            node: subnode,
            delay: node.delay,
            duration: node.duration
          });
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_transition(subgroups, this.id, this.time).ease(this.ease());
  };
  d3_transitionPrototype.selectAll = function(selector) {
    var subgroups = [], subgroup, subnodes, node;
    if (typeof selector !== "function") selector = d3_selection_selectorAll(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subnodes = selector.call(node.node, node.node.__data__, i);
          subgroups.push(subgroup = []);
          for (var k = -1, o = subnodes.length; ++k < o; ) {
            subgroup.push({
              node: subnodes[k],
              delay: node.delay,
              duration: node.duration
            });
          }
        }
      }
    }
    return d3_transition(subgroups, this.id, this.time).ease(this.ease());
  };
  d3_transitionPrototype.filter = function(filter) {
    var subgroups = [], subgroup, group, node;
    if (typeof filter !== "function") filter = d3_selection_filter(filter);
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        if ((node = group[i]) && filter.call(node.node, node.node.__data__, i)) {
          subgroup.push(node);
        }
      }
    }
    return d3_transition(subgroups, this.id, this.time).ease(this.ease());
  };
  d3_transitionPrototype.attr = function(name, value) {
    if (arguments.length < 2) {
      for (value in name) this.attrTween(value, d3_tweenByName(name[value], value));
      return this;
    }
    return this.attrTween(name, d3_tweenByName(value, name));
  };
  d3_transitionPrototype.attrTween = function(nameNS, tween) {
    function attrTween(d, i) {
      var f = tween.call(this, d, i, this.getAttribute(name));
      return f === d3_tweenRemove ? (this.removeAttribute(name), null) : f && function(t) {
        this.setAttribute(name, f(t));
      };
    }
    function attrTweenNS(d, i) {
      var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
      return f === d3_tweenRemove ? (this.removeAttributeNS(name.space, name.local), null) : f && function(t) {
        this.setAttributeNS(name.space, name.local, f(t));
      };
    }
    var name = d3.ns.qualify(nameNS);
    return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween);
  };
  d3_transitionPrototype.style = function(name, value, priority) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof name !== "string") {
        if (n < 2) value = "";
        for (priority in name) this.styleTween(priority, d3_tweenByName(name[priority], priority), value);
        return this;
      }
      priority = "";
    }
    return this.styleTween(name, d3_tweenByName(value, name), priority);
  };
  d3_transitionPrototype.styleTween = function(name, tween, priority) {
    if (arguments.length < 3) priority = "";
    return this.tween("style." + name, function(d, i) {
      var f = tween.call(this, d, i, window.getComputedStyle(this, null).getPropertyValue(name));
      return f === d3_tweenRemove ? (this.style.removeProperty(name), null) : f && function(t) {
        this.style.setProperty(name, f(t), priority);
      };
    });
  };
  d3_transitionPrototype.text = function(value) {
    return this.tween("text", function(d, i) {
      this.textContent = typeof value === "function" ? value.call(this, d, i) : value;
    });
  };
  d3_transitionPrototype.remove = function() {
    return this.each("end.transition", function() {
      var p;
      if (!this.__transition__ && (p = this.parentNode)) p.removeChild(this);
    });
  };
  d3_transitionPrototype.delay = function(value) {
    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
      node.delay = value.call(node = node.node, node.__data__, i, j) | 0;
    } : (value = value | 0, function(node) {
      node.delay = value;
    }));
  };
  d3_transitionPrototype.duration = function(value) {
    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
      node.duration = Math.max(1, value.call(node = node.node, node.__data__, i, j) | 0);
    } : (value = Math.max(1, value | 0), function(node) {
      node.duration = value;
    }));
  };
  d3_transitionPrototype.transition = function() {
    return this.select(d3_this);
  };
  d3.tween = function(b, interpolate) {
    function tweenFunction(d, i, a) {
      var v = b.call(this, d, i);
      return v == null ? a != "" && d3_tweenRemove : a != v && interpolate(a, v + "");
    }
    function tweenString(d, i, a) {
      return a != b && interpolate(a, b);
    }
    return typeof b === "function" ? tweenFunction : b == null ? d3_tweenNull : (b += "", tweenString);
  };
  var d3_tweenRemove = {};
  var d3_timer_id = 0, d3_timer_byId = {}, d3_timer_queue = null, d3_timer_interval, d3_timer_timeout;
  d3.timer = function(callback, delay, then) {
    if (arguments.length < 3) {
      if (arguments.length < 2) delay = 0; else if (!isFinite(delay)) return;
      then = Date.now();
    }
    var timer = d3_timer_byId[callback.id];
    if (timer && timer.callback === callback) {
      timer.then = then;
      timer.delay = delay;
    } else d3_timer_byId[callback.id = ++d3_timer_id] = d3_timer_queue = {
      callback: callback,
      then: then,
      delay: delay,
      next: d3_timer_queue
    };
    if (!d3_timer_interval) {
      d3_timer_timeout = clearTimeout(d3_timer_timeout);
      d3_timer_interval = 1;
      d3_timer_frame(d3_timer_step);
    }
  };
  d3.timer.flush = function() {
    var elapsed, now = Date.now(), t1 = d3_timer_queue;
    while (t1) {
      elapsed = now - t1.then;
      if (!t1.delay) t1.flush = t1.callback(elapsed);
      t1 = t1.next;
    }
    d3_timer_flush();
  };
  var d3_timer_frame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {
    setTimeout(callback, 17);
  };
  d3.mouse = function(container) {
    return d3_mousePoint(container, d3_eventSource());
  };
  var d3_mouse_bug44083 = /WebKit/.test(navigator.userAgent) ? -1 : 0;
  d3.touches = function(container, touches) {
    if (arguments.length < 2) touches = d3_eventSource().touches;
    return touches ? d3_array(touches).map(function(touch) {
      var point = d3_mousePoint(container, touch);
      point.identifier = touch.identifier;
      return point;
    }) : [];
  };
  d3.scale = {};
  d3.scale.linear = function() {
    return d3_scale_linear([ 0, 1 ], [ 0, 1 ], d3.interpolate, false);
  };
  d3.scale.log = function() {
    return d3_scale_log(d3.scale.linear(), d3_scale_logp);
  };
  var d3_scale_logFormat = d3.format(".0e");
  d3_scale_logp.pow = function(x) {
    return Math.pow(10, x);
  };
  d3_scale_logn.pow = function(x) {
    return -Math.pow(10, -x);
  };
  d3.scale.pow = function() {
    return d3_scale_pow(d3.scale.linear(), 1);
  };
  d3.scale.sqrt = function() {
    return d3.scale.pow().exponent(.5);
  };
  d3.scale.ordinal = function() {
    return d3_scale_ordinal([], {
      t: "range",
      a: [ [] ]
    });
  };
  d3.scale.category10 = function() {
    return d3.scale.ordinal().range(d3_category10);
  };
  d3.scale.category20 = function() {
    return d3.scale.ordinal().range(d3_category20);
  };
  d3.scale.category20b = function() {
    return d3.scale.ordinal().range(d3_category20b);
  };
  d3.scale.category20c = function() {
    return d3.scale.ordinal().range(d3_category20c);
  };
  var d3_category10 = [ "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf" ];
  var d3_category20 = [ "#1f77b4", "#aec7e8", "#ff7f0e", "#ffbb78", "#2ca02c", "#98df8a", "#d62728", "#ff9896", "#9467bd", "#c5b0d5", "#8c564b", "#c49c94", "#e377c2", "#f7b6d2", "#7f7f7f", "#c7c7c7", "#bcbd22", "#dbdb8d", "#17becf", "#9edae5" ];
  var d3_category20b = [ "#393b79", "#5254a3", "#6b6ecf", "#9c9ede", "#637939", "#8ca252", "#b5cf6b", "#cedb9c", "#8c6d31", "#bd9e39", "#e7ba52", "#e7cb94", "#843c39", "#ad494a", "#d6616b", "#e7969c", "#7b4173", "#a55194", "#ce6dbd", "#de9ed6" ];
  var d3_category20c = [ "#3182bd", "#6baed6", "#9ecae1", "#c6dbef", "#e6550d", "#fd8d3c", "#fdae6b", "#fdd0a2", "#31a354", "#74c476", "#a1d99b", "#c7e9c0", "#756bb1", "#9e9ac8", "#bcbddc", "#dadaeb", "#636363", "#969696", "#bdbdbd", "#d9d9d9" ];
  d3.scale.quantile = function() {
    return d3_scale_quantile([], []);
  };
  d3.scale.quantize = function() {
    return d3_scale_quantize(0, 1, [ 0, 1 ]);
  };
  d3.scale.threshold = function() {
    return d3_scale_threshold([ .5 ], [ 0, 1 ]);
  };
  d3.scale.identity = function() {
    return d3_scale_identity([ 0, 1 ]);
  };
  d3.svg = {};
  d3.svg.arc = function() {
    function arc() {
      var r0 = innerRadius.apply(this, arguments), r1 = outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) + d3_svg_arcOffset, a1 = endAngle.apply(this, arguments) + d3_svg_arcOffset, da = (a1 < a0 && (da = a0, a0 = a1, a1 = da), a1 - a0), df = da < Math.PI ? "0" : "1", c0 = Math.cos(a0), s0 = Math.sin(a0), c1 = Math.cos(a1), s1 = Math.sin(a1);
      return da >= d3_svg_arcMax ? r0 ? "M0," + r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + -r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + r1 + "M0," + r0 + "A" + r0 + "," + r0 + " 0 1,0 0," + -r0 + "A" + r0 + "," + r0 + " 0 1,0 0," + r0 + "Z" : "M0," + r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + -r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + r1 + "Z" : r0 ? "M" + r1 * c0 + "," + r1 * s0 + "A" + r1 + "," + r1 + " 0 " + df + ",1 " + r1 * c1 + "," + r1 * s1 + "L" + r0 * c1 + "," + r0 * s1 + "A" + r0 + "," + r0 + " 0 " + df + ",0 " + r0 * c0 + "," + r0 * s0 + "Z" : "M" + r1 * c0 + "," + r1 * s0 + "A" + r1 + "," + r1 + " 0 " + df + ",1 " + r1 * c1 + "," + r1 * s1 + "L0,0" + "Z";
    }
    var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
    arc.innerRadius = function(v) {
      if (!arguments.length) return innerRadius;
      innerRadius = d3_functor(v);
      return arc;
    };
    arc.outerRadius = function(v) {
      if (!arguments.length) return outerRadius;
      outerRadius = d3_functor(v);
      return arc;
    };
    arc.startAngle = function(v) {
      if (!arguments.length) return startAngle;
      startAngle = d3_functor(v);
      return arc;
    };
    arc.endAngle = function(v) {
      if (!arguments.length) return endAngle;
      endAngle = d3_functor(v);
      return arc;
    };
    arc.centroid = function() {
      var r = (innerRadius.apply(this, arguments) + outerRadius.apply(this, arguments)) / 2, a = (startAngle.apply(this, arguments) + endAngle.apply(this, arguments)) / 2 + d3_svg_arcOffset;
      return [ Math.cos(a) * r, Math.sin(a) * r ];
    };
    return arc;
  };
  var d3_svg_arcOffset = -Math.PI / 2, d3_svg_arcMax = 2 * Math.PI - 1e-6;
  d3.svg.line = function() {
    return d3_svg_line(d3_identity);
  };
  var d3_svg_lineInterpolators = d3.map({
    linear: d3_svg_lineLinear,
    "linear-closed": d3_svg_lineLinearClosed,
    "step-before": d3_svg_lineStepBefore,
    "step-after": d3_svg_lineStepAfter,
    basis: d3_svg_lineBasis,
    "basis-open": d3_svg_lineBasisOpen,
    "basis-closed": d3_svg_lineBasisClosed,
    bundle: d3_svg_lineBundle,
    cardinal: d3_svg_lineCardinal,
    "cardinal-open": d3_svg_lineCardinalOpen,
    "cardinal-closed": d3_svg_lineCardinalClosed,
    monotone: d3_svg_lineMonotone
  });
  d3_svg_lineInterpolators.forEach(function(key, value) {
    value.key = key;
    value.closed = /-closed$/.test(key);
  });
  var d3_svg_lineBasisBezier1 = [ 0, 2 / 3, 1 / 3, 0 ], d3_svg_lineBasisBezier2 = [ 0, 1 / 3, 2 / 3, 0 ], d3_svg_lineBasisBezier3 = [ 0, 1 / 6, 2 / 3, 1 / 6 ];
  d3.svg.line.radial = function() {
    var line = d3_svg_line(d3_svg_lineRadial);
    line.radius = line.x, delete line.x;
    line.angle = line.y, delete line.y;
    return line;
  };
  d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
  d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;
  d3.svg.area = function() {
    return d3_svg_area(d3_identity);
  };
  d3.svg.area.radial = function() {
    var area = d3_svg_area(d3_svg_lineRadial);
    area.radius = area.x, delete area.x;
    area.innerRadius = area.x0, delete area.x0;
    area.outerRadius = area.x1, delete area.x1;
    area.angle = area.y, delete area.y;
    area.startAngle = area.y0, delete area.y0;
    area.endAngle = area.y1, delete area.y1;
    return area;
  };
  d3.svg.chord = function() {
    function chord(d, i) {
      var s = subgroup(this, source, d, i), t = subgroup(this, target, d, i);
      return "M" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + "Z";
    }
    function subgroup(self, f, d, i) {
      var subgroup = f.call(self, d, i), r = radius.call(self, subgroup, i), a0 = startAngle.call(self, subgroup, i) + d3_svg_arcOffset, a1 = endAngle.call(self, subgroup, i) + d3_svg_arcOffset;
      return {
        r: r,
        a0: a0,
        a1: a1,
        p0: [ r * Math.cos(a0), r * Math.sin(a0) ],
        p1: [ r * Math.cos(a1), r * Math.sin(a1) ]
      };
    }
    function equals(a, b) {
      return a.a0 == b.a0 && a.a1 == b.a1;
    }
    function arc(r, p, a) {
      return "A" + r + "," + r + " 0 " + +(a > Math.PI) + ",1 " + p;
    }
    function curve(r0, p0, r1, p1) {
      return "Q 0,0 " + p1;
    }
    var source = d3_svg_chordSource, target = d3_svg_chordTarget, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
    chord.radius = function(v) {
      if (!arguments.length) return radius;
      radius = d3_functor(v);
      return chord;
    };
    chord.source = function(v) {
      if (!arguments.length) return source;
      source = d3_functor(v);
      return chord;
    };
    chord.target = function(v) {
      if (!arguments.length) return target;
      target = d3_functor(v);
      return chord;
    };
    chord.startAngle = function(v) {
      if (!arguments.length) return startAngle;
      startAngle = d3_functor(v);
      return chord;
    };
    chord.endAngle = function(v) {
      if (!arguments.length) return endAngle;
      endAngle = d3_functor(v);
      return chord;
    };
    return chord;
  };
  d3.svg.diagonal = function() {
    function diagonal(d, i) {
      var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [ p0, {
        x: p0.x,
        y: m
      }, {
        x: p3.x,
        y: m
      }, p3 ];
      p = p.map(projection);
      return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3];
    }
    var source = d3_svg_chordSource, target = d3_svg_chordTarget, projection = d3_svg_diagonalProjection;
    diagonal.source = function(x) {
      if (!arguments.length) return source;
      source = d3_functor(x);
      return diagonal;
    };
    diagonal.target = function(x) {
      if (!arguments.length) return target;
      target = d3_functor(x);
      return diagonal;
    };
    diagonal.projection = function(x) {
      if (!arguments.length) return projection;
      projection = x;
      return diagonal;
    };
    return diagonal;
  };
  d3.svg.diagonal.radial = function() {
    var diagonal = d3.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection;
    diagonal.projection = function(x) {
      return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;
    };
    return diagonal;
  };
  d3.svg.mouse = d3.mouse;
  d3.svg.touches = d3.touches;
  d3.svg.symbol = function() {
    function symbol(d, i) {
      return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));
    }
    var type = d3_svg_symbolType, size = d3_svg_symbolSize;
    symbol.type = function(x) {
      if (!arguments.length) return type;
      type = d3_functor(x);
      return symbol;
    };
    symbol.size = function(x) {
      if (!arguments.length) return size;
      size = d3_functor(x);
      return symbol;
    };
    return symbol;
  };
  var d3_svg_symbols = d3.map({
    circle: d3_svg_symbolCircle,
    cross: function(size) {
      var r = Math.sqrt(size / 5) / 2;
      return "M" + -3 * r + "," + -r + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z";
    },
    diamond: function(size) {
      var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)), rx = ry * d3_svg_symbolTan30;
      return "M0," + -ry + "L" + rx + ",0" + " 0," + ry + " " + -rx + ",0" + "Z";
    },
    square: function(size) {
      var r = Math.sqrt(size) / 2;
      return "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
    },
    "triangle-down": function(size) {
      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
      return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
    },
    "triangle-up": function(size) {
      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
      return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
    }
  });
  d3.svg.symbolTypes = d3_svg_symbols.keys();
  var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 * Math.PI / 180);
  d3.svg.axis = function() {
    function axis(g) {
      g.each(function() {
        var g = d3.select(this);
        var ticks = tickValues == null ? scale.ticks ? scale.ticks.apply(scale, tickArguments_) : scale.domain() : tickValues, tickFormat = tickFormat_ == null ? scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments_) : String : tickFormat_;
        var subticks = d3_svg_axisSubdivide(scale, ticks, tickSubdivide), subtick = g.selectAll(".minor").data(subticks, String), subtickEnter = subtick.enter().insert("line", "g").attr("class", "tick minor").style("opacity", 1e-6), subtickExit = d3.transition(subtick.exit()).style("opacity", 1e-6).remove(), subtickUpdate = d3.transition(subtick).style("opacity", 1);
        var tick = g.selectAll("g").data(ticks, String), tickEnter = tick.enter().insert("g", "path").style("opacity", 1e-6), tickExit = d3.transition(tick.exit()).style("opacity", 1e-6).remove(), tickUpdate = d3.transition(tick).style("opacity", 1), tickTransform;
        var range = d3_scaleRange(scale), path = g.selectAll(".domain").data([ 0 ]), pathEnter = path.enter().append("path").attr("class", "domain"), pathUpdate = d3.transition(path);
        var scale1 = scale.copy(), scale0 = this.__chart__ || scale1;
        this.__chart__ = scale1;
        tickEnter.append("line").attr("class", "tick");
        tickEnter.append("text");
        var lineEnter = tickEnter.select("line"), lineUpdate = tickUpdate.select("line"), text = tick.select("text").text(tickFormat), textEnter = tickEnter.select("text"), textUpdate = tickUpdate.select("text");
        switch (orient) {
         case "bottom":
          {
            tickTransform = d3_svg_axisX;
            subtickEnter.attr("y2", tickMinorSize);
            subtickUpdate.attr("x2", 0).attr("y2", tickMinorSize);
            lineEnter.attr("y2", tickMajorSize);
            textEnter.attr("y", Math.max(tickMajorSize, 0) + tickPadding);
            lineUpdate.attr("x2", 0).attr("y2", tickMajorSize);
            textUpdate.attr("x", 0).attr("y", Math.max(tickMajorSize, 0) + tickPadding);
            text.attr("dy", ".71em").attr("text-anchor", "middle");
            pathUpdate.attr("d", "M" + range[0] + "," + tickEndSize + "V0H" + range[1] + "V" + tickEndSize);
            break;
          }
         case "top":
          {
            tickTransform = d3_svg_axisX;
            subtickEnter.attr("y2", -tickMinorSize);
            subtickUpdate.attr("x2", 0).attr("y2", -tickMinorSize);
            lineEnter.attr("y2", -tickMajorSize);
            textEnter.attr("y", -(Math.max(tickMajorSize, 0) + tickPadding));
            lineUpdate.attr("x2", 0).attr("y2", -tickMajorSize);
            textUpdate.attr("x", 0).attr("y", -(Math.max(tickMajorSize, 0) + tickPadding));
            text.attr("dy", "0em").attr("text-anchor", "middle");
            pathUpdate.attr("d", "M" + range[0] + "," + -tickEndSize + "V0H" + range[1] + "V" + -tickEndSize);
            break;
          }
         case "left":
          {
            tickTransform = d3_svg_axisY;
            subtickEnter.attr("x2", -tickMinorSize);
            subtickUpdate.attr("x2", -tickMinorSize).attr("y2", 0);
            lineEnter.attr("x2", -tickMajorSize);
            textEnter.attr("x", -(Math.max(tickMajorSize, 0) + tickPadding));
            lineUpdate.attr("x2", -tickMajorSize).attr("y2", 0);
            textUpdate.attr("x", -(Math.max(tickMajorSize, 0) + tickPadding)).attr("y", 0);
            text.attr("dy", ".32em").attr("text-anchor", "end");
            pathUpdate.attr("d", "M" + -tickEndSize + "," + range[0] + "H0V" + range[1] + "H" + -tickEndSize);
            break;
          }
         case "right":
          {
            tickTransform = d3_svg_axisY;
            subtickEnter.attr("x2", tickMinorSize);
            subtickUpdate.attr("x2", tickMinorSize).attr("y2", 0);
            lineEnter.attr("x2", tickMajorSize);
            textEnter.attr("x", Math.max(tickMajorSize, 0) + tickPadding);
            lineUpdate.attr("x2", tickMajorSize).attr("y2", 0);
            textUpdate.attr("x", Math.max(tickMajorSize, 0) + tickPadding).attr("y", 0);
            text.attr("dy", ".32em").attr("text-anchor", "start");
            pathUpdate.attr("d", "M" + tickEndSize + "," + range[0] + "H0V" + range[1] + "H" + tickEndSize);
            break;
          }
        }
        if (scale.ticks) {
          tickEnter.call(tickTransform, scale0);
          tickUpdate.call(tickTransform, scale1);
          tickExit.call(tickTransform, scale1);
          subtickEnter.call(tickTransform, scale0);
          subtickUpdate.call(tickTransform, scale1);
          subtickExit.call(tickTransform, scale1);
        } else {
          var dx = scale1.rangeBand() / 2, x = function(d) {
            return scale1(d) + dx;
          };
          tickEnter.call(tickTransform, x);
          tickUpdate.call(tickTransform, x);
        }
      });
    }
    var scale = d3.scale.linear(), orient = "bottom", tickMajorSize = 6, tickMinorSize = 6, tickEndSize = 6, tickPadding = 3, tickArguments_ = [ 10 ], tickValues = null, tickFormat_, tickSubdivide = 0;
    axis.scale = function(x) {
      if (!arguments.length) return scale;
      scale = x;
      return axis;
    };
    axis.orient = function(x) {
      if (!arguments.length) return orient;
      orient = x;
      return axis;
    };
    axis.ticks = function() {
      if (!arguments.length) return tickArguments_;
      tickArguments_ = arguments;
      return axis;
    };
    axis.tickValues = function(x) {
      if (!arguments.length) return tickValues;
      tickValues = x;
      return axis;
    };
    axis.tickFormat = function(x) {
      if (!arguments.length) return tickFormat_;
      tickFormat_ = x;
      return axis;
    };
    axis.tickSize = function(x, y, z) {
      if (!arguments.length) return tickMajorSize;
      var n = arguments.length - 1;
      tickMajorSize = +x;
      tickMinorSize = n > 1 ? +y : tickMajorSize;
      tickEndSize = n > 0 ? +arguments[n] : tickMajorSize;
      return axis;
    };
    axis.tickPadding = function(x) {
      if (!arguments.length) return tickPadding;
      tickPadding = +x;
      return axis;
    };
    axis.tickSubdivide = function(x) {
      if (!arguments.length) return tickSubdivide;
      tickSubdivide = +x;
      return axis;
    };
    return axis;
  };
  d3.svg.brush = function() {
    function brush(g) {
      g.each(function() {
        var g = d3.select(this), bg = g.selectAll(".background").data([ 0 ]), fg = g.selectAll(".extent").data([ 0 ]), tz = g.selectAll(".resize").data(resizes, String), e;
        g.style("pointer-events", "all").on("mousedown.brush", brushstart).on("touchstart.brush", brushstart);
        bg.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair");
        fg.enter().append("rect").attr("class", "extent").style("cursor", "move");
        tz.enter().append("g").attr("class", function(d) {
          return "resize " + d;
        }).style("cursor", function(d) {
          return d3_svg_brushCursor[d];
        }).append("rect").attr("x", function(d) {
          return /[ew]$/.test(d) ? -3 : null;
        }).attr("y", function(d) {
          return /^[ns]/.test(d) ? -3 : null;
        }).attr("width", 6).attr("height", 6).style("visibility", "hidden");
        tz.style("display", brush.empty() ? "none" : null);
        tz.exit().remove();
        if (x) {
          e = d3_scaleRange(x);
          bg.attr("x", e[0]).attr("width", e[1] - e[0]);
          redrawX(g);
        }
        if (y) {
          e = d3_scaleRange(y);
          bg.attr("y", e[0]).attr("height", e[1] - e[0]);
          redrawY(g);
        }
        redraw(g);
      });
    }
    function redraw(g) {
      g.selectAll(".resize").attr("transform", function(d) {
        return "translate(" + extent[+/e$/.test(d)][0] + "," + extent[+/^s/.test(d)][1] + ")";
      });
    }
    function redrawX(g) {
      g.select(".extent").attr("x", extent[0][0]);
      g.selectAll(".extent,.n>rect,.s>rect").attr("width", extent[1][0] - extent[0][0]);
    }
    function redrawY(g) {
      g.select(".extent").attr("y", extent[0][1]);
      g.selectAll(".extent,.e>rect,.w>rect").attr("height", extent[1][1] - extent[0][1]);
    }
    function brushstart() {
      function mouse() {
        var touches = d3.event.changedTouches;
        return touches ? d3.touches(target, touches)[0] : d3.mouse(target);
      }
      function keydown() {
        if (d3.event.keyCode == 32) {
          if (!dragging) {
            center = null;
            origin[0] -= extent[1][0];
            origin[1] -= extent[1][1];
            dragging = 2;
          }
          d3_eventCancel();
        }
      }
      function keyup() {
        if (d3.event.keyCode == 32 && dragging == 2) {
          origin[0] += extent[1][0];
          origin[1] += extent[1][1];
          dragging = 0;
          d3_eventCancel();
        }
      }
      function brushmove() {
        var point = mouse(), moved = false;
        if (offset) {
          point[0] += offset[0];
          point[1] += offset[1];
        }
        if (!dragging) {
          if (d3.event.altKey) {
            if (!center) center = [ (extent[0][0] + extent[1][0]) / 2, (extent[0][1] + extent[1][1]) / 2 ];
            origin[0] = extent[+(point[0] < center[0])][0];
            origin[1] = extent[+(point[1] < center[1])][1];
          } else center = null;
        }
        if (resizingX && move1(point, x, 0)) {
          redrawX(g);
          moved = true;
        }
        if (resizingY && move1(point, y, 1)) {
          redrawY(g);
          moved = true;
        }
        if (moved) {
          redraw(g);
          event_({
            type: "brush",
            mode: dragging ? "move" : "resize"
          });
        }
      }
      function move1(point, scale, i) {
        var range = d3_scaleRange(scale), r0 = range[0], r1 = range[1], position = origin[i], size = extent[1][i] - extent[0][i], min, max;
        if (dragging) {
          r0 -= position;
          r1 -= size + position;
        }
        min = Math.max(r0, Math.min(r1, point[i]));
        if (dragging) {
          max = (min += position) + size;
        } else {
          if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));
          if (position < min) {
            max = min;
            min = position;
          } else {
            max = position;
          }
        }
        if (extent[0][i] !== min || extent[1][i] !== max) {
          extentDomain = null;
          extent[0][i] = min;
          extent[1][i] = max;
          return true;
        }
      }
      function brushend() {
        brushmove();
        g.style("pointer-events", "all").selectAll(".resize").style("display", brush.empty() ? "none" : null);
        d3.select("body").style("cursor", null);
        w.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null);
        event_({
          type: "brushend"
        });
        d3_eventCancel();
      }
      var target = this, eventTarget = d3.select(d3.event.target), event_ = event.of(target, arguments), g = d3.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) && x, resizingY = !/^(e|w)$/.test(resizing) && y, dragging = eventTarget.classed("extent"), center, origin = mouse(), offset;
      var w = d3.select(window).on("mousemove.brush", brushmove).on("mouseup.brush", brushend).on("touchmove.brush", brushmove).on("touchend.brush", brushend).on("keydown.brush", keydown).on("keyup.brush", keyup);
      if (dragging) {
        origin[0] = extent[0][0] - origin[0];
        origin[1] = extent[0][1] - origin[1];
      } else if (resizing) {
        var ex = +/w$/.test(resizing), ey = +/^n/.test(resizing);
        offset = [ extent[1 - ex][0] - origin[0], extent[1 - ey][1] - origin[1] ];
        origin[0] = extent[ex][0];
        origin[1] = extent[ey][1];
      } else if (d3.event.altKey) center = origin.slice();
      g.style("pointer-events", "none").selectAll(".resize").style("display", null);
      d3.select("body").style("cursor", eventTarget.style("cursor"));
      event_({
        type: "brushstart"
      });
      brushmove();
      d3_eventCancel();
    }
    var event = d3_eventDispatch(brush, "brushstart", "brush", "brushend"), x = null, y = null, resizes = d3_svg_brushResizes[0], extent = [ [ 0, 0 ], [ 0, 0 ] ], extentDomain;
    brush.x = function(z) {
      if (!arguments.length) return x;
      x = z;
      resizes = d3_svg_brushResizes[!x << 1 | !y];
      return brush;
    };
    brush.y = function(z) {
      if (!arguments.length) return y;
      y = z;
      resizes = d3_svg_brushResizes[!x << 1 | !y];
      return brush;
    };
    brush.extent = function(z) {
      var x0, x1, y0, y1, t;
      if (!arguments.length) {
        z = extentDomain || extent;
        if (x) {
          x0 = z[0][0], x1 = z[1][0];
          if (!extentDomain) {
            x0 = extent[0][0], x1 = extent[1][0];
            if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);
            if (x1 < x0) t = x0, x0 = x1, x1 = t;
          }
        }
        if (y) {
          y0 = z[0][1], y1 = z[1][1];
          if (!extentDomain) {
            y0 = extent[0][1], y1 = extent[1][1];
            if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);
            if (y1 < y0) t = y0, y0 = y1, y1 = t;
          }
        }
        return x && y ? [ [ x0, y0 ], [ x1, y1 ] ] : x ? [ x0, x1 ] : y && [ y0, y1 ];
      }
      extentDomain = [ [ 0, 0 ], [ 0, 0 ] ];
      if (x) {
        x0 = z[0], x1 = z[1];
        if (y) x0 = x0[0], x1 = x1[0];
        extentDomain[0][0] = x0, extentDomain[1][0] = x1;
        if (x.invert) x0 = x(x0), x1 = x(x1);
        if (x1 < x0) t = x0, x0 = x1, x1 = t;
        extent[0][0] = x0 | 0, extent[1][0] = x1 | 0;
      }
      if (y) {
        y0 = z[0], y1 = z[1];
        if (x) y0 = y0[1], y1 = y1[1];
        extentDomain[0][1] = y0, extentDomain[1][1] = y1;
        if (y.invert) y0 = y(y0), y1 = y(y1);
        if (y1 < y0) t = y0, y0 = y1, y1 = t;
        extent[0][1] = y0 | 0, extent[1][1] = y1 | 0;
      }
      return brush;
    };
    brush.clear = function() {
      extentDomain = null;
      extent[0][0] = extent[0][1] = extent[1][0] = extent[1][1] = 0;
      return brush;
    };
    brush.empty = function() {
      return x && extent[0][0] === extent[1][0] || y && extent[0][1] === extent[1][1];
    };
    return d3.rebind(brush, event, "on");
  };
  var d3_svg_brushCursor = {
    n: "ns-resize",
    e: "ew-resize",
    s: "ns-resize",
    w: "ew-resize",
    nw: "nwse-resize",
    ne: "nesw-resize",
    se: "nwse-resize",
    sw: "nesw-resize"
  };
  var d3_svg_brushResizes = [ [ "n", "e", "s", "w", "nw", "ne", "se", "sw" ], [ "e", "w" ], [ "n", "s" ], [] ];
  d3.behavior = {};
  d3.behavior.drag = function() {
    function drag() {
      this.on("mousedown.drag", mousedown).on("touchstart.drag", mousedown);
    }
    function mousedown() {
      function point() {
        var p = target.parentNode;
        return touchId ? d3.touches(p).filter(function(p) {
          return p.identifier === touchId;
        })[0] : d3.mouse(p);
      }
      function dragmove() {
        if (!target.parentNode) return dragend();
        var p = point(), dx = p[0] - origin_[0], dy = p[1] - origin_[1];
        moved |= dx | dy;
        origin_ = p;
        d3_eventCancel();
        event_({
          type: "drag",
          x: p[0] + offset[0],
          y: p[1] + offset[1],
          dx: dx,
          dy: dy
        });
      }
      function dragend() {
        event_({
          type: "dragend"
        });
        if (moved) {
          d3_eventCancel();
          if (d3.event.target === eventTarget) w.on("click.drag", click, true);
        }
        w.on(touchId ? "touchmove.drag-" + touchId : "mousemove.drag", null).on(touchId ? "touchend.drag-" + touchId : "mouseup.drag", null);
      }
      function click() {
        d3_eventCancel();
        w.on("click.drag", null);
      }
      var target = this, event_ = event.of(target, arguments), eventTarget = d3.event.target, touchId = d3.event.touches && d3.event.changedTouches[0].identifier, offset, origin_ = point(), moved = 0;
      var w = d3.select(window).on(touchId ? "touchmove.drag-" + touchId : "mousemove.drag", dragmove).on(touchId ? "touchend.drag-" + touchId : "mouseup.drag", dragend, true);
      if (origin) {
        offset = origin.apply(target, arguments);
        offset = [ offset.x - origin_[0], offset.y - origin_[1] ];
      } else {
        offset = [ 0, 0 ];
      }
      if (!touchId) d3_eventCancel();
      event_({
        type: "dragstart"
      });
    }
    var event = d3_eventDispatch(drag, "drag", "dragstart", "dragend"), origin = null;
    drag.origin = function(x) {
      if (!arguments.length) return origin;
      origin = x;
      return drag;
    };
    return d3.rebind(drag, event, "on");
  };
  d3.behavior.zoom = function() {
    function zoom() {
      this.on("mousedown.zoom", mousedown).on("mousewheel.zoom", mousewheel).on("mousemove.zoom", mousemove).on("DOMMouseScroll.zoom", mousewheel).on("dblclick.zoom", dblclick).on("touchstart.zoom", touchstart).on("touchmove.zoom", touchmove).on("touchend.zoom", touchstart);
    }
    function location(p) {
      return [ (p[0] - translate[0]) / scale, (p[1] - translate[1]) / scale ];
    }
    function point(l) {
      return [ l[0] * scale + translate[0], l[1] * scale + translate[1] ];
    }
    function scaleTo(s) {
      scale = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));
    }
    function translateTo(p, l) {
      l = point(l);
      translate[0] += p[0] - l[0];
      translate[1] += p[1] - l[1];
    }
    function dispatch(event) {
      if (x1) x1.domain(x0.range().map(function(x) {
        return (x - translate[0]) / scale;
      }).map(x0.invert));
      if (y1) y1.domain(y0.range().map(function(y) {
        return (y - translate[1]) / scale;
      }).map(y0.invert));
      d3.event.preventDefault();
      event({
        type: "zoom",
        scale: scale,
        translate: translate
      });
    }
    function mousedown() {
      function mousemove() {
        moved = 1;
        translateTo(d3.mouse(target), l);
        dispatch(event_);
      }
      function mouseup() {
        if (moved) d3_eventCancel();
        w.on("mousemove.zoom", null).on("mouseup.zoom", null);
        if (moved && d3.event.target === eventTarget) w.on("click.zoom", click, true);
      }
      function click() {
        d3_eventCancel();
        w.on("click.zoom", null);
      }
      var target = this, event_ = event.of(target, arguments), eventTarget = d3.event.target, moved = 0, w = d3.select(window).on("mousemove.zoom", mousemove).on("mouseup.zoom", mouseup), l = location(d3.mouse(target));
      window.focus();
      d3_eventCancel();
    }
    function mousewheel() {
      if (!translate0) translate0 = location(d3.mouse(this));
      scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * scale);
      translateTo(d3.mouse(this), translate0);
      dispatch(event.of(this, arguments));
    }
    function mousemove() {
      translate0 = null;
    }
    function dblclick() {
      var p = d3.mouse(this), l = location(p);
      scaleTo(d3.event.shiftKey ? scale / 2 : scale * 2);
      translateTo(p, l);
      dispatch(event.of(this, arguments));
    }
    function touchstart() {
      var touches = d3.touches(this), now = Date.now();
      scale0 = scale;
      translate0 = {};
      touches.forEach(function(t) {
        translate0[t.identifier] = location(t);
      });
      d3_eventCancel();
      if (touches.length === 1) {
        if (now - touchtime < 500) {
          var p = touches[0], l = location(touches[0]);
          scaleTo(scale * 2);
          translateTo(p, l);
          dispatch(event.of(this, arguments));
        }
        touchtime = now;
      }
    }
    function touchmove() {
      var touches = d3.touches(this), p0 = touches[0], l0 = translate0[p0.identifier];
      if (p1 = touches[1]) {
        var p1, l1 = translate0[p1.identifier];
        p0 = [ (p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2 ];
        l0 = [ (l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2 ];
        scaleTo(d3.event.scale * scale0);
      }
      translateTo(p0, l0);
      touchtime = null;
      dispatch(event.of(this, arguments));
    }
    var translate = [ 0, 0 ], translate0, scale = 1, scale0, scaleExtent = d3_behavior_zoomInfinity, event = d3_eventDispatch(zoom, "zoom"), x0, x1, y0, y1, touchtime;
    zoom.translate = function(x) {
      if (!arguments.length) return translate;
      translate = x.map(Number);
      return zoom;
    };
    zoom.scale = function(x) {
      if (!arguments.length) return scale;
      scale = +x;
      return zoom;
    };
    zoom.scaleExtent = function(x) {
      if (!arguments.length) return scaleExtent;
      scaleExtent = x == null ? d3_behavior_zoomInfinity : x.map(Number);
      return zoom;
    };
    zoom.x = function(z) {
      if (!arguments.length) return x1;
      x1 = z;
      x0 = z.copy();
      return zoom;
    };
    zoom.y = function(z) {
      if (!arguments.length) return y1;
      y1 = z;
      y0 = z.copy();
      return zoom;
    };
    return d3.rebind(zoom, event, "on");
  };
  var d3_behavior_zoomDiv, d3_behavior_zoomInfinity = [ 0, Infinity ];
  d3.layout = {};
  d3.layout.bundle = function() {
    return function(links) {
      var paths = [], i = -1, n = links.length;
      while (++i < n) paths.push(d3_layout_bundlePath(links[i]));
      return paths;
    };
  };
  d3.layout.chord = function() {
    function relayout() {
      var subgroups = {}, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [], k, x, x0, i, j;
      chords = [];
      groups = [];
      k = 0, i = -1;
      while (++i < n) {
        x = 0, j = -1;
        while (++j < n) {
          x += matrix[i][j];
        }
        groupSums.push(x);
        subgroupIndex.push(d3.range(n));
        k += x;
      }
      if (sortGroups) {
        groupIndex.sort(function(a, b) {
          return sortGroups(groupSums[a], groupSums[b]);
        });
      }
      if (sortSubgroups) {
        subgroupIndex.forEach(function(d, i) {
          d.sort(function(a, b) {
            return sortSubgroups(matrix[i][a], matrix[i][b]);
          });
        });
      }
      k = (2 * Math.PI - padding * n) / k;
      x = 0, i = -1;
      while (++i < n) {
        x0 = x, j = -1;
        while (++j < n) {
          var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;
          subgroups[di + "-" + dj] = {
            index: di,
            subindex: dj,
            startAngle: a0,
            endAngle: a1,
            value: v
          };
        }
        groups[di] = {
          index: di,
          startAngle: x0,
          endAngle: x,
          value: (x - x0) / k
        };
        x += padding;
      }
      i = -1;
      while (++i < n) {
        j = i - 1;
        while (++j < n) {
          var source = subgroups[i + "-" + j], target = subgroups[j + "-" + i];
          if (source.value || target.value) {
            chords.push(source.value < target.value ? {
              source: target,
              target: source
            } : {
              source: source,
              target: target
            });
          }
        }
      }
      if (sortChords) resort();
    }
    function resort() {
      chords.sort(function(a, b) {
        return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);
      });
    }
    var chord = {}, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords;
    chord.matrix = function(x) {
      if (!arguments.length) return matrix;
      n = (matrix = x) && matrix.length;
      chords = groups = null;
      return chord;
    };
    chord.padding = function(x) {
      if (!arguments.length) return padding;
      padding = x;
      chords = groups = null;
      return chord;
    };
    chord.sortGroups = function(x) {
      if (!arguments.length) return sortGroups;
      sortGroups = x;
      chords = groups = null;
      return chord;
    };
    chord.sortSubgroups = function(x) {
      if (!arguments.length) return sortSubgroups;
      sortSubgroups = x;
      chords = null;
      return chord;
    };
    chord.sortChords = function(x) {
      if (!arguments.length) return sortChords;
      sortChords = x;
      if (chords) resort();
      return chord;
    };
    chord.chords = function() {
      if (!chords) relayout();
      return chords;
    };
    chord.groups = function() {
      if (!groups) relayout();
      return groups;
    };
    return chord;
  };
  d3.layout.force = function() {
    function repulse(node) {
      return function(quad, x1, y1, x2, y2) {
        if (quad.point !== node) {
          var dx = quad.cx - node.x, dy = quad.cy - node.y, dn = 1 / Math.sqrt(dx * dx + dy * dy);
          if ((x2 - x1) * dn < theta) {
            var k = quad.charge * dn * dn;
            node.px -= dx * k;
            node.py -= dy * k;
            return true;
          }
          if (quad.point && isFinite(dn)) {
            var k = quad.pointCharge * dn * dn;
            node.px -= dx * k;
            node.py -= dy * k;
          }
        }
        return !quad.charge;
      };
    }
    function dragmove(d) {
      d.px = d3.event.x;
      d.py = d3.event.y;
      force.resume();
    }
    var force = {}, event = d3.dispatch("start", "tick", "end"), size = [ 1, 1 ], drag, alpha, friction = .9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, gravity = .1, theta = .8, interval, nodes = [], links = [], distances, strengths, charges;
    force.tick = function() {
      if ((alpha *= .99) < .005) {
        event.end({
          type: "end",
          alpha: alpha = 0
        });
        return true;
      }
      var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y;
      for (i = 0; i < m; ++i) {
        o = links[i];
        s = o.source;
        t = o.target;
        x = t.x - s.x;
        y = t.y - s.y;
        if (l = x * x + y * y) {
          l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
          x *= l;
          y *= l;
          t.x -= x * (k = s.weight / (t.weight + s.weight));
          t.y -= y * k;
          s.x += x * (k = 1 - k);
          s.y += y * k;
        }
      }
      if (k = alpha * gravity) {
        x = size[0] / 2;
        y = size[1] / 2;
        i = -1;
        if (k) while (++i < n) {
          o = nodes[i];
          o.x += (x - o.x) * k;
          o.y += (y - o.y) * k;
        }
      }
      if (charge) {
        d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
        i = -1;
        while (++i < n) {
          if (!(o = nodes[i]).fixed) {
            q.visit(repulse(o));
          }
        }
      }
      i = -1;
      while (++i < n) {
        o = nodes[i];
        if (o.fixed) {
          o.x = o.px;
          o.y = o.py;
        } else {
          o.x -= (o.px - (o.px = o.x)) * friction;
          o.y -= (o.py - (o.py = o.y)) * friction;
        }
      }
      event.tick({
        type: "tick",
        alpha: alpha
      });
    };
    force.nodes = function(x) {
      if (!arguments.length) return nodes;
      nodes = x;
      return force;
    };
    force.links = function(x) {
      if (!arguments.length) return links;
      links = x;
      return force;
    };
    force.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return force;
    };
    force.linkDistance = function(x) {
      if (!arguments.length) return linkDistance;
      linkDistance = d3_functor(x);
      return force;
    };
    force.distance = force.linkDistance;
    force.linkStrength = function(x) {
      if (!arguments.length) return linkStrength;
      linkStrength = d3_functor(x);
      return force;
    };
    force.friction = function(x) {
      if (!arguments.length) return friction;
      friction = x;
      return force;
    };
    force.charge = function(x) {
      if (!arguments.length) return charge;
      charge = typeof x === "function" ? x : +x;
      return force;
    };
    force.gravity = function(x) {
      if (!arguments.length) return gravity;
      gravity = x;
      return force;
    };
    force.theta = function(x) {
      if (!arguments.length) return theta;
      theta = x;
      return force;
    };
    force.alpha = function(x) {
      if (!arguments.length) return alpha;
      if (alpha) {
        if (x > 0) alpha = x; else alpha = 0;
      } else if (x > 0) {
        event.start({
          type: "start",
          alpha: alpha = x
        });
        d3.timer(force.tick);
      }
      return force;
    };
    force.start = function() {
      function position(dimension, size) {
        var neighbors = neighbor(i), j = -1, m = neighbors.length, x;
        while (++j < m) if (!isNaN(x = neighbors[j][dimension])) return x;
        return Math.random() * size;
      }
      function neighbor() {
        if (!neighbors) {
          neighbors = [];
          for (j = 0; j < n; ++j) {
            neighbors[j] = [];
          }
          for (j = 0; j < m; ++j) {
            var o = links[j];
            neighbors[o.source.index].push(o.target);
            neighbors[o.target.index].push(o.source);
          }
        }
        return neighbors[i];
      }
      var i, j, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o;
      for (i = 0; i < n; ++i) {
        (o = nodes[i]).index = i;
        o.weight = 0;
      }
      distances = [];
      strengths = [];
      for (i = 0; i < m; ++i) {
        o = links[i];
        if (typeof o.source == "number") o.source = nodes[o.source];
        if (typeof o.target == "number") o.target = nodes[o.target];
        distances[i] = linkDistance.call(this, o, i);
        strengths[i] = linkStrength.call(this, o, i);
        ++o.source.weight;
        ++o.target.weight;
      }
      for (i = 0; i < n; ++i) {
        o = nodes[i];
        if (isNaN(o.x)) o.x = position("x", w);
        if (isNaN(o.y)) o.y = position("y", h);
        if (isNaN(o.px)) o.px = o.x;
        if (isNaN(o.py)) o.py = o.y;
      }
      charges = [];
      if (typeof charge === "function") {
        for (i = 0; i < n; ++i) {
          charges[i] = +charge.call(this, nodes[i], i);
        }
      } else {
        for (i = 0; i < n; ++i) {
          charges[i] = charge;
        }
      }
      return force.resume();
    };
    force.resume = function() {
      return force.alpha(.1);
    };
    force.stop = function() {
      return force.alpha(0);
    };
    force.drag = function() {
      if (!drag) drag = d3.behavior.drag().origin(d3_identity).on("dragstart", d3_layout_forceDragstart).on("drag", dragmove).on("dragend", d3_layout_forceDragend);
      this.on("mouseover.force", d3_layout_forceMouseover).on("mouseout.force", d3_layout_forceMouseout).call(drag);
    };
    return d3.rebind(force, event, "on");
  };
  d3.layout.partition = function() {
    function position(node, x, dx, dy) {
      var children = node.children;
      node.x = x;
      node.y = node.depth * dy;
      node.dx = dx;
      node.dy = dy;
      if (children && (n = children.length)) {
        var i = -1, n, c, d;
        dx = node.value ? dx / node.value : 0;
        while (++i < n) {
          position(c = children[i], x, d = c.value * dx, dy);
          x += d;
        }
      }
    }
    function depth(node) {
      var children = node.children, d = 0;
      if (children && (n = children.length)) {
        var i = -1, n;
        while (++i < n) d = Math.max(d, depth(children[i]));
      }
      return 1 + d;
    }
    function partition(d, i) {
      var nodes = hierarchy.call(this, d, i);
      position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
      return nodes;
    }
    var hierarchy = d3.layout.hierarchy(), size = [ 1, 1 ];
    partition.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return partition;
    };
    return d3_layout_hierarchyRebind(partition, hierarchy);
  };
  d3.layout.pie = function() {
    function pie(data, i) {
      var values = data.map(function(d, i) {
        return +value.call(pie, d, i);
      });
      var a = +(typeof startAngle === "function" ? startAngle.apply(this, arguments) : startAngle);
      var k = ((typeof endAngle === "function" ? endAngle.apply(this, arguments) : endAngle) - startAngle) / d3.sum(values);
      var index = d3.range(data.length);
      if (sort != null) index.sort(sort === d3_layout_pieSortByValue ? function(i, j) {
        return values[j] - values[i];
      } : function(i, j) {
        return sort(data[i], data[j]);
      });
      var arcs = [];
      index.forEach(function(i) {
        var d;
        arcs[i] = {
          data: data[i],
          value: d = values[i],
          startAngle: a,
          endAngle: a += d * k
        };
      });
      return arcs;
    }
    var value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = 2 * Math.PI;
    pie.value = function(x) {
      if (!arguments.length) return value;
      value = x;
      return pie;
    };
    pie.sort = function(x) {
      if (!arguments.length) return sort;
      sort = x;
      return pie;
    };
    pie.startAngle = function(x) {
      if (!arguments.length) return startAngle;
      startAngle = x;
      return pie;
    };
    pie.endAngle = function(x) {
      if (!arguments.length) return endAngle;
      endAngle = x;
      return pie;
    };
    return pie;
  };
  var d3_layout_pieSortByValue = {};
  d3.layout.stack = function() {
    function stack(data, index) {
      var series = data.map(function(d, i) {
        return values.call(stack, d, i);
      });
      var points = series.map(function(d, i) {
        return d.map(function(v, i) {
          return [ x.call(stack, v, i), y.call(stack, v, i) ];
        });
      });
      var orders = order.call(stack, points, index);
      series = d3.permute(series, orders);
      points = d3.permute(points, orders);
      var offsets = offset.call(stack, points, index);
      var n = series.length, m = series[0].length, i, j, o;
      for (j = 0; j < m; ++j) {
        out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);
        for (i = 1; i < n; ++i) {
          out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);
        }
      }
      return data;
    }
    var values = d3_identity, order = d3_layout_stackOrderDefault, offset = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x = d3_layout_stackX, y = d3_layout_stackY;
    stack.values = function(x) {
      if (!arguments.length) return values;
      values = x;
      return stack;
    };
    stack.order = function(x) {
      if (!arguments.length) return order;
      order = typeof x === "function" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;
      return stack;
    };
    stack.offset = function(x) {
      if (!arguments.length) return offset;
      offset = typeof x === "function" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;
      return stack;
    };
    stack.x = function(z) {
      if (!arguments.length) return x;
      x = z;
      return stack;
    };
    stack.y = function(z) {
      if (!arguments.length) return y;
      y = z;
      return stack;
    };
    stack.out = function(z) {
      if (!arguments.length) return out;
      out = z;
      return stack;
    };
    return stack;
  };
  var d3_layout_stackOrders = d3.map({
    "inside-out": function(data) {
      var n = data.length, i, j, max = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index = d3.range(n).sort(function(a, b) {
        return max[a] - max[b];
      }), top = 0, bottom = 0, tops = [], bottoms = [];
      for (i = 0; i < n; ++i) {
        j = index[i];
        if (top < bottom) {
          top += sums[j];
          tops.push(j);
        } else {
          bottom += sums[j];
          bottoms.push(j);
        }
      }
      return bottoms.reverse().concat(tops);
    },
    reverse: function(data) {
      return d3.range(data.length).reverse();
    },
    "default": d3_layout_stackOrderDefault
  });
  var d3_layout_stackOffsets = d3.map({
    silhouette: function(data) {
      var n = data.length, m = data[0].length, sums = [], max = 0, i, j, o, y0 = [];
      for (j = 0; j < m; ++j) {
        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
        if (o > max) max = o;
        sums.push(o);
      }
      for (j = 0; j < m; ++j) {
        y0[j] = (max - sums[j]) / 2;
      }
      return y0;
    },
    wiggle: function(data) {
      var n = data.length, x = data[0], m = x.length, max = 0, i, j, k, s1, s2, s3, dx, o, o0, y0 = [];
      y0[0] = o = o0 = 0;
      for (j = 1; j < m; ++j) {
        for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];
        for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {
          for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {
            s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;
          }
          s2 += s3 * data[i][j][1];
        }
        y0[j] = o -= s1 ? s2 / s1 * dx : 0;
        if (o < o0) o0 = o;
      }
      for (j = 0; j < m; ++j) y0[j] -= o0;
      return y0;
    },
    expand: function(data) {
      var n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = [];
      for (j = 0; j < m; ++j) {
        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
        if (o) for (i = 0; i < n; i++) data[i][j][1] /= o; else for (i = 0; i < n; i++) data[i][j][1] = k;
      }
      for (j = 0; j < m; ++j) y0[j] = 0;
      return y0;
    },
    zero: d3_layout_stackOffsetZero
  });
  d3.layout.histogram = function() {
    function histogram(data, i) {
      var bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), bin, i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n, x;
      while (++i < m) {
        bin = bins[i] = [];
        bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);
        bin.y = 0;
      }
      if (m > 0) {
        i = -1;
        while (++i < n) {
          x = values[i];
          if (x >= range[0] && x <= range[1]) {
            bin = bins[d3.bisect(thresholds, x, 1, m) - 1];
            bin.y += k;
            bin.push(data[i]);
          }
        }
      }
      return bins;
    }
    var frequency = true, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges;
    histogram.value = function(x) {
      if (!arguments.length) return valuer;
      valuer = x;
      return histogram;
    };
    histogram.range = function(x) {
      if (!arguments.length) return ranger;
      ranger = d3_functor(x);
      return histogram;
    };
    histogram.bins = function(x) {
      if (!arguments.length) return binner;
      binner = typeof x === "number" ? function(range) {
        return d3_layout_histogramBinFixed(range, x);
      } : d3_functor(x);
      return histogram;
    };
    histogram.frequency = function(x) {
      if (!arguments.length) return frequency;
      frequency = !!x;
      return histogram;
    };
    return histogram;
  };
  d3.layout.hierarchy = function() {
    function recurse(data, depth, nodes) {
      var childs = children.call(hierarchy, data, depth), node = d3_layout_hierarchyInline ? data : {
        data: data
      };
      node.depth = depth;
      nodes.push(node);
      if (childs && (n = childs.length)) {
        var i = -1, n, c = node.children = [], v = 0, j = depth + 1, d;
        while (++i < n) {
          d = recurse(childs[i], j, nodes);
          d.parent = node;
          c.push(d);
          v += d.value;
        }
        if (sort) c.sort(sort);
        if (value) node.value = v;
      } else if (value) {
        node.value = +value.call(hierarchy, data, depth) || 0;
      }
      return node;
    }
    function revalue(node, depth) {
      var children = node.children, v = 0;
      if (children && (n = children.length)) {
        var i = -1, n, j = depth + 1;
        while (++i < n) v += revalue(children[i], j);
      } else if (value) {
        v = +value.call(hierarchy, d3_layout_hierarchyInline ? node : node.data, depth) || 0;
      }
      if (value) node.value = v;
      return v;
    }
    function hierarchy(d) {
      var nodes = [];
      recurse(d, 0, nodes);
      return nodes;
    }
    var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;
    hierarchy.sort = function(x) {
      if (!arguments.length) return sort;
      sort = x;
      return hierarchy;
    };
    hierarchy.children = function(x) {
      if (!arguments.length) return children;
      children = x;
      return hierarchy;
    };
    hierarchy.value = function(x) {
      if (!arguments.length) return value;
      value = x;
      return hierarchy;
    };
    hierarchy.revalue = function(root) {
      revalue(root, 0);
      return root;
    };
    return hierarchy;
  };
  var d3_layout_hierarchyInline = false;
  d3.layout.pack = function() {
    function pack(d, i) {
      var nodes = hierarchy.call(this, d, i), root = nodes[0];
      root.x = 0;
      root.y = 0;
      d3_layout_treeVisitAfter(root, function(d) {
        d.r = Math.sqrt(d.value);
      });
      d3_layout_treeVisitAfter(root, d3_layout_packSiblings);
      var w = size[0], h = size[1], k = Math.max(2 * root.r / w, 2 * root.r / h);
      if (padding > 0) {
        var dr = padding * k / 2;
        d3_layout_treeVisitAfter(root, function(d) {
          d.r += dr;
        });
        d3_layout_treeVisitAfter(root, d3_layout_packSiblings);
        d3_layout_treeVisitAfter(root, function(d) {
          d.r -= dr;
        });
        k = Math.max(2 * root.r / w, 2 * root.r / h);
      }
      d3_layout_packTransform(root, w / 2, h / 2, 1 / k);
      return nodes;
    }
    var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [ 1, 1 ];
    pack.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return pack;
    };
    pack.padding = function(_) {
      if (!arguments.length) return padding;
      padding = +_;
      return pack;
    };
    return d3_layout_hierarchyRebind(pack, hierarchy);
  };
  d3.layout.cluster = function() {
    function cluster(d, i) {
      var nodes = hierarchy.call(this, d, i), root = nodes[0], previousNode, x = 0, kx, ky;
      d3_layout_treeVisitAfter(root, function(node) {
        var children = node.children;
        if (children && children.length) {
          node.x = d3_layout_clusterX(children);
          node.y = d3_layout_clusterY(children);
        } else {
          node.x = previousNode ? x += separation(node, previousNode) : 0;
          node.y = 0;
          previousNode = node;
        }
      });
      var left = d3_layout_clusterLeft(root), right = d3_layout_clusterRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;
      d3_layout_treeVisitAfter(root, function(node) {
        node.x = (node.x - x0) / (x1 - x0) * size[0];
        node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];
      });
      return nodes;
    }
    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ];
    cluster.separation = function(x) {
      if (!arguments.length) return separation;
      separation = x;
      return cluster;
    };
    cluster.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return cluster;
    };
    return d3_layout_hierarchyRebind(cluster, hierarchy);
  };
  d3.layout.tree = function() {
    function tree(d, i) {
      function firstWalk(node, previousSibling) {
        var children = node.children, layout = node._tree;
        if (children && (n = children.length)) {
          var n, firstChild = children[0], previousChild, ancestor = firstChild, child, i = -1;
          while (++i < n) {
            child = children[i];
            firstWalk(child, previousChild);
            ancestor = apportion(child, previousChild, ancestor);
            previousChild = child;
          }
          d3_layout_treeShift(node);
          var midpoint = .5 * (firstChild._tree.prelim + child._tree.prelim);
          if (previousSibling) {
            layout.prelim = previousSibling._tree.prelim + separation(node, previousSibling);
            layout.mod = layout.prelim - midpoint;
          } else {
            layout.prelim = midpoint;
          }
        } else {
          if (previousSibling) {
            layout.prelim = previousSibling._tree.prelim + separation(node, previousSibling);
          }
        }
      }
      function secondWalk(node, x) {
        node.x = node._tree.prelim + x;
        var children = node.children;
        if (children && (n = children.length)) {
          var i = -1, n;
          x += node._tree.mod;
          while (++i < n) {
            secondWalk(children[i], x);
          }
        }
      }
      function apportion(node, previousSibling, ancestor) {
        if (previousSibling) {
          var vip = node, vop = node, vim = previousSibling, vom = node.parent.children[0], sip = vip._tree.mod, sop = vop._tree.mod, sim = vim._tree.mod, som = vom._tree.mod, shift;
          while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {
            vom = d3_layout_treeLeft(vom);
            vop = d3_layout_treeRight(vop);
            vop._tree.ancestor = node;
            shift = vim._tree.prelim + sim - vip._tree.prelim - sip + separation(vim, vip);
            if (shift > 0) {
              d3_layout_treeMove(d3_layout_treeAncestor(vim, node, ancestor), node, shift);
              sip += shift;
              sop += shift;
            }
            sim += vim._tree.mod;
            sip += vip._tree.mod;
            som += vom._tree.mod;
            sop += vop._tree.mod;
          }
          if (vim && !d3_layout_treeRight(vop)) {
            vop._tree.thread = vim;
            vop._tree.mod += sim - sop;
          }
          if (vip && !d3_layout_treeLeft(vom)) {
            vom._tree.thread = vip;
            vom._tree.mod += sip - som;
            ancestor = node;
          }
        }
        return ancestor;
      }
      var nodes = hierarchy.call(this, d, i), root = nodes[0];
      d3_layout_treeVisitAfter(root, function(node, previousSibling) {
        node._tree = {
          ancestor: node,
          prelim: 0,
          mod: 0,
          change: 0,
          shift: 0,
          number: previousSibling ? previousSibling._tree.number + 1 : 0
        };
      });
      firstWalk(root);
      secondWalk(root, -root._tree.prelim);
      var left = d3_layout_treeSearch(root, d3_layout_treeLeftmost), right = d3_layout_treeSearch(root, d3_layout_treeRightmost), deep = d3_layout_treeSearch(root, d3_layout_treeDeepest), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2, y1 = deep.depth || 1;
      d3_layout_treeVisitAfter(root, function(node) {
        node.x = (node.x - x0) / (x1 - x0) * size[0];
        node.y = node.depth / y1 * size[1];
        delete node._tree;
      });
      return nodes;
    }
    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ];
    tree.separation = function(x) {
      if (!arguments.length) return separation;
      separation = x;
      return tree;
    };
    tree.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return tree;
    };
    return d3_layout_hierarchyRebind(tree, hierarchy);
  };
  d3.layout.treemap = function() {
    function scale(children, k) {
      var i = -1, n = children.length, child, area;
      while (++i < n) {
        area = (child = children[i]).value * (k < 0 ? 0 : k);
        child.area = isNaN(area) || area <= 0 ? 0 : area;
      }
    }
    function squarify(node) {
      var children = node.children;
      if (children && children.length) {
        var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = Math.min(rect.dx, rect.dy), n;
        scale(remaining, rect.dx * rect.dy / node.value);
        row.area = 0;
        while ((n = remaining.length) > 0) {
          row.push(child = remaining[n - 1]);
          row.area += child.area;
          if ((score = worst(row, u)) <= best) {
            remaining.pop();
            best = score;
          } else {
            row.area -= row.pop().area;
            position(row, u, rect, false);
            u = Math.min(rect.dx, rect.dy);
            row.length = row.area = 0;
            best = Infinity;
          }
        }
        if (row.length) {
          position(row, u, rect, true);
          row.length = row.area = 0;
        }
        children.forEach(squarify);
      }
    }
    function stickify(node) {
      var children = node.children;
      if (children && children.length) {
        var rect = pad(node), remaining = children.slice(), child, row = [];
        scale(remaining, rect.dx * rect.dy / node.value);
        row.area = 0;
        while (child = remaining.pop()) {
          row.push(child);
          row.area += child.area;
          if (child.z != null) {
            position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
            row.length = row.area = 0;
          }
        }
        children.forEach(stickify);
      }
    }
    function worst(row, u) {
      var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length;
      while (++i < n) {
        if (!(r = row[i].area)) continue;
        if (r < rmin) rmin = r;
        if (r > rmax) rmax = r;
      }
      s *= s;
      u *= u;
      return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;
    }
    function position(row, u, rect, flush) {
      var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o;
      if (u == rect.dx) {
        if (flush || v > rect.dy) v = rect.dy;
        while (++i < n) {
          o = row[i];
          o.x = x;
          o.y = y;
          o.dy = v;
          x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
        }
        o.z = true;
        o.dx += rect.x + rect.dx - x;
        rect.y += v;
        rect.dy -= v;
      } else {
        if (flush || v > rect.dx) v = rect.dx;
        while (++i < n) {
          o = row[i];
          o.x = x;
          o.y = y;
          o.dx = v;
          y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
        }
        o.z = false;
        o.dy += rect.y + rect.dy - y;
        rect.x += v;
        rect.dx -= v;
      }
    }
    function treemap(d) {
      var nodes = stickies || hierarchy(d), root = nodes[0];
      root.x = 0;
      root.y = 0;
      root.dx = size[0];
      root.dy = size[1];
      if (stickies) hierarchy.revalue(root);
      scale([ root ], root.dx * root.dy / root.value);
      (stickies ? stickify : squarify)(root);
      if (sticky) stickies = nodes;
      return nodes;
    }
    var hierarchy = d3.layout.hierarchy(), round = Math.round, size = [ 1, 1 ], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, ratio = .5 * (1 + Math.sqrt(5));
    treemap.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return treemap;
    };
    treemap.padding = function(x) {
      function padFunction(node) {
        var p = x.call(treemap, node, node.depth);
        return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === "number" ? [ p, p, p, p ] : p);
      }
      function padConstant(node) {
        return d3_layout_treemapPad(node, x);
      }
      if (!arguments.length) return padding;
      var type;
      pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === "function" ? padFunction : type === "number" ? (x = [ x, x, x, x ], padConstant) : padConstant;
      return treemap;
    };
    treemap.round = function(x) {
      if (!arguments.length) return round != Number;
      round = x ? Math.round : Number;
      return treemap;
    };
    treemap.sticky = function(x) {
      if (!arguments.length) return sticky;
      sticky = x;
      stickies = null;
      return treemap;
    };
    treemap.ratio = function(x) {
      if (!arguments.length) return ratio;
      ratio = x;
      return treemap;
    };
    return d3_layout_hierarchyRebind(treemap, hierarchy);
  };
  d3.csv = d3_dsv(",", "text/csv");
  d3.tsv = d3_dsv("	", "text/tab-separated-values");
  d3.geo = {};
  var d3_geo_radians = Math.PI / 180;
  d3.geo.azimuthal = function() {
    function azimuthal(coordinates) {
      var x1 = coordinates[0] * d3_geo_radians - x0, y1 = coordinates[1] * d3_geo_radians, cx1 = Math.cos(x1), sx1 = Math.sin(x1), cy1 = Math.cos(y1), sy1 = Math.sin(y1), cc = mode !== "orthographic" ? sy0 * sy1 + cy0 * cy1 * cx1 : null, c, k = mode === "stereographic" ? 1 / (1 + cc) : mode === "gnomonic" ? 1 / cc : mode === "equidistant" ? (c = Math.acos(cc), c ? c / Math.sin(c) : 0) : mode === "equalarea" ? Math.sqrt(2 / (1 + cc)) : 1, x = k * cy1 * sx1, y = k * (sy0 * cy1 * cx1 - cy0 * sy1);
      return [ scale * x + translate[0], scale * y + translate[1] ];
    }
    var mode = "orthographic", origin, scale = 200, translate = [ 480, 250 ], x0, y0, cy0, sy0;
    azimuthal.invert = function(coordinates) {
      var x = (coordinates[0] - translate[0]) / scale, y = (coordinates[1] - translate[1]) / scale, p = Math.sqrt(x * x + y * y), c = mode === "stereographic" ? 2 * Math.atan(p) : mode === "gnomonic" ? Math.atan(p) : mode === "equidistant" ? p : mode === "equalarea" ? 2 * Math.asin(.5 * p) : Math.asin(p), sc = Math.sin(c), cc = Math.cos(c);
      return [ (x0 + Math.atan2(x * sc, p * cy0 * cc + y * sy0 * sc)) / d3_geo_radians, Math.asin(cc * sy0 - (p ? y * sc * cy0 / p : 0)) / d3_geo_radians ];
    };
    azimuthal.mode = function(x) {
      if (!arguments.length) return mode;
      mode = x + "";
      return azimuthal;
    };
    azimuthal.origin = function(x) {
      if (!arguments.length) return origin;
      origin = x;
      x0 = origin[0] * d3_geo_radians;
      y0 = origin[1] * d3_geo_radians;
      cy0 = Math.cos(y0);
      sy0 = Math.sin(y0);
      return azimuthal;
    };
    azimuthal.scale = function(x) {
      if (!arguments.length) return scale;
      scale = +x;
      return azimuthal;
    };
    azimuthal.translate = function(x) {
      if (!arguments.length) return translate;
      translate = [ +x[0], +x[1] ];
      return azimuthal;
    };
    return azimuthal.origin([ 0, 0 ]);
  };
  d3.geo.albers = function() {
    function albers(coordinates) {
      var t = n * (d3_geo_radians * coordinates[0] - lng0), p = Math.sqrt(C - 2 * n * Math.sin(d3_geo_radians * coordinates[1])) / n;
      return [ scale * p * Math.sin(t) + translate[0], scale * (p * Math.cos(t) - p0) + translate[1] ];
    }
    function reload() {
      var phi1 = d3_geo_radians * parallels[0], phi2 = d3_geo_radians * parallels[1], lat0 = d3_geo_radians * origin[1], s = Math.sin(phi1), c = Math.cos(phi1);
      lng0 = d3_geo_radians * origin[0];
      n = .5 * (s + Math.sin(phi2));
      C = c * c + 2 * n * s;
      p0 = Math.sqrt(C - 2 * n * Math.sin(lat0)) / n;
      return albers;
    }
    var origin = [ -98, 38 ], parallels = [ 29.5, 45.5 ], scale = 1e3, translate = [ 480, 250 ], lng0, n, C, p0;
    albers.invert = function(coordinates) {
      var x = (coordinates[0] - translate[0]) / scale, y = (coordinates[1] - translate[1]) / scale, p0y = p0 + y, t = Math.atan2(x, p0y), p = Math.sqrt(x * x + p0y * p0y);
      return [ (lng0 + t / n) / d3_geo_radians, Math.asin((C - p * p * n * n) / (2 * n)) / d3_geo_radians ];
    };
    albers.origin = function(x) {
      if (!arguments.length) return origin;
      origin = [ +x[0], +x[1] ];
      return reload();
    };
    albers.parallels = function(x) {
      if (!arguments.length) return parallels;
      parallels = [ +x[0], +x[1] ];
      return reload();
    };
    albers.scale = function(x) {
      if (!arguments.length) return scale;
      scale = +x;
      return albers;
    };
    albers.translate = function(x) {
      if (!arguments.length) return translate;
      translate = [ +x[0], +x[1] ];
      return albers;
    };
    return reload();
  };
  d3.geo.albersUsa = function() {
    function albersUsa(coordinates) {
      var lon = coordinates[0], lat = coordinates[1];
      return (lat > 50 ? alaska : lon < -140 ? hawaii : lat < 21 ? puertoRico : lower48)(coordinates);
    }
    var lower48 = d3.geo.albers();
    var alaska = d3.geo.albers().origin([ -160, 60 ]).parallels([ 55, 65 ]);
    var hawaii = d3.geo.albers().origin([ -160, 20 ]).parallels([ 8, 18 ]);
    var puertoRico = d3.geo.albers().origin([ -60, 10 ]).parallels([ 8, 18 ]);
    albersUsa.scale = function(x) {
      if (!arguments.length) return lower48.scale();
      lower48.scale(x);
      alaska.scale(x * .6);
      hawaii.scale(x);
      puertoRico.scale(x * 1.5);
      return albersUsa.translate(lower48.translate());
    };
    albersUsa.translate = function(x) {
      if (!arguments.length) return lower48.translate();
      var dz = lower48.scale() / 1e3, dx = x[0], dy = x[1];
      lower48.translate(x);
      alaska.translate([ dx - 400 * dz, dy + 170 * dz ]);
      hawaii.translate([ dx - 190 * dz, dy + 200 * dz ]);
      puertoRico.translate([ dx + 580 * dz, dy + 430 * dz ]);
      return albersUsa;
    };
    return albersUsa.scale(lower48.scale());
  };
  d3.geo.bonne = function() {
    function bonne(coordinates) {
      var x = coordinates[0] * d3_geo_radians - x0, y = coordinates[1] * d3_geo_radians - y0;
      if (y1) {
        var p = c1 + y1 - y, E = x * Math.cos(y) / p;
        x = p * Math.sin(E);
        y = p * Math.cos(E) - c1;
      } else {
        x *= Math.cos(y);
        y *= -1;
      }
      return [ scale * x + translate[0], scale * y + translate[1] ];
    }
    var scale = 200, translate = [ 480, 250 ], x0, y0, y1, c1;
    bonne.invert = function(coordinates) {
      var x = (coordinates[0] - translate[0]) / scale, y = (coordinates[1] - translate[1]) / scale;
      if (y1) {
        var c = c1 + y, p = Math.sqrt(x * x + c * c);
        y = c1 + y1 - p;
        x = x0 + p * Math.atan2(x, c) / Math.cos(y);
      } else {
        y *= -1;
        x /= Math.cos(y);
      }
      return [ x / d3_geo_radians, y / d3_geo_radians ];
    };
    bonne.parallel = function(x) {
      if (!arguments.length) return y1 / d3_geo_radians;
      c1 = 1 / Math.tan(y1 = x * d3_geo_radians);
      return bonne;
    };
    bonne.origin = function(x) {
      if (!arguments.length) return [ x0 / d3_geo_radians, y0 / d3_geo_radians ];
      x0 = x[0] * d3_geo_radians;
      y0 = x[1] * d3_geo_radians;
      return bonne;
    };
    bonne.scale = function(x) {
      if (!arguments.length) return scale;
      scale = +x;
      return bonne;
    };
    bonne.translate = function(x) {
      if (!arguments.length) return translate;
      translate = [ +x[0], +x[1] ];
      return bonne;
    };
    return bonne.origin([ 0, 0 ]).parallel(45);
  };
  d3.geo.equirectangular = function() {
    function equirectangular(coordinates) {
      var x = coordinates[0] / 360, y = -coordinates[1] / 360;
      return [ scale * x + translate[0], scale * y + translate[1] ];
    }
    var scale = 500, translate = [ 480, 250 ];
    equirectangular.invert = function(coordinates) {
      var x = (coordinates[0] - translate[0]) / scale, y = (coordinates[1] - translate[1]) / scale;
      return [ 360 * x, -360 * y ];
    };
    equirectangular.scale = function(x) {
      if (!arguments.length) return scale;
      scale = +x;
      return equirectangular;
    };
    equirectangular.translate = function(x) {
      if (!arguments.length) return translate;
      translate = [ +x[0], +x[1] ];
      return equirectangular;
    };
    return equirectangular;
  };
  d3.geo.mercator = function() {
    function mercator(coordinates) {
      var x = coordinates[0] / 360, y = -(Math.log(Math.tan(Math.PI / 4 + coordinates[1] * d3_geo_radians / 2)) / d3_geo_radians) / 360;
      return [ scale * x + translate[0], scale * Math.max(-.5, Math.min(.5, y)) + translate[1] ];
    }
    var scale = 500, translate = [ 480, 250 ];
    mercator.invert = function(coordinates) {
      var x = (coordinates[0] - translate[0]) / scale, y = (coordinates[1] - translate[1]) / scale;
      return [ 360 * x, 2 * Math.atan(Math.exp(-360 * y * d3_geo_radians)) / d3_geo_radians - 90 ];
    };
    mercator.scale = function(x) {
      if (!arguments.length) return scale;
      scale = +x;
      return mercator;
    };
    mercator.translate = function(x) {
      if (!arguments.length) return translate;
      translate = [ +x[0], +x[1] ];
      return mercator;
    };
    return mercator;
  };
  d3.geo.path = function() {
    function path(d, i) {
      if (typeof pointRadius === "function") pointCircle = d3_path_circle(pointRadius.apply(this, arguments));
      pathType(d);
      var result = buffer.length ? buffer.join("") : null;
      buffer = [];
      return result;
    }
    function project(coordinates) {
      return projection(coordinates).join(",");
    }
    function polygonArea(coordinates) {
      var sum = area(coordinates[0]), i = 0, n = coordinates.length;
      while (++i < n) sum -= area(coordinates[i]);
      return sum;
    }
    function polygonCentroid(coordinates) {
      var polygon = d3.geom.polygon(coordinates[0].map(projection)), area = polygon.area(), centroid = polygon.centroid(area < 0 ? (area *= -1, 1) : -1), x = centroid[0], y = centroid[1], z = area, i = 0, n = coordinates.length;
      while (++i < n) {
        polygon = d3.geom.polygon(coordinates[i].map(projection));
        area = polygon.area();
        centroid = polygon.centroid(area < 0 ? (area *= -1, 1) : -1);
        x -= centroid[0];
        y -= centroid[1];
        z -= area;
      }
      return [ x, y, 6 * z ];
    }
    function area(coordinates) {
      return Math.abs(d3.geom.polygon(coordinates.map(projection)).area());
    }
    var pointRadius = 4.5, pointCircle = d3_path_circle(pointRadius), projection = d3.geo.albersUsa(), buffer = [];
    var pathType = d3_geo_type({
      FeatureCollection: function(o) {
        var features = o.features, i = -1, n = features.length;
        while (++i < n) buffer.push(pathType(features[i].geometry));
      },
      Feature: function(o) {
        pathType(o.geometry);
      },
      Point: function(o) {
        buffer.push("M", project(o.coordinates), pointCircle);
      },
      MultiPoint: function(o) {
        var coordinates = o.coordinates, i = -1, n = coordinates.length;
        while (++i < n) buffer.push("M", project(coordinates[i]), pointCircle);
      },
      LineString: function(o) {
        var coordinates = o.coordinates, i = -1, n = coordinates.length;
        buffer.push("M");
        while (++i < n) buffer.push(project(coordinates[i]), "L");
        buffer.pop();
      },
      MultiLineString: function(o) {
        var coordinates = o.coordinates, i = -1, n = coordinates.length, subcoordinates, j, m;
        while (++i < n) {
          subcoordinates = coordinates[i];
          j = -1;
          m = subcoordinates.length;
          buffer.push("M");
          while (++j < m) buffer.push(project(subcoordinates[j]), "L");
          buffer.pop();
        }
      },
      Polygon: function(o) {
        var coordinates = o.coordinates, i = -1, n = coordinates.length, subcoordinates, j, m;
        while (++i < n) {
          subcoordinates = coordinates[i];
          j = -1;
          if ((m = subcoordinates.length - 1) > 0) {
            buffer.push("M");
            while (++j < m) buffer.push(project(subcoordinates[j]), "L");
            buffer[buffer.length - 1] = "Z";
          }
        }
      },
      MultiPolygon: function(o) {
        var coordinates = o.coordinates, i = -1, n = coordinates.length, subcoordinates, j, m, subsubcoordinates, k, p;
        while (++i < n) {
          subcoordinates = coordinates[i];
          j = -1;
          m = subcoordinates.length;
          while (++j < m) {
            subsubcoordinates = subcoordinates[j];
            k = -1;
            if ((p = subsubcoordinates.length - 1) > 0) {
              buffer.push("M");
              while (++k < p) buffer.push(project(subsubcoordinates[k]), "L");
              buffer[buffer.length - 1] = "Z";
            }
          }
        }
      },
      GeometryCollection: function(o) {
        var geometries = o.geometries, i = -1, n = geometries.length;
        while (++i < n) buffer.push(pathType(geometries[i]));
      }
    });
    var areaType = path.area = d3_geo_type({
      FeatureCollection: function(o) {
        var area = 0, features = o.features, i = -1, n = features.length;
        while (++i < n) area += areaType(features[i]);
        return area;
      },
      Feature: function(o) {
        return areaType(o.geometry);
      },
      Polygon: function(o) {
        return polygonArea(o.coordinates);
      },
      MultiPolygon: function(o) {
        var sum = 0, coordinates = o.coordinates, i = -1, n = coordinates.length;
        while (++i < n) sum += polygonArea(coordinates[i]);
        return sum;
      },
      GeometryCollection: function(o) {
        var sum = 0, geometries = o.geometries, i = -1, n = geometries.length;
        while (++i < n) sum += areaType(geometries[i]);
        return sum;
      }
    }, 0);
    var centroidType = path.centroid = d3_geo_type({
      Feature: function(o) {
        return centroidType(o.geometry);
      },
      Polygon: function(o) {
        var centroid = polygonCentroid(o.coordinates);
        return [ centroid[0] / centroid[2], centroid[1] / centroid[2] ];
      },
      MultiPolygon: function(o) {
        var area = 0, coordinates = o.coordinates, centroid, x = 0, y = 0, z = 0, i = -1, n = coordinates.length;
        while (++i < n) {
          centroid = polygonCentroid(coordinates[i]);
          x += centroid[0];
          y += centroid[1];
          z += centroid[2];
        }
        return [ x / z, y / z ];
      }
    });
    path.projection = function(x) {
      projection = x;
      return path;
    };
    path.pointRadius = function(x) {
      if (typeof x === "function") pointRadius = x; else {
        pointRadius = +x;
        pointCircle = d3_path_circle(pointRadius);
      }
      return path;
    };
    return path;
  };
  d3.geo.bounds = function(feature) {
    var left = Infinity, bottom = Infinity, right = -Infinity, top = -Infinity;
    d3_geo_bounds(feature, function(x, y) {
      if (x < left) left = x;
      if (x > right) right = x;
      if (y < bottom) bottom = y;
      if (y > top) top = y;
    });
    return [ [ left, bottom ], [ right, top ] ];
  };
  var d3_geo_boundsTypes = {
    Feature: d3_geo_boundsFeature,
    FeatureCollection: d3_geo_boundsFeatureCollection,
    GeometryCollection: d3_geo_boundsGeometryCollection,
    LineString: d3_geo_boundsLineString,
    MultiLineString: d3_geo_boundsMultiLineString,
    MultiPoint: d3_geo_boundsLineString,
    MultiPolygon: d3_geo_boundsMultiPolygon,
    Point: d3_geo_boundsPoint,
    Polygon: d3_geo_boundsPolygon
  };
  d3.geo.circle = function() {
    function circle() {}
    function visible(point) {
      return arc.distance(point) < radians;
    }
    function clip(coordinates) {
      var i = -1, n = coordinates.length, clipped = [], p0, p1, p2, d0, d1;
      while (++i < n) {
        d1 = arc.distance(p2 = coordinates[i]);
        if (d1 < radians) {
          if (p1) clipped.push(d3_geo_greatArcInterpolate(p1, p2)((d0 - radians) / (d0 - d1)));
          clipped.push(p2);
          p0 = p1 = null;
        } else {
          p1 = p2;
          if (!p0 && clipped.length) {
            clipped.push(d3_geo_greatArcInterpolate(clipped[clipped.length - 1], p1)((radians - d0) / (d1 - d0)));
            p0 = p1;
          }
        }
        d0 = d1;
      }
      p0 = coordinates[0];
      p1 = clipped[0];
      if (p1 && p2[0] === p0[0] && p2[1] === p0[1] && !(p2[0] === p1[0] && p2[1] === p1[1])) {
        clipped.push(p1);
      }
      return resample(clipped);
    }
    function resample(coordinates) {
      var i = 0, n = coordinates.length, j, m, resampled = n ? [ coordinates[0] ] : coordinates, resamples, origin = arc.source();
      while (++i < n) {
        resamples = arc.source(coordinates[i - 1])(coordinates[i]).coordinates;
        for (j = 0, m = resamples.length; ++j < m; ) resampled.push(resamples[j]);
      }
      arc.source(origin);
      return resampled;
    }
    var origin = [ 0, 0 ], degrees = 90 - .01, radians = degrees * d3_geo_radians, arc = d3.geo.greatArc().source(origin).target(d3_identity);
    circle.clip = function(d) {
      if (typeof origin === "function") arc.source(origin.apply(this, arguments));
      return clipType(d) || null;
    };
    var clipType = d3_geo_type({
      FeatureCollection: function(o) {
        var features = o.features.map(clipType).filter(d3_identity);
        return features && (o = Object.create(o), o.features = features, o);
      },
      Feature: function(o) {
        var geometry = clipType(o.geometry);
        return geometry && (o = Object.create(o), o.geometry = geometry, o);
      },
      Point: function(o) {
        return visible(o.coordinates) && o;
      },
      MultiPoint: function(o) {
        var coordinates = o.coordinates.filter(visible);
        return coordinates.length && {
          type: o.type,
          coordinates: coordinates
        };
      },
      LineString: function(o) {
        var coordinates = clip(o.coordinates);
        return coordinates.length && (o = Object.create(o), o.coordinates = coordinates, o);
      },
      MultiLineString: function(o) {
        var coordinates = o.coordinates.map(clip).filter(function(d) {
          return d.length;
        });
        return coordinates.length && (o = Object.create(o), o.coordinates = coordinates, o);
      },
      Polygon: function(o) {
        var coordinates = o.coordinates.map(clip);
        return coordinates[0].length && (o = Object.create(o), o.coordinates = coordinates, o);
      },
      MultiPolygon: function(o) {
        var coordinates = o.coordinates.map(function(d) {
          return d.map(clip);
        }).filter(function(d) {
          return d[0].length;
        });
        return coordinates.length && (o = Object.create(o), o.coordinates = coordinates, o);
      },
      GeometryCollection: function(o) {
        var geometries = o.geometries.map(clipType).filter(d3_identity);
        return geometries.length && (o = Object.create(o), o.geometries = geometries, o);
      }
    });
    circle.origin = function(x) {
      if (!arguments.length) return origin;
      origin = x;
      if (typeof origin !== "function") arc.source(origin);
      return circle;
    };
    circle.angle = function(x) {
      if (!arguments.length) return degrees;
      radians = (degrees = +x) * d3_geo_radians;
      return circle;
    };
    return d3.rebind(circle, arc, "precision");
  };
  d3.geo.greatArc = function() {
    function greatArc() {
      var d = greatArc.distance.apply(this, arguments), t = 0, dt = precision / d, coordinates = [ p0 ];
      while ((t += dt) < 1) coordinates.push(interpolate(t));
      coordinates.push(p1);
      return {
        type: "LineString",
        coordinates: coordinates
      };
    }
    var source = d3_geo_greatArcSource, p0, target = d3_geo_greatArcTarget, p1, precision = 6 * d3_geo_radians, interpolate = d3_geo_greatArcInterpolator();
    greatArc.distance = function() {
      if (typeof source === "function") interpolate.source(p0 = source.apply(this, arguments));
      if (typeof target === "function") interpolate.target(p1 = target.apply(this, arguments));
      return interpolate.distance();
    };
    greatArc.source = function(_) {
      if (!arguments.length) return source;
      source = _;
      if (typeof source !== "function") interpolate.source(p0 = source);
      return greatArc;
    };
    greatArc.target = function(_) {
      if (!arguments.length) return target;
      target = _;
      if (typeof target !== "function") interpolate.target(p1 = target);
      return greatArc;
    };
    greatArc.precision = function(_) {
      if (!arguments.length) return precision / d3_geo_radians;
      precision = _ * d3_geo_radians;
      return greatArc;
    };
    return greatArc;
  };
  d3.geo.greatCircle = d3.geo.circle;
  d3.geom = {};
  d3.geom.contour = function(grid, start) {
    var s = start || d3_geom_contourStart(grid), c = [], x = s[0], y = s[1], dx = 0, dy = 0, pdx = NaN, pdy = NaN, i = 0;
    do {
      i = 0;
      if (grid(x - 1, y - 1)) i += 1;
      if (grid(x, y - 1)) i += 2;
      if (grid(x - 1, y)) i += 4;
      if (grid(x, y)) i += 8;
      if (i === 6) {
        dx = pdy === -1 ? -1 : 1;
        dy = 0;
      } else if (i === 9) {
        dx = 0;
        dy = pdx === 1 ? -1 : 1;
      } else {
        dx = d3_geom_contourDx[i];
        dy = d3_geom_contourDy[i];
      }
      if (dx != pdx && dy != pdy) {
        c.push([ x, y ]);
        pdx = dx;
        pdy = dy;
      }
      x += dx;
      y += dy;
    } while (s[0] != x || s[1] != y);
    return c;
  };
  var d3_geom_contourDx = [ 1, 0, 1, 1, -1, 0, -1, 1, 0, 0, 0, 0, -1, 0, -1, NaN ], d3_geom_contourDy = [ 0, -1, 0, 0, 0, -1, 0, 0, 1, -1, 1, 1, 0, -1, 0, NaN ];
  d3.geom.hull = function(vertices) {
    if (vertices.length < 3) return [];
    var len = vertices.length, plen = len - 1, points = [], stack = [], i, j, h = 0, x1, y1, x2, y2, u, v, a, sp;
    for (i = 1; i < len; ++i) {
      if (vertices[i][1] < vertices[h][1]) {
        h = i;
      } else if (vertices[i][1] == vertices[h][1]) {
        h = vertices[i][0] < vertices[h][0] ? i : h;
      }
    }
    for (i = 0; i < len; ++i) {
      if (i === h) continue;
      y1 = vertices[i][1] - vertices[h][1];
      x1 = vertices[i][0] - vertices[h][0];
      points.push({
        angle: Math.atan2(y1, x1),
        index: i
      });
    }
    points.sort(function(a, b) {
      return a.angle - b.angle;
    });
    a = points[0].angle;
    v = points[0].index;
    u = 0;
    for (i = 1; i < plen; ++i) {
      j = points[i].index;
      if (a == points[i].angle) {
        x1 = vertices[v][0] - vertices[h][0];
        y1 = vertices[v][1] - vertices[h][1];
        x2 = vertices[j][0] - vertices[h][0];
        y2 = vertices[j][1] - vertices[h][1];
        if (x1 * x1 + y1 * y1 >= x2 * x2 + y2 * y2) {
          points[i].index = -1;
        } else {
          points[u].index = -1;
          a = points[i].angle;
          u = i;
          v = j;
        }
      } else {
        a = points[i].angle;
        u = i;
        v = j;
      }
    }
    stack.push(h);
    for (i = 0, j = 0; i < 2; ++j) {
      if (points[j].index !== -1) {
        stack.push(points[j].index);
        i++;
      }
    }
    sp = stack.length;
    for (; j < plen; ++j) {
      if (points[j].index === -1) continue;
      while (!d3_geom_hullCCW(stack[sp - 2], stack[sp - 1], points[j].index, vertices)) {
        --sp;
      }
      stack[sp++] = points[j].index;
    }
    var poly = [];
    for (i = 0; i < sp; ++i) {
      poly.push(vertices[stack[i]]);
    }
    return poly;
  };
  d3.geom.polygon = function(coordinates) {
    coordinates.area = function() {
      var i = 0, n = coordinates.length, a = coordinates[n - 1][0] * coordinates[0][1], b = coordinates[n - 1][1] * coordinates[0][0];
      while (++i < n) {
        a += coordinates[i - 1][0] * coordinates[i][1];
        b += coordinates[i - 1][1] * coordinates[i][0];
      }
      return (b - a) * .5;
    };
    coordinates.centroid = function(k) {
      var i = -1, n = coordinates.length, x = 0, y = 0, a, b = coordinates[n - 1], c;
      if (!arguments.length) k = -1 / (6 * coordinates.area());
      while (++i < n) {
        a = b;
        b = coordinates[i];
        c = a[0] * b[1] - b[0] * a[1];
        x += (a[0] + b[0]) * c;
        y += (a[1] + b[1]) * c;
      }
      return [ x * k, y * k ];
    };
    coordinates.clip = function(subject) {
      var input, i = -1, n = coordinates.length, j, m, a = coordinates[n - 1], b, c, d;
      while (++i < n) {
        input = subject.slice();
        subject.length = 0;
        b = coordinates[i];
        c = input[(m = input.length) - 1];
        j = -1;
        while (++j < m) {
          d = input[j];
          if (d3_geom_polygonInside(d, a, b)) {
            if (!d3_geom_polygonInside(c, a, b)) {
              subject.push(d3_geom_polygonIntersect(c, d, a, b));
            }
            subject.push(d);
          } else if (d3_geom_polygonInside(c, a, b)) {
            subject.push(d3_geom_polygonIntersect(c, d, a, b));
          }
          c = d;
        }
        a = b;
      }
      return subject;
    };
    return coordinates;
  };
  d3.geom.voronoi = function(vertices) {
    var polygons = vertices.map(function() {
      return [];
    });
    d3_voronoi_tessellate(vertices, function(e) {
      var s1, s2, x1, x2, y1, y2;
      if (e.a === 1 && e.b >= 0) {
        s1 = e.ep.r;
        s2 = e.ep.l;
      } else {
        s1 = e.ep.l;
        s2 = e.ep.r;
      }
      if (e.a === 1) {
        y1 = s1 ? s1.y : -1e6;
        x1 = e.c - e.b * y1;
        y2 = s2 ? s2.y : 1e6;
        x2 = e.c - e.b * y2;
      } else {
        x1 = s1 ? s1.x : -1e6;
        y1 = e.c - e.a * x1;
        x2 = s2 ? s2.x : 1e6;
        y2 = e.c - e.a * x2;
      }
      var v1 = [ x1, y1 ], v2 = [ x2, y2 ];
      polygons[e.region.l.index].push(v1, v2);
      polygons[e.region.r.index].push(v1, v2);
    });
    return polygons.map(function(polygon, i) {
      var cx = vertices[i][0], cy = vertices[i][1];
      polygon.forEach(function(v) {
        v.angle = Math.atan2(v[0] - cx, v[1] - cy);
      });
      return polygon.sort(function(a, b) {
        return a.angle - b.angle;
      }).filter(function(d, i) {
        return !i || d.angle - polygon[i - 1].angle > 1e-10;
      });
    });
  };
  var d3_voronoi_opposite = {
    l: "r",
    r: "l"
  };
  d3.geom.delaunay = function(vertices) {
    var edges = vertices.map(function() {
      return [];
    }), triangles = [];
    d3_voronoi_tessellate(vertices, function(e) {
      edges[e.region.l.index].push(vertices[e.region.r.index]);
    });
    edges.forEach(function(edge, i) {
      var v = vertices[i], cx = v[0], cy = v[1];
      edge.forEach(function(v) {
        v.angle = Math.atan2(v[0] - cx, v[1] - cy);
      });
      edge.sort(function(a, b) {
        return a.angle - b.angle;
      });
      for (var j = 0, m = edge.length - 1; j < m; j++) {
        triangles.push([ v, edge[j], edge[j + 1] ]);
      }
    });
    return triangles;
  };
  d3.geom.quadtree = function(points, x1, y1, x2, y2) {
    function insert(n, p, x1, y1, x2, y2) {
      if (isNaN(p.x) || isNaN(p.y)) return;
      if (n.leaf) {
        var v = n.point;
        if (v) {
          if (Math.abs(v.x - p.x) + Math.abs(v.y - p.y) < .01) {
            insertChild(n, p, x1, y1, x2, y2);
          } else {
            n.point = null;
            insertChild(n, v, x1, y1, x2, y2);
            insertChild(n, p, x1, y1, x2, y2);
          }
        } else {
          n.point = p;
        }
      } else {
        insertChild(n, p, x1, y1, x2, y2);
      }
    }
    function insertChild(n, p, x1, y1, x2, y2) {
      var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, right = p.x >= sx, bottom = p.y >= sy, i = (bottom << 1) + right;
      n.leaf = false;
      n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());
      if (right) x1 = sx; else x2 = sx;
      if (bottom) y1 = sy; else y2 = sy;
      insert(n, p, x1, y1, x2, y2);
    }
    var p, i = -1, n = points.length;
    if (n && isNaN(points[0].x)) points = points.map(d3_geom_quadtreePoint);
    if (arguments.length < 5) {
      if (arguments.length === 3) {
        y2 = x2 = y1;
        y1 = x1;
      } else {
        x1 = y1 = Infinity;
        x2 = y2 = -Infinity;
        while (++i < n) {
          p = points[i];
          if (p.x < x1) x1 = p.x;
          if (p.y < y1) y1 = p.y;
          if (p.x > x2) x2 = p.x;
          if (p.y > y2) y2 = p.y;
        }
        var dx = x2 - x1, dy = y2 - y1;
        if (dx > dy) y2 = y1 + dx; else x2 = x1 + dy;
      }
    }
    var root = d3_geom_quadtreeNode();
    root.add = function(p) {
      insert(root, p, x1, y1, x2, y2);
    };
    root.visit = function(f) {
      d3_geom_quadtreeVisit(f, root, x1, y1, x2, y2);
    };
    points.forEach(root.add);
    return root;
  };
  d3.time = {};
  var d3_time = Date, d3_time_daySymbols = [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ];
  d3_time_utc.prototype = {
    getDate: function() {
      return this._.getUTCDate();
    },
    getDay: function() {
      return this._.getUTCDay();
    },
    getFullYear: function() {
      return this._.getUTCFullYear();
    },
    getHours: function() {
      return this._.getUTCHours();
    },
    getMilliseconds: function() {
      return this._.getUTCMilliseconds();
    },
    getMinutes: function() {
      return this._.getUTCMinutes();
    },
    getMonth: function() {
      return this._.getUTCMonth();
    },
    getSeconds: function() {
      return this._.getUTCSeconds();
    },
    getTime: function() {
      return this._.getTime();
    },
    getTimezoneOffset: function() {
      return 0;
    },
    valueOf: function() {
      return this._.valueOf();
    },
    setDate: function() {
      d3_time_prototype.setUTCDate.apply(this._, arguments);
    },
    setDay: function() {
      d3_time_prototype.setUTCDay.apply(this._, arguments);
    },
    setFullYear: function() {
      d3_time_prototype.setUTCFullYear.apply(this._, arguments);
    },
    setHours: function() {
      d3_time_prototype.setUTCHours.apply(this._, arguments);
    },
    setMilliseconds: function() {
      d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);
    },
    setMinutes: function() {
      d3_time_prototype.setUTCMinutes.apply(this._, arguments);
    },
    setMonth: function() {
      d3_time_prototype.setUTCMonth.apply(this._, arguments);
    },
    setSeconds: function() {
      d3_time_prototype.setUTCSeconds.apply(this._, arguments);
    },
    setTime: function() {
      d3_time_prototype.setTime.apply(this._, arguments);
    }
  };
  var d3_time_prototype = Date.prototype;
  var d3_time_formatDateTime = "%a %b %e %H:%M:%S %Y", d3_time_formatDate = "%m/%d/%y", d3_time_formatTime = "%H:%M:%S";
  var d3_time_days = d3_time_daySymbols, d3_time_dayAbbreviations = d3_time_days.map(d3_time_formatAbbreviate), d3_time_months = [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ], d3_time_monthAbbreviations = d3_time_months.map(d3_time_formatAbbreviate);
  d3.time.format = function(template) {
    function format(date) {
      var string = [], i = -1, j = 0, c, f;
      while (++i < n) {
        if (template.charCodeAt(i) == 37) {
          string.push(template.substring(j, i), (f = d3_time_formats[c = template.charAt(++i)]) ? f(date) : c);
          j = i + 1;
        }
      }
      string.push(template.substring(j, i));
      return string.join("");
    }
    var n = template.length;
    format.parse = function(string) {
      var d = {
        y: 1900,
        m: 0,
        d: 1,
        H: 0,
        M: 0,
        S: 0,
        L: 0
      }, i = d3_time_parse(d, template, string, 0);
      if (i != string.length) return null;
      if ("p" in d) d.H = d.H % 12 + d.p * 12;
      var date = new d3_time;
      date.setFullYear(d.y, d.m, d.d);
      date.setHours(d.H, d.M, d.S, d.L);
      return date;
    };
    format.toString = function() {
      return template;
    };
    return format;
  };
  var d3_time_zfill2 = d3.format("02d"), d3_time_zfill3 = d3.format("03d"), d3_time_zfill4 = d3.format("04d"), d3_time_sfill2 = d3.format("2d");
  var d3_time_dayRe = d3_time_formatRe(d3_time_days), d3_time_dayAbbrevRe = d3_time_formatRe(d3_time_dayAbbreviations), d3_time_monthRe = d3_time_formatRe(d3_time_months), d3_time_monthLookup = d3_time_formatLookup(d3_time_months), d3_time_monthAbbrevRe = d3_time_formatRe(d3_time_monthAbbreviations), d3_time_monthAbbrevLookup = d3_time_formatLookup(d3_time_monthAbbreviations);
  var d3_time_formats = {
    a: function(d) {
      return d3_time_dayAbbreviations[d.getDay()];
    },
    A: function(d) {
      return d3_time_days[d.getDay()];
    },
    b: function(d) {
      return d3_time_monthAbbreviations[d.getMonth()];
    },
    B: function(d) {
      return d3_time_months[d.getMonth()];
    },
    c: d3.time.format(d3_time_formatDateTime),
    d: function(d) {
      return d3_time_zfill2(d.getDate());
    },
    e: function(d) {
      return d3_time_sfill2(d.getDate());
    },
    H: function(d) {
      return d3_time_zfill2(d.getHours());
    },
    I: function(d) {
      return d3_time_zfill2(d.getHours() % 12 || 12);
    },
    j: function(d) {
      return d3_time_zfill3(1 + d3.time.dayOfYear(d));
    },
    L: function(d) {
      return d3_time_zfill3(d.getMilliseconds());
    },
    m: function(d) {
      return d3_time_zfill2(d.getMonth() + 1);
    },
    M: function(d) {
      return d3_time_zfill2(d.getMinutes());
    },
    p: function(d) {
      return d.getHours() >= 12 ? "PM" : "AM";
    },
    S: function(d) {
      return d3_time_zfill2(d.getSeconds());
    },
    U: function(d) {
      return d3_time_zfill2(d3.time.sundayOfYear(d));
    },
    w: function(d) {
      return d.getDay();
    },
    W: function(d) {
      return d3_time_zfill2(d3.time.mondayOfYear(d));
    },
    x: d3.time.format(d3_time_formatDate),
    X: d3.time.format(d3_time_formatTime),
    y: function(d) {
      return d3_time_zfill2(d.getFullYear() % 100);
    },
    Y: function(d) {
      return d3_time_zfill4(d.getFullYear() % 1e4);
    },
    Z: d3_time_zone,
    "%": function(d) {
      return "%";
    }
  };
  var d3_time_parsers = {
    a: d3_time_parseWeekdayAbbrev,
    A: d3_time_parseWeekday,
    b: d3_time_parseMonthAbbrev,
    B: d3_time_parseMonth,
    c: d3_time_parseLocaleFull,
    d: d3_time_parseDay,
    e: d3_time_parseDay,
    H: d3_time_parseHour24,
    I: d3_time_parseHour24,
    L: d3_time_parseMilliseconds,
    m: d3_time_parseMonthNumber,
    M: d3_time_parseMinutes,
    p: d3_time_parseAmPm,
    S: d3_time_parseSeconds,
    x: d3_time_parseLocaleDate,
    X: d3_time_parseLocaleTime,
    y: d3_time_parseYear,
    Y: d3_time_parseFullYear
  };
  var d3_time_numberRe = /^\s*\d+/;
  var d3_time_amPmLookup = d3.map({
    am: 0,
    pm: 1
  });
  d3.time.format.utc = function(template) {
    function format(date) {
      try {
        d3_time = d3_time_utc;
        var utc = new d3_time;
        utc._ = date;
        return local(utc);
      } finally {
        d3_time = Date;
      }
    }
    var local = d3.time.format(template);
    format.parse = function(string) {
      try {
        d3_time = d3_time_utc;
        var date = local.parse(string);
        return date && date._;
      } finally {
        d3_time = Date;
      }
    };
    format.toString = local.toString;
    return format;
  };
  var d3_time_formatIso = d3.time.format.utc("%Y-%m-%dT%H:%M:%S.%LZ");
  d3.time.format.iso = Date.prototype.toISOString ? d3_time_formatIsoNative : d3_time_formatIso;
  d3_time_formatIsoNative.parse = function(string) {
    var date = new Date(string);
    return isNaN(date) ? null : date;
  };
  d3_time_formatIsoNative.toString = d3_time_formatIso.toString;
  d3.time.second = d3_time_interval(function(date) {
    return new d3_time(Math.floor(date / 1e3) * 1e3);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 1e3);
  }, function(date) {
    return date.getSeconds();
  });
  d3.time.seconds = d3.time.second.range;
  d3.time.seconds.utc = d3.time.second.utc.range;
  d3.time.minute = d3_time_interval(function(date) {
    return new d3_time(Math.floor(date / 6e4) * 6e4);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 6e4);
  }, function(date) {
    return date.getMinutes();
  });
  d3.time.minutes = d3.time.minute.range;
  d3.time.minutes.utc = d3.time.minute.utc.range;
  d3.time.hour = d3_time_interval(function(date) {
    var timezone = date.getTimezoneOffset() / 60;
    return new d3_time((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 36e5);
  }, function(date) {
    return date.getHours();
  });
  d3.time.hours = d3.time.hour.range;
  d3.time.hours.utc = d3.time.hour.utc.range;
  d3.time.day = d3_time_interval(function(date) {
    var day = new d3_time(1970, 0);
    day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
    return day;
  }, function(date, offset) {
    date.setDate(date.getDate() + offset);
  }, function(date) {
    return date.getDate() - 1;
  });
  d3.time.days = d3.time.day.range;
  d3.time.days.utc = d3.time.day.utc.range;
  d3.time.dayOfYear = function(date) {
    var year = d3.time.year(date);
    return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);
  };
  d3_time_daySymbols.forEach(function(day, i) {
    day = day.toLowerCase();
    i = 7 - i;
    var interval = d3.time[day] = d3_time_interval(function(date) {
      (date = d3.time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);
      return date;
    }, function(date, offset) {
      date.setDate(date.getDate() + Math.floor(offset) * 7);
    }, function(date) {
      var day = d3.time.year(date).getDay();
      return Math.floor((d3.time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);
    });
    d3.time[day + "s"] = interval.range;
    d3.time[day + "s"].utc = interval.utc.range;
    d3.time[day + "OfYear"] = function(date) {
      var day = d3.time.year(date).getDay();
      return Math.floor((d3.time.dayOfYear(date) + (day + i) % 7) / 7);
    };
  });
  d3.time.week = d3.time.sunday;
  d3.time.weeks = d3.time.sunday.range;
  d3.time.weeks.utc = d3.time.sunday.utc.range;
  d3.time.weekOfYear = d3.time.sundayOfYear;
  d3.time.month = d3_time_interval(function(date) {
    date = d3.time.day(date);
    date.setDate(1);
    return date;
  }, function(date, offset) {
    date.setMonth(date.getMonth() + offset);
  }, function(date) {
    return date.getMonth();
  });
  d3.time.months = d3.time.month.range;
  d3.time.months.utc = d3.time.month.utc.range;
  d3.time.year = d3_time_interval(function(date) {
    date = d3.time.day(date);
    date.setMonth(0, 1);
    return date;
  }, function(date, offset) {
    date.setFullYear(date.getFullYear() + offset);
  }, function(date) {
    return date.getFullYear();
  });
  d3.time.years = d3.time.year.range;
  d3.time.years.utc = d3.time.year.utc.range;
  var d3_time_scaleSteps = [ 1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6 ];
  var d3_time_scaleLocalMethods = [ [ d3.time.second, 1 ], [ d3.time.second, 5 ], [ d3.time.second, 15 ], [ d3.time.second, 30 ], [ d3.time.minute, 1 ], [ d3.time.minute, 5 ], [ d3.time.minute, 15 ], [ d3.time.minute, 30 ], [ d3.time.hour, 1 ], [ d3.time.hour, 3 ], [ d3.time.hour, 6 ], [ d3.time.hour, 12 ], [ d3.time.day, 1 ], [ d3.time.day, 2 ], [ d3.time.week, 1 ], [ d3.time.month, 1 ], [ d3.time.month, 3 ], [ d3.time.year, 1 ] ];
  var d3_time_scaleLocalFormats = [ [ d3.time.format("%Y"), function(d) {
    return true;
  } ], [ d3.time.format("%B"), function(d) {
    return d.getMonth();
  } ], [ d3.time.format("%b %d"), function(d) {
    return d.getDate() != 1;
  } ], [ d3.time.format("%a %d"), function(d) {
    return d.getDay() && d.getDate() != 1;
  } ], [ d3.time.format("%I %p"), function(d) {
    return d.getHours();
  } ], [ d3.time.format("%I:%M"), function(d) {
    return d.getMinutes();
  } ], [ d3.time.format(":%S"), function(d) {
    return d.getSeconds();
  } ], [ d3.time.format(".%L"), function(d) {
    return d.getMilliseconds();
  } ] ];
  var d3_time_scaleLinear = d3.scale.linear(), d3_time_scaleLocalFormat = d3_time_scaleFormat(d3_time_scaleLocalFormats);
  d3_time_scaleLocalMethods.year = function(extent, m) {
    return d3_time_scaleLinear.domain(extent.map(d3_time_scaleGetYear)).ticks(m).map(d3_time_scaleSetYear);
  };
  d3.time.scale = function() {
    return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);
  };
  var d3_time_scaleUTCMethods = d3_time_scaleLocalMethods.map(function(m) {
    return [ m[0].utc, m[1] ];
  });
  var d3_time_scaleUTCFormats = [ [ d3.time.format.utc("%Y"), function(d) {
    return true;
  } ], [ d3.time.format.utc("%B"), function(d) {
    return d.getUTCMonth();
  } ], [ d3.time.format.utc("%b %d"), function(d) {
    return d.getUTCDate() != 1;
  } ], [ d3.time.format.utc("%a %d"), function(d) {
    return d.getUTCDay() && d.getUTCDate() != 1;
  } ], [ d3.time.format.utc("%I %p"), function(d) {
    return d.getUTCHours();
  } ], [ d3.time.format.utc("%I:%M"), function(d) {
    return d.getUTCMinutes();
  } ], [ d3.time.format.utc(":%S"), function(d) {
    return d.getUTCSeconds();
  } ], [ d3.time.format.utc(".%L"), function(d) {
    return d.getUTCMilliseconds();
  } ] ];
  var d3_time_scaleUTCFormat = d3_time_scaleFormat(d3_time_scaleUTCFormats);
  d3_time_scaleUTCMethods.year = function(extent, m) {
    return d3_time_scaleLinear.domain(extent.map(d3_time_scaleUTCGetYear)).ticks(m).map(d3_time_scaleUTCSetYear);
  };
  d3.time.scale.utc = function() {
    return d3_time_scale(d3.scale.linear(), d3_time_scaleUTCMethods, d3_time_scaleUTCFormat);
  };
})();
</script>

    <script type="text/javascript">
/*
The MIT License (MIT)

Copyright (c) 2013 bill@bunkat.com

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

    INTERLACE_BLOCKS_VERT_OFFSET = false;
    INTERLACE_BLOCKS_COLOR = false;
    BLOCKS_SHADOW = false;

    /**
     * Allow library to be used within both the browser and node.js
     */
    var ContigData = function(chromosome) {
        return parseData(contig_data[chromosome]);
    };

    var root = typeof exports !== "undefined" && exports !== null ? exports : window;
    root.contigData = ContigData;

    var isContigSizePlot = !chromosome;
    if (chromosome) var data = contigData(chromosome);
    else var data = parseData(contig_data);
    var lanes = data.lanes, items = data.items;

    var w = 0.9 * (window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth) - 300;
    var margin = {
                top: 20, right: 15, bottom: 15, left: /*Math.max(d3.max(lanes, function (d) {
                 return getTextSize(d.label);
                 }), 120)*/ 145
            },
            mainLanesHeight = 45,
            miniLanesHeight = 18,
            miniItemHeight = 10;
            annotationMiniLanesHeight = 18,
            featureMiniHeight = 10,
            annotationLanesHeight = 30,
            featureHeight = 20,
            annotationLanesInterval = 10,
            offsetsY = [0, .3, .15],
            offsetsMiniY = [0, .1, .05],
            lanesInterval = 15,
            miniScale = 50,
            mainScale = 50,
            paleContigsOpacity = .35,
            width = w,
            chartWidth = w,
            miniHeight = lanes.length * miniLanesHeight,
            mainHeight = lanes.length * (mainLanesHeight + lanesInterval),
            coverageHeight = typeof coverage_data != 'undefined' ? 125 : 0;
            coverageSpace = typeof coverage_data != 'undefined' ? 50 : 0;

    var contigsColors = {'N50': '#7437BA', 'N75': '#7437BA', 'NG50': '#B53778', 'NG75': '#B53778'};

    // legend items
    var legendItemWidth = 50;
    var legendItemHeight = 30;
    var legendItemXSpace = 5;
    var legendItemYSpace = 20;
    var legendItemOddOffset = 10;
    var legendTextOffsetX = legendItemWidth + legendItemXSpace * 2;

    var total_len = 0;
    if (!isContigSizePlot) {
      for (var chr in chromosomes_len) {
          total_len += chromosomes_len[chr];
      }
    }
    else total_len = contigs_total_len;
    var x_mini = d3.scale.linear()
            .domain([0, total_len])
            .range([0, chartWidth]);
    var x_main = d3.scale.linear()
            .range([0, chartWidth]);

    var ext = d3.extent(lanes, function (d) {
        return d.id;
    });
    var minBrushExtent = 10;
    var y_main = d3.scale.linear().domain([ext[0], ext[1] + 1]).range([0, mainHeight]);
    var y_mini = d3.scale.linear().domain([ext[0], ext[1] + 1]).range([0, miniHeight]);
    var hideBtnAnnotationsMini, hideBtnAnnotationsMain;

    var letterSize = getSize('w') - 1;
    var numberSize = getSize('0') - 1;

    var annotationsHeight = 0, annotationsMiniHeight = 0;
    if (chromosome) {
      var featuresData = parseFeaturesData(chromosome);
      annotationsHeight = annotationLanesHeight * featuresData.lanes.length;
      annotationsMiniHeight = annotationMiniLanesHeight * featuresData.lanes.length;
      var ext = d3.extent(featuresData.lanes, function (d) {
          return d.id;
      });
      var y_anno_mini = d3.scale.linear().domain([ext[0], ext[1] + 1]).range([0, annotationsMiniHeight]);
      var y_anno = d3.scale.linear().domain([ext[0], ext[1] + 1]).range([0, annotationsHeight]);
    }

    var coverageFactor = 9, maxCovDots = chartWidth;
    var featuresHidden = false, drawCoverage = false, coverageMainHidden = true;
    if (!featuresData || featuresData.features.length == 0)
      featuresHidden = true;
    if (typeof coverage_data != "undefined")
        drawCoverage = true;
    var featuresMainHidden = featuresHidden || lanes.length > 3;
    var brush, brush_cov, brush_anno;

    var spaceAfterMain = 10;
    var spaceAfterTrack = 40;
    var annotationsMainOffsetY = mainHeight + mainScale + (featuresHidden ? 0 : spaceAfterMain);
    var covMainOffsetY = typeof coverage_data != 'undefined' ? (annotationsMainOffsetY +
                            (featuresHidden ? spaceAfterMain : spaceAfterTrack)) : annotationsMainOffsetY;
    if (!featuresMainHidden)
        covMainOffsetY += annotationsHeight;
    var miniOffsetY = covMainOffsetY + spaceAfterTrack;
    var annotationsMiniOffsetY = miniOffsetY + miniHeight + (featuresHidden ? 0 : spaceAfterTrack);
    var covMiniOffsetY = annotationsMiniOffsetY + annotationsMiniHeight + spaceAfterTrack;

    var baseChartHeight = covMiniOffsetY + coverageHeight * 2 + annotationsHeight + margin.top + margin.bottom + 100;
    var curChartHeight = baseChartHeight;

    var manyChromosomes = !isContigSizePlot && chrContigs.length > 1;
    var chrLabelsOffsetY = manyChromosomes ? 6 : 0;

    var chart = d3.select('body').append('div').attr('id', 'chart')
            .append('svg:svg')
            .attr('width', width + margin.right + margin.left)
            .attr('height', curChartHeight)
            .attr('class', 'chart');

    chart.append('defs').append('clipPath')
            .attr('id', 'clip')
            .append('rect')
            .attr('width', width)
            .attr('height', mainHeight + chrLabelsOffsetY);

    var filter = chart.append('defs')
            .append('filter').attr('id', 'shadow');
    filter.append('feOffset').attr('result', 'offOut').attr('in', 'SourceAlpha').attr('dx', '2');
    filter.append('feGaussianBlur').attr('result', 'blurOut').attr('in', 'offOut').attr('stdDeviation', '2');
    filter.append('feBlend').attr('in', 'SourceGraphic').attr('in2', 'blurOut').attr('mode', 'normal');

    var main = chart.append('g')
            .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')')
            .attr('width', chartWidth)
            .attr('height', mainHeight + mainScale)
            .attr('class', 'main');

    var mainOffsetY = 120;

    var hideBtnAnnotationsMiniOffsetY = annotationsMiniOffsetY + mainOffsetY;
    var hideBtnAnnotationsMainOffsetY = annotationsMainOffsetY + mainOffsetY;
    var hideBtnCoverageMiniOffsetY = covMiniOffsetY + mainOffsetY;
    var hideBtnCoverageMainOffsetY = covMainOffsetY + mainOffsetY;

    //annotations track
    if (!featuresHidden) {
        var annotationsMain = chart.append('g')
            .attr('transform', 'translate(' + margin.left + ',' + annotationsMainOffsetY + ')')
            .attr('width', chartWidth)
            .attr('height', annotationLanesHeight)
            .attr('class', 'main')
            .attr('id', 'annotationsMain');
        if (featuresMainHidden)
            annotationsMain.attr('display', 'none')
    }

    var mini = chart.append('g')
            .attr('transform', 'translate(' + margin.left + ',' + miniOffsetY + ')')
            .attr('width', chartWidth)
            .attr('height', miniHeight + miniScale)
            .attr('class', 'main');
    if (!featuresHidden) {
        var annotationsMini = chart.append('g')
            .attr('transform', 'translate(' + margin.left + ',' + annotationsMiniOffsetY + ')')
            .attr('width', chartWidth)
            .attr('height', annotationMiniLanesHeight)
            .attr('class', 'main')
            .attr('id', 'annotationsMini');
    }

    // draw the lanes for the main chart
    main.append('g').selectAll('.laneLines')
            .data(lanes)
            //.enter().append('line')
            .attr('x1', 0)
            .attr('y1', function (d) {
                return d3.round(y_main(d.id)) + .5;
            })
            .attr('x2', chartWidth)
            .attr('y2', function (d) {
                return d3.round(y_main(d.id)) + .5;
            })
            .attr('stroke', function (d) {
                return d.label === '' ? 'white' : 'lightgray'
            });

    var laneLabelOffsetX = 80 + (isContigSizePlot ? 20 : 0);
    main.append('g').selectAll('.laneText')
            .data(lanes)
            .enter().append('text')
            .text(function (d) {
                return getVisibleText(d.label, 180);
            })
            .attr('x', -10)
            .attr('y', function (d) {
                return y_main(d.id + .1);
            })
            .attr('dy', '.5ex')
            .attr('text-anchor', 'end')
            .attr('class', 'laneText')
            .text(function(d) { return d.description; })
            .call(wrap, laneLabelOffsetX, true, !isContigSizePlot, -10, /\n/);

    function addTooltipTspan(displayedText, tspan, width) {
        var visibleLabel = getVisibleText(displayedText, width);
        if (visibleLabel.length < displayedText.length) {
            var fullName = displayedText;
            tspan.on('mouseover',function(d) {
                addTooltip(d, '<span class="lane_tooltip">' + fullName + '</span>');
            });
            tspan.on('mouseout',function(d) {
                removeTooltip();
            });
            displayedText = visibleLabel;
        }
        return displayedText
    }

    function wrap(text, width, cutText, addStdoutLink, offsetX, separator) {
      var stdoutLinkWidth = getSize('(text)') + 10;
      text.each(function() {
          var text = d3.select(this),
              words = text.text().split(separator).reverse(),
              word,
              line = [],
              lineNumber = 0,
              lineHeight = 1.1,
              y = text.attr('y'),
              dy = parseFloat(text.attr('dy')),
              tspan = text.text(null).append('tspan').attr('x', addStdoutLink ? -stdoutLinkWidth : offsetX)
                                    .attr('y', y).attr('dy', dy + 'em')
                                    .style('font-weight', 'bold');
          var firstLine = true;
          while (word = words.pop()) {
            line.push(word);
            var displayedText = line.join(' ');
            tspan.text(displayedText);
            var doCut = firstLine && cutText;
            if ((tspan.node().getComputedTextLength() > width || doCut) && line.length > 1) {
                line.pop();
                displayedText = line.join(' ');
                displayedText = doCut ? addTooltipTspan(line[0], tspan, width) : displayedText;
                tspan.text(displayedText);
                line = [word];
                if (firstLine && addStdoutLink) {
                    linkAdded = true;
                    tspan = text.append('tspan')
                            .attr('x', offsetX)
                            .attr('y', y)
                            .attr('dy', lineNumber * lineHeight + dy + 'em')
                            .attr('text-decoration', 'underline')
                            .attr('fill', '#0000EE')
                            .style("cursor", "pointer")
                            .text('(text)')
                            .on('click',function(d) {
                                window.open(d.link, '_blank');
                                d3.event.stopPropagation();
                            });
                }
                firstLine = false;
                if (word.search("\\+") != -1) {
                    tspan = text.append('tspan')
                                .attr('x', offsetX)
                                .attr('y', y)
                                .attr('dy', ++lineNumber * lineHeight + dy + 'em')
                                .text(word);
                    var msWords = word.split('+');
                    var misassemblies = msWords[0];
                    var extMisassemblies = misassemblies.split(' ')[1];
                    var localMisassemblies = msWords[1];
                    var msTooltip = extMisassemblies + ' extensive + ' + localMisassemblies + ' local misassemblies';
                    tspan.on('mouseover',function(d) {
                        addTooltip(d, '<span class="lane_tooltip">' + msTooltip + '</span>');
                    });
                    tspan.on('mouseout',function(d) {
                        removeTooltip();
                    });
                }
                else {
                    tspan = text.append('tspan')
                                .attr('x', offsetX)
                                .attr('y', y)
                                .attr('dy', ++lineNumber * lineHeight + dy + 'em')
                                .text(word);
                }
            }
            else if (doCut) {
                displayedText = addTooltipTspan(line[0], tspan, width);
                tspan.text(displayedText);
            }
          }
      });
    }

    // draw the lanes for the mini chart
    mini.append('g').selectAll('.laneLines')
            .data(lanes)
            //.enter().append('line')
            .attr('x1', 0)
            .attr('y1', function (d) {
                return d3.round(y_mini(d.id)) + .5;
            })
            .attr('x2', chartWidth)
            .attr('y2', function (d) {
                return d3.round(y_mini(d.id)) + .5;
            })
            .attr('stroke', function (d) {
                return d.label === '' ? 'white' : 'lightgray'
            });

    mini.append('g').selectAll('.laneText')
            .data(lanes)
            .enter().append('text')
            .attr('x', -10)
            .attr('y', function (d) {
                return y_mini(d.id + .5);
            })
            .attr('dy', '.5ex')
            .attr('text-anchor', 'end')
            .attr('class', 'laneText')
            .text(function(d) { return d.label; })
            .call(wrap, 100, true, false, -10, /\n/);

    // draw the lanes for the annotations chart
    if (!featuresHidden) {
        var featurePaths = getFeaturePaths(featuresData.features);
        addFeatureTrackInfo(annotationsMini, y_anno_mini);
        addFeatureTrackInfo(annotationsMain, y_anno);
    }

    var mini_cov, main_cov, x_cov_mini_S, y_cov_main_S, y_cov_main_A, numYTicks;
    if (drawCoverage)
        setupCoverage();
    // draw the x axis
    var xMainAxis, xMiniAxis;
    setupXAxis();

    var centerPos = (x_mini.domain()[1] + x_mini.domain()[0]) / 2;

    // draw a line representing today's date
    main.append('line')
            .attr('y1', 0)
            .attr('y2', mainHeight)
            .attr('class', 'main curSegment')
            .attr('clip-path', 'url(#clip)');

    mini.append('line')
            .attr('x1', x_mini(centerPos) + .5)
            .attr('y1', 0)
            .attr('x2', x_mini(centerPos) + .5)
            .attr('y2', miniHeight)
            .attr('class', 'curSegment');

    var visItems = null;

    // draw the items
    var itemSvgOffsetY = margin.top + document.getElementById('chart').offsetTop;
    var itemsLayer = d3.select('body').append('div').attr('id', 'items')
                                    .append('svg:svg')
                                    .style('position', 'absolute')
                                    .attr('width', width)
                                    .attr('height', mainHeight)
                                    .style('top', itemSvgOffsetY)
                                    .style('left', margin.left);

    itemsLayer.append('rect')
            .attr('pointer-events', 'painted')
            .attr('width', chartWidth)
            .attr('height', mainHeight)
            .attr('visibility', 'hidden')
            .on('click', function (d) {
                coordinates = d3.mouse(this);
                var x = coordinates[0];
                var y = coordinates[1];
                var laneHeight = mainHeight / lanes.length;
                var lane = parseInt(y / laneHeight);
                var laneCoords1 = laneHeight*lane;
                var laneCoords2 = laneHeight*(lane+1);
                var itemToSelect = null;
                var minX = 10;
                var e = itemsContainer.selectAll(".mainItem").filter(function () {
                    var width = this.getBoundingClientRect().width;
                    var curCoords = d3.transform(d3.select(this).attr("transform")).translate;
                    var curY = curCoords[1];
                    if (curY > laneCoords1 && curY < laneCoords2) {
                        var currentx = curCoords[0];
                        if (Math.abs(currentx - x) < 10 || Math.abs(currentx + width - x) < 10 ) {
                            if (Math.abs(currentx - x) < minX) {
                                minX = Math.abs(currentx - x);
                                itemToSelect = d3.select(this);
                                return d3.select(this)
                            }
                        }
                    }
                }); // each
                if (e.length > 0 && itemToSelect) {
                    e = itemToSelect[0].pop();
                    e.__onclick();
                }
    });
    var itemsContainer = itemsLayer.append('g');

    var miniItems = getMiniItems(items);
    miniRects = miniItems.filter(function (block) {
        if (isContigSizePlot && !block.fullContig) return;
        if (!block.path) return block;
    });
    miniPaths = miniItems.filter(function (block) {
        if (block.path) return block;
    });

    mini.append('g').selectAll('miniItems')
            .data(miniRects)
            .enter().append('rect')
            .attr('class', function (block) {
                if (block.text && !block.contig_type) return 'block gradient';
                return 'block miniItem ' + block.objClass;
            })                
            .attr('fill', function (block) {
                if (block.text && !block.contig_type) return addGradient(block, block.text, false);
            })
            .attr('transform', function (block) {
                return 'translate(' + block.start + ', ' + block.y + ')';
            })
            .attr('width', function (block) {
                itemWidth = block.end - block.start;
                return itemWidth;
            })
            .attr('height', miniItemHeight)
            .attr('opacity', function (block) {
                if (block.contig_type == 'small_contigs')
                    return paleContigsOpacity;
                return 1;
            });
    mini.append('g').selectAll('miniItems')
            .data(miniPaths)
            .enter().append('path')
            .attr('class', function (block) {
              return 'mainItem end ' + block.objClass;
            })
            .attr('d', function (block) {
              return block.path;
            });

    var featureTip = d3.select('body').append('div')
                        .attr('class', 'feature_tip')
                        .style('opacity', 0);
    if (!featuresHidden) addFeatureTrackItems(annotationsMini, x_mini);

    addSelectionAreas();

    d3.select('body').on("keypress", keyPressAnswer);
    d3.select('body').on("keydown", keyDownAnswer);

    // draw contig info menu
    var menu = d3.select('body').append('div')
            .attr('id', 'menu');
    menu.append('div')
            .attr('class', ' block title')
            .text('Contig info');
    info = menu.append('div')
            .attr('class', 'block');
    addClickContigText(info);

    // draw legend
    appendLegend();

    var selected_id;
    var prev = undefined;

    var arrows = [];
    var markerWidth = 3,
        markerHeight = 3;
    var markerCircleR = 2,
        markerCircleD = 4;

    chart.append("svg:defs").selectAll("marker")
        .data(["arrow", "arrow_selected"])
        .enter().append("svg:marker")
        .attr("id", function (d) {
            return 'start_' + d })
        .attr("refX", markerCircleR)
        .attr("refY", markerCircleR)
        .attr("markerWidth", markerCircleD)
        .attr("markerHeight", markerCircleD)
        .append("circle")
        .attr("cx", markerCircleR)
        .attr("cy", markerCircleR)
        .attr("r", markerCircleR);
    d3.select('#start_arrow').select('circle').style('fill', '#909090');

    chart.append("svg:defs").selectAll("marker")
        .data(["arrow", "arrow_selected"])
        .enter().append("svg:marker")
        .attr("id", String)
        .attr("viewBox", "0 -5 10 10")
        .attr("refX", 0)
        .attr("refY", 0)
        .attr("markerWidth", markerWidth)
        .attr("markerHeight", markerHeight)
        .attr("orient", "auto")
        .append("svg:path")
        .attr("d", "M0,-5L10,0L0,5");
    d3.select('#arrow').select('path').style('fill', '#777777');

    var separatedLines = [], breakpointLines = [];
    var currentLen = 0;
    if (!isContigSizePlot) {
        if (chrContigs.length > 1) {
            for (var i = 0; i < chrContigs.length; i++) {
                chrName = chrContigs[i];
                chrLen = chromosomes_len[chrName];
                separatedLines.push({name: chrName, corr_start: currentLen, corr_end: currentLen + chrLen,
                               y1: 0, y2: mainHeight + chrLabelsOffsetY, len: chrLen});
                currentLen += chrLen;
            }
        }
    }
    else {
        for (var line = 0; line < contigLines.length; line++) {
            for (var lane = 0; lane < lanes.length; lane++)
                if (lanes[lane].label == contigLines[line].assembly)
                    contigLines[line].lane = lanes[lane].id;
        }
        separatedLines = contigLines;
        breakpointLines = getBreakpointLines();
        for (var i = 0; i < items.length; i++) addGradient(items[i], items[i].marks, true);
        mini.append('g').selectAll('miniItems')
            .data(separatedLines)
            .enter().append('text')
            .attr('class', 'miniItems text')
            .text(function (d) {
                return d.label;
            })
            .style('fill', 'white')
            .attr('transform', function (d) {
                var x = Math.max(x_mini(d.corr_end) - x_mini(d.size) + 1, (x_mini(d.corr_end) - x_mini(d.size) / 2) - getSize(d.label) / 2);
                var y = y_mini(d.lane) + miniLanesHeight - 5;
                return 'translate(' + x + ', ' + y + ')';
            });
    }

    var linesLabelsLayer = d3.select('body').append('div').attr('id', 'lines_labels')
                                    .append('svg:svg')
                                    .style('position', 'absolute')
                                    .attr('width', width)
                                    .attr('height', mainHeight + 20)
                                    .style('top', itemSvgOffsetY - 10)
                                    .style('left', margin.left)
                                    .attr('pointer-events', 'none');
    var itemLabels = linesLabelsLayer.append('g');
    var itemLines = linesLabelsLayer.append('g')
                                    .attr('pointer-events', 'painted');
    var textLayer = itemsLayer.append('g');
    if (!featuresHidden)
      var featurePath = annotationsMain.append('g')
        .attr('clip-path', 'url(#clip)');
    var lineNumberLayer = linesLabelsLayer.append('g')
                            .attr('pointer-events', 'painted');
    var visRectsAndPaths = [];

    if (isContigSizePlot) {
        var drag = d3.behavior.drag()
            .on('dragstart', function () {
                d3.event.sourceEvent.stopPropagation();
            })
             .on('drag', function() {
                d3.event.sourceEvent.stopPropagation();
                if (d3.event.x < 10 || d3.event.x > chartWidth - 10) return;
                lineCountContigs.attr('transform', 'translate(' + d3.event.x + ',10)');
                getNumberOfContigs(d3.event.x);
            });
        var startPos = 400;

        var lineCountContigs = lineNumberLayer.append('g')
                .attr('id', 'countLine')
                .attr('transform', function (d) {
                    return 'translate(' + startPos + ', 10)';
                })
                .attr('width', function (d) {
                    return 5;
                })
                .call(drag);
        lineCountContigs.append('rect')
                .attr('width', function (d) {
                    return 5;
                })
                .attr('height', function (d) {
                    return mainHeight;
                })
                .attr('fill', '#300000');
    }

    display();

    setupInterface();

    getCoordsFromURL();

    function display() {
        x_main = d3.scale.linear()
            .range([0, chartWidth]);
        var rects
                , minExtent = Math.max(brush.extent()[0], x_mini.domain()[0])
                , maxExtent = Math.min(brush.extent()[1], x_mini.domain()[1])
                , visibleText = function (d) {
                    if (!d.name && !d.label) return;
                    var drawLimit = letterSize * 3;
                    if (d.label) {
                       visibleLength = (x_main(d.corr_end) - x_main(minExtent))  + (x_main(maxExtent) - x_main(d.corr_end));
                       if (visibleLength > drawLimit)
                           return getVisibleText(d.label, visibleLength);
                    }
                    var visibleLength = x_main(Math.min(maxExtent, d.corr_end)) - x_main(Math.max(minExtent, d.corr_start)) - 20;
                    if (visibleLength > drawLimit)
                        return getVisibleText(d.name, visibleLength, d.len);
                },
                visibleArrows = arrows.filter(function (d) {
                    if (d.corr_start < maxExtent && d.corr_end > minExtent) return d;
                }),
                visibleLines = separatedLines.filter(function (d) {
                    if (d.corr_end < maxExtent) return d;
                }),
                visibleBreakpointLines = breakpointLines.filter(function (d) {
                    if (d.pos < maxExtent) return d;
                }),
                visibleLinesLabels = separatedLines.filter(function (d) {
                    if (d.name && d.corr_start < maxExtent && d.corr_end > minExtent) return d;
                    if (d.label) {
                        var textSize = d.label.length * letterSize / 2;
                        if (d.label && d.corr_end - textSize > minExtent && d.corr_end + textSize < maxExtent) return d;
                    }
                });
        visItems = items.filter(function (d) {
                if (d.corr_start < maxExtent && d.corr_end > minExtent) {
                    var drawLimit = 1;
                    var visibleLength = x_main(Math.min(maxExtent, d.corr_end)) - x_main(Math.max(minExtent, d.corr_start));
                    if (visibleLength > drawLimit)
                        return d;
                }
            });
        mini.select('.brush').call(brush.extent([minExtent, maxExtent]));
        if (drawCoverage)
            mini_cov.select('.brush').call(brush_cov.extent([minExtent, maxExtent]));
        if (!featuresHidden)
            annotationsMini.select('.brush').call(brush_anno.extent([minExtent, maxExtent]));

        x_main.domain([minExtent, maxExtent]);
        document.getElementById('input_coords').value = Math.round(minExtent) + "-" + Math.round(maxExtent);

        // shift the today line
        main.select('.main.curLine')
                .attr('x1', x_main(centerPos) + .5)
                .attr('x2', x_main(centerPos) + .5);

        mainAxisUpdate();

        //upd arrows
        var shift = 4.03;

        //lines between reference contigs
        linesLabelsLayer.selectAll('.main_lines').remove();
        var lineContigs = itemLines.selectAll('.g')
                .data(visibleLines, function (d) {
                    return d.id;
                });

        var lines = lineContigs.enter().append('g')
                .attr('class', 'main_lines')
                .attr('transform', function (d) {
                    var x = x_main(d.corr_end);
                    var y = d.assembly ? y_main(d.lane) + 10 : 10;

                    return 'translate(' + x + ', ' + y + ')';
                });
        lines.append('rect')
                .attr('width', function (d) {
                    return 1;
                })
                .attr('height', function (d) {
                    return d.assembly ? mainLanesHeight + lanesInterval : d.y2;
                })
                .attr('fill', '#300000');

        //misassemblies breakpoints lines
        linesLabelsLayer.selectAll('.dashed_lines').remove();

        lines = itemLines.selectAll('.g')
                .data(visibleBreakpointLines, function (d) {
                    return d.id;
                })
                .enter().append('g')
                .attr('class', 'dashed_lines')
                .attr('transform', function (d) {
                    return 'translate(' + x_main(d.pos) + ', ' + d.y + ')';
                });
        lines.append('path')
                .attr('d', 'M0,0V' + mainLanesHeight)
                .attr('fill', '#300000');

        //update features
        removeTooltip();
        if (!featuresMainHidden) drawFeaturesMain(minExtent, maxExtent);

        // update the block rects
        visRectsAndPaths = [];
        for (var block = 0; block < visItems.length; block++) {
            visRectsAndPaths.push(visItems[block]);
            if (visItems[block].triangles)
                for (var i = 0; i < visItems[block].triangles.length; i++)
                {
                    var triangle = visItems[block].triangles[i];
                    if ((triangle.misassembledEnds == "R" && triangle.corr_end > maxExtent) ||
                        (triangle.misassembledEnds == "L" && triangle.corr_start < minExtent))
                        continue
                    var w = getItemWidth(triangle);
                    var triangle_width = Math.sqrt(0.5) * mainLanesHeight / 2;
                    if (w > triangle_width * 1.5) visRectsAndPaths.push(triangle);
                }
        }
        var oldItems = itemsContainer.selectAll('.block')
                .data(visRectsAndPaths, function (block) {
                    return block.id;
                })
                .attr('transform', function (block) {
                    return getTranslate(block);
                })
                .attr('width', function (block) {
                    return getItemWidth(block);
                })
                .attr('stroke-opacity', function (block) {
                    return getItemStrokeOpacity(block);
                })
                .attr('stroke-width', function (block) {
                    return getItemStrokeWidth(block);
                })
                .attr('fill-opacity', function (block) {
                    return getItemOpacity(block);
                });
        oldItems.exit().remove();

        var newItems = oldItems.enter().append('g').each(function(itemData) {
            var container = d3.select(this);
            var itemFigure = itemData.misassembledEnds ? container.append('path') : container.append('rect');
            itemFigure.attr('class', function (block) {
                            if (block.misassembledEnds) {
                                if (!block.objClass) block.objClass = 'misassembled';
                                return 'block end ' + block.objClass;
                            }
                            if (!block.marks || block.contig_type)
                                return 'block mainItem ' + block.objClass;
                            else return 'block';
                        })// Define the gradient
                        .attr('fill', function (block) {
                            if (block.marks && !block.contig_type)
                                return addGradient(block, block.marks, true);
                        })
                        .attr('transform', function (block) {
                            return getTranslate(block);
                        })
                        .attr('width', function (block) {
                            return getItemWidth(block);
                        })
                        .attr('height', mainLanesHeight)
                        .attr('stroke', 'black')
                        .attr('stroke-opacity', function (block) {
                            return getItemStrokeOpacity(block);
                        })
                        .attr('stroke-width', function (block) {
                            return getItemStrokeWidth(block);
                        })
                        .attr('fill-opacity', function (block) {
                            return getItemOpacity(block);
                        })
                        .attr('pointer-events', function (block) {
                            return (block.misassembledEnds || block.notActive) ? 'none' : 'painted';
                        })
                        .attr('d', function(block) {
                            if (block.misassembledEnds) return make_triangle(block);
                        });
        });

        function getItemWidth(block) {
            var w = x_main(Math.min(maxExtent, block.corr_end)) - x_main(Math.max(minExtent, block.corr_start));
            return w;
        }

        function getItemStrokeWidth(block) {
            if (block.misassembledEnds) return 0;
            if (block.notActive) return 0;
            return (block.groupId == selected_id ? 2 : 1);
        }

        function getItemStrokeOpacity(block) {
            if (block.misassembledEnds) return 0;
            if (block.notActive) return 0;
            return (block.groupId == selected_id ? 1 : .7);
        }

        function getItemOpacity(block) {
            var defOpacity = 0.65;
            if (block.contig_type == 'small_contigs')
                return paleContigsOpacity;
            if (isContigSizePlot && (!block.contig_type || block.contig_type == 'unaligned'))
                defOpacity = 1;
            if (block.misassembledEnds) return 1;
            if (block.fullContig && block.contig_type && block.contig_type != 'unaligned' && block.contig_type != 'small_contigs')
                return 0.05;
            if (!block || !block.size) return defOpacity;
            return block.size > minContigSize ? defOpacity : paleContigsOpacity;
        }

        function getTranslate(block) {
            if (block.misassembledEnds) {
                var x = block.misassembledEnds == "L" ? x_main(block.corr_start) : x_main(block.corr_end);
                var y = y_main(block.lane) + .25 * lanesInterval;
                if (INTERLACE_BLOCKS_VERT_OFFSET) y += offsetsY[block.order % 3] * lanesInterval;
                if (block.groupId == selected_id) {
                    if (block.misassembledEnds == "L") x += 1;
                    else x += -1;
                }
                return 'translate(' + x + ', ' + y + ')';
            }
            var x = x_main(Math.max(minExtent, block.corr_start));
            var y = y_main(block.lane) + .25 * lanesInterval;
            if (INTERLACE_BLOCKS_VERT_OFFSET) y += offsetsY[block.order % 3] * lanesInterval;
            return 'translate(' + x + ', ' + y + ')';
        }

        if (BLOCKS_SHADOW) other.attr('filter', 'url(#shadow)');

        function make_triangle(block) {
            var startX = 0;
            var startY = block.groupId == selected_id ? 2 : 0;
            if (block.misassembledEnds == "L")
                path = ['M', startX, startY, 'L', startX + (0.5 * (mainLanesHeight - startY) / 2),
                    (startY + (mainLanesHeight - startY)) / 2, 'L', startX, mainLanesHeight - startY, 'L',  startX, startY].join(' ');
            if (block.misassembledEnds == "R")
                path = ['M', startX, startY, 'L', startX - (0.5 * (mainLanesHeight - startY) / 2),
                    (startY + (mainLanesHeight - startY)) / 2, 'L', startX, mainLanesHeight - startY, 'L',  startX, startY].join(' ');
            return path;
        }

        newItems.on('click', function (block) {
                        selected_id = block.groupId;
                        changeInfo(block);
                    })
                .on('mouseenter', glow)
                .on('mouseleave', disglow);
        var prevX = 0;
        var prevLane = -1;
        var visTexts = visRectsAndPaths.filter(function (d) {
            if (!d.name) return;
            var textStart = x_main(Math.max(minExtent, d.corr_start));
            if (textStart - prevX > 20 || d.lane != prevLane) {
                var visWidth = x_main(Math.min(maxExtent, d.corr_end)) - textStart;
                if (visWidth > 20) {
                    textLen = d.name.length * letterSize;
                    prevX = textStart + Math.min(textLen, visWidth) - 30;
                    prevLane = d.lane;
                    return d;
                }
            }
        });
        var texts = textLayer.selectAll('text')
                    .data(visTexts, function (d) {
                        return d.id;
                    })
                    .attr('x', function(d) {
                       return x_main(Math.max(minExtent, d.corr_start)) + 5;
                    })
                    .attr('y', function(d) {
                        var y = y_main(d.lane) + .25 * lanesInterval;
                        if (INTERLACE_BLOCKS_VERT_OFFSET) y += offsetsY[d.order % 3] * lanesInterval;
                        return y + 20;
                    })
                    .text(function(d) {
                        if (!d.size || d.size > minContigSize) return visibleText(d);
                    });
        texts.exit().remove();

        var newTexts = texts.enter().append('text')
                            .attr('class', 'itemLabel')
                            .attr('x', function(d) {
                               return x_main(Math.max(minExtent, d.corr_start)) + 5;
                            })
                            .attr('y', function(d) {
                                var y = y_main(d.lane) + .25 * lanesInterval;
                                if (INTERLACE_BLOCKS_VERT_OFFSET) y += offsetsY[d.order % 3] * lanesInterval;
                                return y + 20;
                            })
                            .text(function(d) {
                                if (!d.size || d.size > minContigSize) return visibleText(d);
                            });
        if (isContigSizePlot)
            getNumberOfContigs(d3.transform(d3.select('#countLine').attr("transform")).translate[0]);

        // upd coverage
        if (drawCoverage && !coverageMainHidden) updateMainCoverage(minExtent, maxExtent, coverageFactor);

        linesLabelsLayer.selectAll('.main_labels').remove();

        var visibleLabels = itemLabels.selectAll('.g')
                            .data(visibleLinesLabels, function (d) {
                                return d.id;
                            });

        var labels = visibleLabels.enter().append('g')
                        .attr('class', 'main_labels')
                        .attr('transform', function (d) {
                            var x = d.label ? x_main(d.corr_end) - d.label.length * letterSize :
                                                   x_main(Math.max(minExtent, d.corr_start)) + 5 ;
                            var y = d.y2 ? d.y2 + 6 : y_main(d.lane) + 13;

                            return 'translate(' + x + ', ' + y + ')';
                        });
        labels.append('rect')
                .attr('class', 'main_labels')
                .attr('height', 15)
                .attr('transform', 'translate(0, -12)');
        labels.append('text')
                .text(visibleText)
                .attr('text-anchor', 'start')
                .attr('class', 'itemLabel');
    }


    function parseData (data) {
        chart = { assemblies: {} };

        for (var assembly in data) {
            var alignments = data[assembly];
            if (!chart.assemblies[assembly])
                chart.assemblies[assembly] = [];
            for (var numAlign = 0; numAlign < alignments.length; numAlign++)
                chart.assemblies[assembly].push(alignments[numAlign]);
        }

        return collapseLanes(chart);
    }

    function getBreakpointLines() {
        var lines = [];
        var contigStart = true;
        var prev_pos = 0;
        var fullsizeBlock = false;
        for (var i = 0; i < items.length; i++) {
        	block = items[i];
            if (block.notActive) {
                if (block.size - (block.corr_end - block.corr_start) < 5) {
                    fullsizeBlock = true;
                    continue;
                }
                fullsizeBlock = false;
            	y = y_main(block.lane) + .25 * lanesInterval + 10;
            	if (!contigStart) {
            		if (Math.abs(prev_pos - block.corr_start) > 2) {
		            	lines.push({pos:block.corr_start, y: y});
            		}
            	}
            	else contigStart = false;
            	prev_pos = block.corr_end;
            	lines.push({pos:block.corr_end, y: y});
            }
            else {
            	contigStart = true;
                if (!fullsizeBlock) lines.pop();
            }
        }
        return lines;
    }

    function isOverlapping (block, lane) {
        if (lane)
            for (var i = 0; i < lane.length; i++)
                if (block.corr_start <= lane[i].corr_end && lane[i].corr_start <= block.corr_end)
                    return true;

        return false;
    }

    function addAssemblyDescription (lanes) {
        for (var laneNum = 0; laneNum < lanes.length; laneNum++) {
            if (lanes[laneNum].label) {
                assemblyName = lanes[laneNum].label;
                var description = assemblyName + '\n';
                description += 'length: ' + assemblies_len[assemblyName] + '\n';
                description += 'contigs: ' + assemblies_contigs[assemblyName] + '\n';
                if (!isContigSizePlot)
                    description += 'misassemblies: ' + assemblies_misassemblies[assemblyName];
                else
                    description += 'N50: ' + assemblies_n50[assemblyName];
                lanes[laneNum].description = description;
                if (!isContigSizePlot)
                    lanes[laneNum].link = assemblies_links[assemblyName];
            }
        }
        return lanes;
    }

    function collapseLanes (chart) {
        var lanes = [], items = [], laneId = 0, itemId = 0, groupId = 0;

        function parseItem(block, fullInfo) {
            block.misassembledEnds = '';
            block.lane = laneId;
            block.id = itemId;
            block.groupId = groupId;
            block.assembly = assemblyName;
            if (isContigSizePlot) {
                if (!fullInfo) {
                    block.corr_start = currentLen;
                    currentLen += block.size;
                    block.corr_end = currentLen;
                    block.fullContig = true;
                }
                else {
                    block.start_in_ref = block.corr_start;
                    block.end_in_ref = block.corr_end;
            	    start_in_contig = Math.min(block.start_in_contig, block.end_in_contig);
            	    end_in_contig = Math.max(block.start_in_contig, block.end_in_contig);
                    block.corr_start = currentLen + start_in_contig - 1;
                    block.corr_end = currentLen + end_in_contig - 1;
                    block.notActive = true;
                    block.contig_type = fullInfo.contig_type;
                }
            }
            block.triangles = Array();
            itemId++;
            numItems++;
            if (block.mis_ends && misassembled_ends) {
                for (var num = 0; num < misassembled_ends.length; num++) {
                    if (!misassembled_ends[num]) continue;
                    var triangleItem = {};
                    triangleItem.name = block.name;
                    triangleItem.corr_start = block.corr_start;
                    triangleItem.corr_end = block.corr_end;
                    triangleItem.assembly = block.assembly;
                    triangleItem.id = itemId;
                    triangleItem.lane = laneId;
                    triangleItem.groupId = groupId;
                    triangleItem.misassembledEnds = misassembled_ends[num];
                    triangleItem.misassemblies = block.misassemblies.split(';')[num];
                    block.triangles.push(triangleItem);
                    itemId++;
                    numItems++;
                }
            }
            return block
        }

        for (var assemblyName in chart.assemblies) {
            var lane = chart.assemblies[assemblyName];
            var currentLen = 0;
            var numItems = 0;
            for (var i = 0; i < lane.length; i++) {
                var block = lane[i];
                if (block.mis_ends) var misassembled_ends = block.mis_ends.split(';');
                if (isContigSizePlot) {
                    var blocks = block.structure;
                    if (blocks) {
                        for (var k = 0; k < blocks.length; k++) {
                            if (blocks[k].contig_type != 'M')
                                items.push(parseItem(blocks[k], block));
                        }
                    }
                }
                items.push(parseItem(block));
                groupId++;
            }

            if (numItems > 0) {
                lanes.push({
                    id: laneId,
                    label: assemblyName
                });
                laneId++;
            }
        }

        addAssemblyDescription(lanes);
        return {lanes: lanes, items: items};
    }

    function addSelectionAreas() {
        brush = drawBrush(mini, miniHeight);
        if (!featuresHidden)
            brush_anno = drawBrush(annotationsMini, annotationsMiniHeight, 'features');
        if (drawCoverage)
            brush_cov = drawBrush(mini_cov, coverageHeight, 'coverage');
    }

    function keyPress (cmd, deltaCoeff) {
        var ext = brush.extent();
        var delta = .01 * (ext[1] - ext[0]);
        if (deltaCoeff) delta *= deltaCoeff;
        delta = Math.max(1, delta);
        switch (cmd) {
            case 'zoom_in':
                if (ext[1] - ext[0] - 2 * delta > minBrushExtent)
                    brush.extent([ext[0] + delta, ext[1] - delta]);
                break;
            case 'zoom_out':
                brush.extent([ext[0] - delta, ext[1] + delta]);
                break;
            case 'left':
                if (ext[0] > 0) brush.extent([ext[0] - delta, ext[1] - delta]);
                break;
            case 'right':
                if (ext[1] < x_mini.domain()[1]) brush.extent([ext[0] + delta, ext[1] + delta]);
                break;
            case 'esc': {
                info.selectAll('p')
                    .remove();
                info.selectAll('span')
                    .remove();
                addClickContigText(info);
                setBaseChartHeight();
                arrows = [];
                mini.selectAll('.arrow').remove();
                mini.selectAll('.arrow_selected').remove();
                removeTooltip();
                selected_id = null;
                break
            }
        }
        itemsContainer.select('.glow').remove();
        display();
    }

    function setBaseChartHeight() {
        curChartHeight = baseChartHeight;
        chart.attr('height', curChartHeight);
    }

    function addClickContigText(info) {
        p = info.append('p');
        p.text('<click on a contig to get details>');
        p.attr('class', 'click_a_contig_text');
    }

    function addTooltip(feature, tooltipText) {
        if (!tooltipText)
            tooltipText = feature ? '<strong>' + (feature.name ? feature.name + ',' : '') + '</strong> <span>' +
                          (feature.id ? ' ID=' + feature.id + ',' : '') + ' coordinates: ' + feature.start + '-' + feature.end + '</span>' : '';
        if (tooltipText && featureTip.html() != tooltipText) {
            featureTip.style('opacity', 1);
            featureTip.html(tooltipText)
                .style('left', (d3.event.pageX - 50) + 'px')
                .style('top', (d3.event.pageY + 5) + 'px');
        }
        else removeTooltip();
    }

    function removeTooltip() {
        featureTip.style('opacity', 0);
        featureTip.html('');
    }

    function setupInterface() {
        document.getElementById('left').onclick=function() {
            keyPress('left', 1) };
        document.getElementById('left_shift').onclick=function() {
            keyPress('left', 5) };
        document.getElementById('right').onclick=function() {
            keyPress('right', 1) };
        document.getElementById('right_shift').onclick=function() {
            keyPress('right', 5) };
        document.getElementById('zoom_in').onclick=function() {
            keyPress('zoom_in', 25) };
        document.getElementById('zoom_in_5').onclick=function() {
            keyPress('zoom_in', 40) };
        document.getElementById('zoom_out').onclick=function() {
            keyPress('zoom_out', 50) };
        document.getElementById('zoom_out_5').onclick=function() {
            keyPress('zoom_out', 200) };

        document.getElementById('input_coords').onkeydown=function(event) {
            enterCoords(event, this) };
        if (document.getElementById('input_contig_threshold')) {
            document.getElementById('input_contig_threshold').value = minContigSize;
            document.getElementById('input_contig_threshold').onkeyup = function(event) {
                setContigSizeThreshold(event, this) };
        }

        var checkboxes = document.getElementsByName('misassemblies_select');
        for(var i = 0; i < checkboxes.length; i++) {
            checkboxes[i].addEventListener('change', function(){
                showMisassemblies();
            });
        }
        if (!featuresHidden) addAnnotationsTrackButtons();
        if (drawCoverage) addCovTrackButtons();
        window.onresize = function(){ location.reload(); }
    }

    function addCovTrackButtons() {
        var hideBtnCoverageMini = document.getElementById('hideBtnCovMini');
        setTrackBtnPos(hideBtnCoverageMini, hideBtnCoverageMiniOffsetY, 'cov', 'mini', true);
        var hideBtnCoverageMain = document.getElementById('hideBtnCovMain');
        setTrackBtnPos(hideBtnCoverageMain, hideBtnCoverageMainOffsetY, 'cov', 'main', false);
    }

    function addAnnotationsTrackButtons() {
        hideBtnAnnotationsMini = document.getElementById('hideBtnAnnoMini');
        setTrackBtnPos(hideBtnAnnotationsMini, hideBtnAnnotationsMiniOffsetY, 'features', 'mini', true);
        hideBtnAnnotationsMain = document.getElementById('hideBtnAnnoMain');
        if (!featuresMainHidden)
            hideBtnAnnotationsMain.innerHTML = "Hide";
        setTrackBtnPos(hideBtnAnnotationsMain, hideBtnAnnotationsMainOffsetY + 6, 'features', 'main', !featuresMainHidden);
    }

    function setTrackBtnPos(hideBtn, offsetY, track, pane, doHide) {
        var hideBtnExpandWidth = 130;
        hideBtn.style.display = "";
        hideBtn.style.left = (margin.left - hideBtnExpandWidth) + "px";
        hideBtn.style.top = offsetY + "px";
        hideBtn.onclick = function() {
            hideTrack(track, pane, doHide);
        };
    }

    function keyPressAnswer() {
        if (d3.event.target.className == 'textBox') return;
        var charCode = d3.event.which || d3.event.keyCode;
        var charStr = String.fromCharCode(charCode);
        if (d3.event.shiftKey) deltaCoeff = 5;
        else deltaCoeff = 1;
        var ext = brush.extent();
        if (charStr == '-' || charStr == '_') // -
            keyPress('zoom_out', deltaCoeff);
        else if (charStr == '+' || charStr == '=') // +
            keyPress('zoom_in', deltaCoeff);
    }

    function keyDownAnswer() {
        var key = d3.event.keyCode;
        if (d3.event.target.className == 'textBox') return;
        if (d3.event.shiftKey) deltaCoeff = 5;
        else deltaCoeff = 1;
        var ext = brush.extent();
        if (key == 39 && x_mini.domain()[1] - ext[0] > minBrushExtent) // >
            keyPress('right', deltaCoeff);
        else if (key == 37 && ext[1] > minBrushExtent) // <
            keyPress('left', deltaCoeff);
        else if (key == 27)
            keyPress('esc');
    }

    function enterCoords(event, textBox) {
        var key = event.keyCode || this.event.keyCode;
        if (key == 27) {
            document.getElementById('input_coords').blur();
        }
        if (key == 13) {
            var coordText = textBox.value;
            var coords = coordText.split('-');
            setCoords(coords);
        }
    }

    var timerAnimationSetCoords;

    function setCoords(coords, animation) {
        var ext = brush.extent();
        var startCoord = ext[0], endCoord = ext[1];
        if (coords.length >= 2 && parseInt(coords[0]) <= parseInt(coords[1])) {
            startCoord = parseInt(coords[0]);
            endCoord = Math.max(parseInt(coords[1]), startCoord + 5);
        }
        else if (coords.length == 1 && parseInt(coords[0])) {
            startCoord = parseInt(coords[0]);
            var brushSize = ext[1] - ext[0];
            endCoord = startCoord + brushSize;
        }
        startCoord = Math.max(0, startCoord);
        endCoord = Math.min(endCoord, x_mini.domain()[1]);
        startCoord = Math.min(startCoord, endCoord - minBrushExtent);
        clearInterval(timerAnimationSetCoords);
        if (animation) {
            var distance = Math.abs(startCoord - ext[0]);
            if (distance < 5) return;
            var distRange = distance / (ext[1] - ext[0]);
            if (distRange < 0.5) {
                brush.extent([startCoord, endCoord]);
                display();
                return
            }
            if (distRange > 50) {
                distRange = distRange * 0.05;
                var zoomDelta = (distRange - 1) * .5 * 100;
                brush.extent([ext[0] - zoomDelta, ext[1] + zoomDelta]);
            }
            var delta = Math.max(5, 0.05 * distance);
            ext = brush.extent();
            var numSteps = Math.max(1, parseInt(distance / delta));
            if (ext[0] > startCoord) delta = -delta;
            delta = (startCoord - ext[0]) / numSteps;
            timerAnimationSetCoords = setInterval(function() {
                ext = [ext[0] + delta, ext[1] + delta];
                if ((delta > 0 && ext[0] >= startCoord) || (delta < 0 && ext[0] <= startCoord)) {
                    clearInterval(timerAnimationSetCoords);
                    brush.extent([startCoord, endCoord]);
                    display();
                    return;
                }
                brush.extent(ext);
                display();
            }, 5)
        }
        else {
            brush.extent([startCoord, endCoord]);
            display();
        }
    }

    function setContigSizeThreshold(event, textBox) {
        var key = event.keyCode || this.event.keyCode;
        if (key == 27) {
            document.getElementById('input_contig_threshold').blur();
        }
        else {
            if (parseInt(textBox.value)) minContigSize = parseInt(textBox.value);
            else if (key == 13) minContigSize = 0;
            //only for contig size plot
            mini.selectAll('.block')
                .attr('opacity', function (d) {
                  if (!d || !d.size) return 1;
                  if (d.contig_type == "small_contigs") return paleContigsOpacity;
                  return d.size > minContigSize ? 1 : paleContigsOpacity;
            });
            display();
        }
    }

    function getNumberOfContigs(x) {
        lineCountContigs.selectAll('g')
                .remove();
        for (var block = 0; block < visRectsAndPaths.length; block++) {
            if (x_main(visRectsAndPaths[block].corr_start) <= x && x <= x_main(visRectsAndPaths[block].corr_end)) {
                var curItem = visRectsAndPaths[block];
                if (curItem.objClass.search("disabled") != -1)
                    continue;
                order = (curItem.order + 1).toString();
                offsetY = y_main(curItem.lane) + mainLanesHeight / 2;
                var suffix = 'th';
                var lastNumber = order.slice(-1);
                if (lastNumber == '1' && order != "11") suffix = 'st';
                else if (lastNumber == '2' && order != "12") suffix = 'nd';
                else if (lastNumber == '3' && order != "13") suffix = 'rd';
                var container = lineCountContigs.append('g')
                        .attr('transform', function (d) {
                            return 'translate(-3, ' + offsetY + ')';
                        })
                        .attr('width', function (d) {
                        });
                var numberLabel = container.append('text')
                        .text(order + suffix + ' contig')
                        .attr('text-anchor', 'end')
                        .attr('class', 'itemLabel');
                var labelRect = numberLabel.node().getBBox();
                container.insert('rect', 'text')
                        .attr('x', labelRect.x - 2)
                        .attr('y', labelRect.y)
                        .attr('height', labelRect.height + 2)
                        .attr('width', labelRect.width + 5)
                        .attr('fill', '#fff');
            }
        }
    }

    function sync(syncBrush, track) {
        var minExtent = Math.max(syncBrush.extent()[0], x_mini.domain()[0]),
                maxExtent = Math.min(syncBrush.extent()[1], x_mini.domain()[1]);
        if (minExtent + minBrushExtent >= x_mini.domain()[1]) minExtent = maxExtent - minBrushExtent;
        if (maxExtent - minExtent < minBrushExtent) maxExtent = minExtent + minBrushExtent;
        brush.extent([minExtent, maxExtent]);
        if (brush_cov && track != 'coverage') brush_cov.extent([minExtent, maxExtent]);
        if (brush_anno && track != 'features') brush_anno.extent([minExtent, maxExtent]);
        display();
    }

    function moveBrush() {
        var origin = d3.mouse(this)
                , point = x_mini.invert(origin[0])
                , halfExtent = (brush.extent()[1] - brush.extent()[0]) / 2
                , begin = point - halfExtent
                , end = point + halfExtent;

        brush.extent([begin, end]);
        if (drawCoverage)
            brush_cov.extent([begin, end]);
        if (!featuresHidden)
            brush_anno.extent([begin, end]);

        display();
    }

    function addGradient(d, marks, gradientExists) {
      if (!marks) return;
      var gradientId = 'gradient' + d.id;
      marks = marks.split(', ');
      if (marks.length == 1) return contigsColors[marks[0]];
      if (gradientExists) return 'url(#' + gradientId + ')';
      var gradient = chart.append("svg:defs")
          .append("svg:linearGradient")
          .attr("id", gradientId);
      gradient.attr("x1", "0%")
              .attr("y1", "0%")
              .attr("x2", "0%")
              .attr("y2", "100%");
      gradientSteps = ["50%", "50%"];

      for (var m = 0; m < marks.length; m++)
        gradient.append("svg:stop")
          .attr("offset", gradientSteps[m])
          .attr("stop-color", contigsColors[marks[m]])
          .attr("stop-opacity", 1);

      return 'url(#' + gradientId + ')';
    }


    function setupXAxis() {
        var mainTickValue;
        xMainAxis = d3.svg.axis()
                .scale(x_main)
                .orient('bottom')
                .tickSize(6, 0, 0);
        addMainXAxis(main, mainHeight + chrLabelsOffsetY);
        var miniTickValue = getTickValue(x_mini.domain()[1]);

        xMiniAxis = appendXAxis(mini, x_mini, miniHeight, miniTickValue);

        mini.append('g')
            .attr('transform', 'translate(0,' + miniHeight + ')')
            .attr('class', 'axis')
            .call(xMiniAxis);

        if (!featuresHidden) {
            addMiniXAxis(annotationsMini, x_mini, annotationsMiniHeight, miniTickValue);
            addMainXAxis(annotationsMain, annotationsHeight);
        }
        if (drawCoverage) {
            addMiniXAxis(mini_cov, x_mini, coverageHeight, miniTickValue);
            addMainXAxis(main_cov, coverageHeight);
        }
    }

    function addMiniXAxis(track, scale, height, tickValue) {
        var axis = appendXAxis(track, scale, height, tickValue);
        track.append('g')
            .attr('transform', 'translate(0,' + height + ')')
            .attr('class', 'axis')
            .call(axis);
    }

    function addMainXAxis(track, trackHeight) {
        track.append('g')
                .attr('transform', 'translate(0,' + trackHeight + ')')
                .attr('class', 'main axis')
                .call(xMainAxis);
    }

    function getTickValue(value) {
        if (value > 1000000000)
          return 'Gbp';
        else if (value > 1000000)
          return 'Mbp';
        else if (value > 1000)
          return 'kbp';
        else
          return 'bp';
    }

    function formatValue(d, tickValue) {
          d = Math.round(d);
          if (tickValue == 'Gbp')
              return d3.round(d / 1000000000, 2);
          else if (tickValue == 'Mbp')
              return d3.round(d / 1000000, 2);
          else if (tickValue == 'kbp')
              return d3.round(d / 1000, 2);
          else
              return d;
      }

    function appendXAxis(lane, scale, laneHeight, tickValue) {
      var ticksValues = scale.ticks(5);
      ticksValues = [scale.domain()[0]].concat(ticksValues);
      ticksValues.push(scale.domain()[1]);

      var min_ticks_delta = Math.max(getTextSize(formatValue(ticksValues.slice(-1)[0], tickValue).toString(), numberSize),
                  getTextSize(formatValue(ticksValues.slice(-2)[0], tickValue).toString(), numberSize));
      if (scale(ticksValues.slice(-1)[0]) - scale(ticksValues.slice(-2)[0]) < min_ticks_delta) {
          ticksValues.splice(-2, 1)
      }

      var xAxis = d3.svg.axis()
            .scale(scale)
            .orient('bottom')
            .tickSize(6, 0, 0)
            .tickValues(ticksValues)
            .tickFormat(function(d) {
              return formatValue(d, tickValue);
            });
      if (!tickValue) return xAxis;

      lane.append('g')
              .attr('transform', 'translate(0,' + laneHeight + ')')
              .attr('class', 'axis')
              .call(xAxis).append('text')
              .attr('transform', 'translate(' + scale(scale.domain()[1]) + ',' + (laneHeight / 2 + 2) + ')');
      var lastTick = lane.select(".axis").selectAll("g")[0].pop();
      var lastTickValue = ticksValues.pop();
      d3.select(lastTick).select('text').text(formatValue(lastTickValue, tickValue) + ' ' + tickValue)
              .attr('transform', 'translate(-10, 0)');
      return xAxis;
    }

    function mainAxisUpdate() {
        var startPos = x_main.domain()[0];
        var endPos = x_main.domain()[1];
        var domain = endPos - startPos;
        mainTickValue = getTickValue(domain);

        xMainAxis.tickFormat(function(tickValue) {
                              return formatValue(startPos + tickValue * domain, mainTickValue);
                            });
        updateTrack(main);
        if (!featuresMainHidden) updateTrack(annotationsMain);
        if (!coverageMainHidden) updateTrack(main_cov);
    }

    function updateTrack(track) {
        track.select('.main.axis').call(xMainAxis);
        var lastTick = track.select(".axis").selectAll("g")[0].pop();
        var textSize = Math.max(0, (formatValue(x_main.domain()[1], mainTickValue).toString().length - 2) * numberSize);
        d3.select(lastTick).select('text').text(formatValue(x_main.domain()[1], mainTickValue) + ' ' + mainTickValue)
                  .attr('transform', 'translate(-' + textSize + ', 0)');
    }

    function drawBrush(track, height, trackName) {
        var offsetY = 7;
        track.append('rect')
                .attr('pointer-events', 'painted')
                .attr('width', chartWidth)
                .attr('height', height)
                .attr('visibility', 'hidden')
                .on('mouseup', moveBrush);

        // draw the selection area
        var delta = (x_mini.domain()[1] - x_mini.domain()[0]) / 16;
        var brushPos = isContigSizePlot ? delta : centerPos;

        var newBrush = d3.svg.brush()
                            .x(x_mini)
                            .extent([brushPos - delta, brushPos + delta])
                            .on("brush", function() {
                                sync(newBrush, trackName)
                            });

        track.append('g')
                        .attr('class', 'x brush')
                        .call(newBrush)
                        .selectAll('rect')
                        .attr('y', -offsetY)
                        .attr('height', height + offsetY);

        track.selectAll('rect.background').remove();
        return newBrush;
    }

    function getNextMaxCovValue(maxY, ticksVals) {
        var factor = ticksVals[1] - ticksVals[0];
        maxY = Math.max(factor, Math.ceil(maxY / factor) * factor);
        return maxY;
    }

    function setupCoverage() {
        numYTicks = 5;
        // draw mini coverage
        x_cov_mini_S = x_mini,      // x coverage scale
        y_max = max_depth[chromosome];

        y_cov_mini_S = d3.scale.linear()
                .domain([y_max, .1])
                .range([0, coverageHeight]);
        y_max = getNextMaxCovValue(y_max, y_cov_mini_S.ticks(numYTicks));
        y_cov_mini_S.domain([y_max, .1]);
        y_cov_main_S = y_cov_mini_S;

        y_cov_mini_A = d3.svg.axis()
                .scale(y_cov_mini_S)
                .orient('left')
                .tickFormat(function(tickValue) {
                    return tickValue;
                })
                .tickSize(2, 0)
                .ticks(numYTicks);
        mini_cov = chart.append('g')
                .attr('class', 'coverage')
                .attr('transform', 'translate(' + margin.left + ', ' + covMiniOffsetY + ')');
        mini_cov.append('g')
                .attr('class', 'y')
                .call(y_cov_mini_A);
        mini_cov.append('text')
                .text('Coverage')
                .attr('transform', 'rotate(-90 20, 80)');

        // draw main coverage
        y_cov_main_A = y_cov_mini_A = d3.svg.axis()
                .scale(y_cov_main_S)
                .orient('left')
                .tickFormat(function(tickValue) {
                    return tickValue;
                })
                .tickSize(2, 0)
                .ticks(numYTicks);

        var x_cov_main_A = xMainAxis;
        main_cov = chart.append('g')
                .attr('class', 'COV')
                .attr('transform', 'translate(' + margin.left + ', ' + covMainOffsetY + ')');

        main_cov.attr('display', 'none');
        main_cov.append('g')
                .attr('class', 'y')
                .attr('transform', 'translate(0, 0)');
        main_cov.select('.y').call(y_cov_main_A);

        drawCoverageLine(x_mini.domain()[0], x_mini.domain()[1], coverageFactor, mini_cov, x_mini);
    }

    function updateMainCoverage(minExtent, maxExtent, coverageFactor) {
        main_cov.select('.covered').remove();
        main_cov.select('.notCovered').remove();
        drawCoverageLine(minExtent, maxExtent, coverageFactor, main_cov, x_main);
        //main_cov.select('.y').call(y_cov_main_A);
    }

    function drawCoverageLine(minExtent, maxExtent, coverageFactor, track, scale) {
        var line = '',
            l = (maxExtent - minExtent) / coverageFactor,
            cov_main_dots_amount = Math.min(maxCovDots, l),
            step = Math.round(l / cov_main_dots_amount);

        var cov_lines = [];
        var nextPos = 0;
        var startPos = Math.floor(minExtent / coverageFactor / step) * step;
        for (var s, i = startPos;; i += step) {
            nextPos = Math.min(maxExtent / coverageFactor, i + step);
            coverage = coverage_data[chromosome].slice(i, i + step);
            if (coverage.length == 0) break;
            s = d3.sum(coverage, function (d) {
                        return d
                    }) / coverage.length;
            //y_max = Math.max(y_max, s);
            if (i == startPos) start = minExtent;
            else start = i * coverageFactor;
            end = nextPos * coverageFactor;
            if (s >= 1)
                cov_lines.push([scale(start), s, scale(end)]);
            else
                cov_lines.push([scale(start), 0, scale(end)]);
            if (nextPos >= (maxExtent / coverageFactor)) break;
        }
        //y_max = getNextMaxCovValue(y_max, y_cov_main_S.ticks(numYTicks));
        //y_cov_main_S.domain([y_max, .1]);
        //y_cov_main_A.scale(y_cov_main_S);

        line += ['M', cov_lines[0][0], y_cov_main_S(0)].join(' ');
        for (i = 0; i < cov_lines.length; i++) {
            cov_line = cov_lines[i];
            line += ['V', y_cov_main_S(cov_line[1])].join(' ');
            line += ['H', cov_line[2]].join(' ');
        }
        line += ['V', y_cov_main_S(0), 'Z'].join(' ');
        track.append('g')
                .attr('class', 'covered')
                .append('path')
                .attr('d', line);

    }

    function getSize(text) {
        var tmp = document.createElement("span");
        tmp.innerHTML = text;
        tmp.style.visibility = "hidden";
        tmp.className = "itemLabel";
        tmp.style.whiteSpace = "nowrap";
        document.body.appendChild(tmp);
        size = tmp.offsetWidth;
        document.body.removeChild(tmp);
        return size;
    }

    // generates a single path for each block class in the mini display
    // ugly - but draws mini 2x faster than append lines or line generator
    // is there a better way to do a bunch of lines as a single path with d3?
    function getMiniItems(items) {
        var result = [];
        var curLane = 0;
        var numItem = 0;

        var countSupplementary = 0;
        for (var c, i = 0; i < items.length; i++) {
            block = items[i];
            if (block.lane != curLane) {
                numItem = 0;
                countSupplementary = 0;
            }
            result.push(createMiniItem(block, curLane, numItem, countSupplementary));
            curLane = block.lane;
            if (!block.notActive) numItem++;
            if (block.triangles && block.triangles.length > 0)
                for (var j = 0; j < block.triangles.length; j++) {
                    result.push(createMiniItem(block.triangles[j], curLane, numItem, countSupplementary));
                    numItem++;
                    countSupplementary++;
                }
        }
        return result;
    }

    function createMiniItem(block, curLane, numItem, countSupplementary) {
        var miniPathHeight = 10;
        var isSmall = x_mini(block.corr_end) - x_mini(block.corr_start) < miniPathHeight;

        block.misassembled = block.misassemblies ? "True" : "False";
        c = (block.misassembled == "False" ? "" : "misassembled");
        c += (block.similar == "True" ? " similar" : "");
        //c += ((!block.misassembledEnds && !isSmall) ? " light_color" : "");
        if (INTERLACE_BLOCKS_COLOR) c += ((numItem - countSupplementary) % 2 == 0 ? " odd" : "");
        var text = '';
        if (isContigSizePlot) {
            if (block.contig_type == "small_contigs") c += " disabled";
            else if (block.contig_type == "unaligned") c += " unaligned";
            else if (block.contig_type == "misassembled") c += " misassembled";
            else if (block.contig_type == "correct") c += "";
            else c += " unknown";
        }

        if (block.marks) {  // NX for contig size plot
          var marks = block.marks;
          text = marks;
          marks = marks.split(', ');
          for (var m = 0; m < marks.length; m++)
            c += " " + marks[m].toLowerCase();
        }

        block.objClass = c;
        block.order = numItem - countSupplementary;

        var startX = block.misassembledEnds == "R" ? x_mini(block.corr_end) : x_mini(block.corr_start);
        var endX = x_mini(block.corr_end);
        var pathEnd = x_mini(block.corr_end);
        var startY = y_mini(block.lane) + .18 * miniLanesHeight;
        if (INTERLACE_BLOCKS_VERT_OFFSET) startY += offsetsMiniY[items[i].order % 3] * miniLanesHeight;
        var path = '';
        if (!isSmall) {
            if (block.misassembledEnds == "L") path = ['M', startX, startY, 'L', startX + (Math.sqrt(3) * miniPathHeight / 2), startY + miniPathHeight / 2,
              'L', startX, startY + miniPathHeight, 'L',  startX, startY].join(' ');
            else if (block.misassembledEnds == "R") path = ['M', startX, startY, 'L', startX - (Math.sqrt(3) * miniPathHeight / 2), startY + miniPathHeight / 2,
              'L', startX, startY + miniPathHeight, 'L',  startX, startY].join(' ');
        }
        return {objClass: block.objClass, path: path, misassemblies: block.misassemblies, misassembledEnds: block.misassembledEnds,
            start: startX, end: endX, y: startY, size: block.size, text: text, id: block.id, contig_type: block.contig_type, fullContig: block.fullContig};
    }

    function getTextSize(text, size) {
        return text.length * size;
    }

    function glow() {
        var selectedItem = d3.select(this).select('rect');
        itemsContainer.append('rect')
                .attr('class', 'glow')
                .attr('pointer-events', 'none')
                .attr('width', selectedItem.attr('width'))
                .attr('height', selectedItem.attr('height'))
                .attr('fill', 'white')
                .attr('opacity', .3)
                .attr('transform', selectedItem.attr('transform'));
    }

    function disglow() {
        itemsContainer.select('.glow').remove();
    }

    function getVisibleText(fullText, l, lenChromosome) {
        var t = '';
        if ((fullText.length - 1) * letterSize > l) {
            t = fullText.slice(0, fullText.length - 1);
            while ((t.length - 1) * letterSize > l && t.length > 3) {
                t = fullText.slice(0, t.length - 1);
            }
        }
        else t = fullText;
        if (lenChromosome && t.length == fullText.length) {
            var t_plus_len = fullText + ' (' + lenChromosome + ' bp)';
            if ((t_plus_len.length - 2)* letterSize <= l) return t_plus_len;
        }
        return (t.length < fullText.length && t.length <= 3 ? '' : t + (t.length >= fullText.length ? '' : '...'));
    }

    function changeInfo(block) {
        info.selectAll('p')
                .remove();

        info.selectAll('span')
                .remove();
        setBaseChartHeight();
        info.append('p')
                .style({'display': 'block', 'word-break': 'break-all', 'word-wrap': 'break-word'})
                .text('Name: ' + block.name, 280);

        if (block.structure) {
            if (isContigSizePlot)
                var contig_type = block.contig_type ? block.contig_type : '';
            else {
                var contig_type = block.misassemblies ? 'misassembled' : 'correct';
                if (block.similar == "True" && !block.misassemblies) contig_type += ' (similar in > 50% of the assemblies)';
                if (block.misassemblies) {
                    var misassemblies = block.misassemblies.split(';');
                    if (misassemblies[0] && misassemblies[1])
                        contig_type += ' (both sides';
                    else if (misassemblies[0])
                        contig_type += ' (left side';
                    else
                        contig_type += ' (right side';

                    if (block.similar == "True") contig_type += ', similar in > 50% of the assemblies';
                    contig_type += ')'
                }
            }
            if (contig_type)
                info.append('p')
                    .text('Type: ' + contig_type);
        }
        if (block.size)
            info.append('p')
                .text('Size: ' + block.size + ' bp');

        var appendPositionElement = function(curBlock, start, end, contigName, assembly, whereAppend,
                                             prev_start, prev_end, is_expanded, overlapped_block) {
            var posVal = function (val) {
                if (mainTickValue == 'Gbp')
                    return d3.round(val / 1000000000, 2);
                else if (mainTickValue == 'Mbp')
                    return d3.round(val / 1000000, 2);
                else if (mainTickValue == 'kbp')
                    return d3.round(val / 1000, 2);
                else
                    return val;
            };
            var format = function (val) {
                val = val.toString();
                for (var i = 3; i < val.length; i += 4 )
                    val = val.slice(0 , val.length - i) + ' ' + val.slice(length - i, val.length);
                return val;
            };

            if (!curBlock) return;
            var ndash = String.fromCharCode(8211);
            if (is_expanded)
                var whereAppendBlock = whereAppend.append('p')
                        .attr('class', 'head_plus collapsed')
                        .on('click', function() {
                            var eventX = d3.event.x || d3.event.clientX;
                            if (eventX < whereAppendBlock[0][0].offsetLeft + 15)
                                openClose(whereAppendBlock[0][0]);
                        });
            else var whereAppendBlock = whereAppend;
            if (is_expanded || !isContigSizePlot) {
                var block = whereAppendBlock.append('span')
                    .attr('class', is_expanded ? 'head' : 'head main')
                    .append('text');
                block.append('tspan')
                    .attr('x', -50)
                    .text('Position: ');
                if (isContigSizePlot) var positionLink = block.append('a');
                else positionLink = block.append('tspan');
                positionLink.attr('id', 'position_link' + numBlock)
                            .style('cursor', 'pointer')
                            .text([posVal(curBlock.start), ndash, posVal(curBlock.end), mainTickValue, ' '].join(' '));
                if (is_expanded && !isContigSizePlot && chrContigs.indexOf(curBlock.chr) != -1)  // chromosome on this screen
                    positionLink.style('text-decoration', 'underline')
                        .style('color', '#7ED5F5')
                        .on('click', function () {
                            var brushExtent = brush.extent();
                            var brushSize = brushExtent[1] - brushExtent[0];
                            if (prev_start && prev_start > curBlock.corr_start) point = curBlock.corr_end;
                            else if (prev_start) point = curBlock.corr_start;
                            setCoords([point - brushSize / 2, point + brushSize / 2], true);
                            for (var i = 0; i < items.length; i++) {
                                if (items[i].assembly == assembly && items[i].name == contigName && 
                                        items[i].corr_start == curBlock.corr_start && items[i].corr_end == curBlock.corr_end) {
                                    selected_id = items[i].groupId;
                                    showArrows(items[i]);
                                    changeInfo(items[i]);
                                    display();
                                    break;
                                }
                            }
                            d3.event.stopPropagation();
                        });
                if (isContigSizePlot) {
                    if (curBlock.start_in_ref) {
                        positionLink.attr('href', (typeof links_to_chromosomes !== 'undefined' ? links_to_chromosomes[curBlock.chr] : 'alignment_viewer') +
                                        '.html?assembly=' + assembly + '&contig=' + contigName  + '&start=' + curBlock.start_in_ref + '&end=' + curBlock.end_in_ref)
                                    .attr('target', '_blank')
                                    .style('text-decoration', 'underline')
                                    .style('color', '#7ED5F5');
                        if (typeof links_to_chromosomes !== 'undefined' && curBlock.chr)
                            positionLink.text(document.getElementById('position_link' + numBlock).textContent + '(' + curBlock.chr + ')');
                    }
                    else {
                        positionLink.text('unaligned');
                        positionLink.style('text-decoration', 'none')
                                    .style('color', 'white');
                    }
                }
                if (is_expanded && !isContigSizePlot) {
                    if (prev_start == start && prev_end == end)
                        block.append('div')
                         .attr('id', 'circle' + start + '_' + end)
                         .attr('class', 'block_circle selected');
                    else
                        block.append('div')
                         .attr('id', 'circle' + start + '_' + end)
                         .attr('class', 'block_circle');
                }
                if (!isContigSizePlot) {
                    if (chrContigs.indexOf(curBlock.chr) == -1) {
                        block.append('a')
                                .attr('href', (typeof links_to_chromosomes !== 'undefined' ? links_to_chromosomes[curBlock.chr] : curBlock.chr) +
                                      '.html?assembly=' + assembly + '&contig=' + contigName  + '&start=' + curBlock.corr_start + '&end=' + curBlock.corr_end)
                                .attr('target', '_blank')
                                .style('text-decoration', 'underline')
                                .style('color', '#7ED5F5')
                                .text('(' + curBlock.chr + ')');
                    }
                    else if (chrContigs.length > 1) {
                        block.append('span')
                                .text('(' + curBlock.chr + ')');
                    }
                }
                block = block.append('p')
                        .attr('class', is_expanded ? 'close' : 'open');
                if (curBlock.start)
                    block.append('p')
                        .text(['reference:',
                            format(curBlock.start), ndash, format(curBlock.end),
                            '(' + format(Math.abs(curBlock.end - curBlock.start) + 1) + ')', 'bp'].join(' '));
                block.append('p')
                        .text(['contig:',
                            format(curBlock.start_in_contig), ndash,  format(curBlock.end_in_contig),
                            '(' + format(Math.abs(curBlock.end_in_contig - curBlock.start_in_contig) + 1) + ')', 'bp'].join(' '));
                if (curBlock.IDY)
                    block.append('p')
                        .text(['IDY:', curBlock.IDY, '%'].join(' '));
                numBlock++;
            }
            
        };
        var numBlock = 0;
        for (var i = 0; i < block.structure.length; i++) {
            var nextBlock = block.structure[i];
            if (nextBlock.contig_type != "M" && block.corr_start == nextBlock.corr_start && nextBlock.corr_end == block.corr_end)
                break;
        }
        appendPositionElement(nextBlock, block.corr_start, block.corr_end, block.name, block.assembly, info);

        showArrows(block);
        if (block.structure && block.structure.length > 0) {
            var blocks = info.append('p')
                    .attr('class', 'head main');
            var blocksText = (block.ambiguous ? 'Alternatives: ' : 'Blocks: ') + block.structure.filter(function(nextBlock) {
                                    if (nextBlock.contig_type != "M") return nextBlock;
                                }).length;
            blocks.text(block.ambiguous ? 'Ambiguously mapped.' : blocksText);
            if (block.ambiguous)
                blocks.append('p')
                      .text(blocksText);

            for (var i = 0; i < block.structure.length; i++) {
                var nextBlock = block.structure[i];
                if (nextBlock.contig_type != "M") {
                    appendPositionElement(nextBlock, nextBlock.corr_start, nextBlock.corr_end, block.name, block.assembly,
                        blocks, block.corr_start, block.corr_end, true);

                    if (block.ambiguous && i < block.structure.length - 1)
                        blocks.append('p')
                              .text('or');
                } else {
                    blocks.append('p')
                            .text(nextBlock.mstype);
                }
            }
        }
        if (block.overlaps && block.overlaps.length > 0) {
            var overlapsInfo = info.append('p')
                .attr('class', 'head main');
            var overlapsText = 'Overlaps with other contigs: ' + block.overlaps.length;
            overlapsInfo.text(overlapsText);

            for (var i = 0; i < block.overlaps.length; i++) {
                var nextBlock = block.overlaps[i];
                appendPositionElement(nextBlock, nextBlock.corr_start,
                    nextBlock.corr_end, nextBlock.contig, block.assembly, overlapsInfo, block.corr_start, block.corr_end, true, nextBlock);
            }
        }
        var blockHeight = info[0][0].offsetHeight;
        curChartHeight += blockHeight;
        chart.attr('height', curChartHeight);
        display();
    }

    function showArrows(block) {
        var verticalShift = -7;
        arrows = [];
        mini.selectAll('.arrow').remove();
        mini.selectAll('.arrow_selected').remove();
        var y = y_mini(block.lane) - 1;

        if (block.structure) {
            for (var i = 0; i < block.structure.length; ++i) {
                var nextBlock = block.structure[i];
                if (nextBlock.contig_type != "M" && !nextBlock.notActive) {
                    if (!(nextBlock.corr_start <= block.corr_start && block.corr_end <= nextBlock.corr_end) &&
                        (isContigSizePlot || chrContigs.indexOf(nextBlock.chr) != -1)) {
                        arrows.push({start: nextBlock.corr_start, end: nextBlock.corr_end, lane: block.lane, selected: false});
                        mini.append('g')
                                .attr('transform', 'translate(' + x_mini((nextBlock.corr_end + nextBlock.corr_start) / 2) + ',' + verticalShift +')')
                                .attr('class', 'arrow')
                                .append("svg:path")
                                .attr("d", 'M0,0V' + (Math.abs(verticalShift) + 1 + block.lane * miniLanesHeight))
                                .attr("class", function () {
                                    return "path arrow";
                                })
                                .attr("marker-start", function () {
                                    return "url(#start_arrow)";
                                })
                                .attr("marker-end", function () {
                                    return "url(#arrow)";
                                });
                    }
                }
            }
        }

        arrows.push({start: block.corr_start, end: block.corr_end, lane: block.lane, selected: true});
        mini.append('g')
                .attr('transform', 'translate(' + x_mini((block.corr_end + block.corr_start) / 2) + ',' + verticalShift +')')
                .attr('class', 'arrow_selected')
                .append("svg:path")
                .attr("d", 'M0,0V' + (Math.abs(verticalShift) + 1 + block.lane * miniLanesHeight))
                .attr("class", function () {
                    return "path arrow_selected";
                })
                .attr("marker-start", function () {
                    return "url(#start_arrow_selected)";
                })
                .attr("marker-end", function () {
                    return "url(#arrow_selected)";
                });
        display();
    }

    function openClose(d) {
        var c = d3.select(d);
        if (c.attr('class') == 'head_plus expanded' || c.attr('class') == 'head_plus collapsed' ){
            c.attr('class', c.attr('class') == 'head_plus expanded' ? 'head_plus collapsed' : 'head_plus expanded');
            p = c.select('span').select('p');
            if (p.attr('class') == 'close') {
                p.attr('class', 'open');
                var blockHeight = c[0][0].offsetHeight;
                curChartHeight += blockHeight;
            }
            else {
                var blockHeight = c[0][0].offsetHeight;
                curChartHeight -= blockHeight;
                p.attr('class', 'close');
            }
            chart.attr('height', curChartHeight);
        }
        d3.event.stopPropagation();
    }

     function showMisassemblies() {
        for (var numItem = 0; numItem < items.length; numItem++) {
            if (items[numItem].misassemblies) {
                items[numItem] = changeMisassembledStatus(items[numItem]);
                if (items[numItem].triangles && items[numItem].triangles.length > 0)
                    for (var i = 0; i < items[numItem].triangles.length; i++) {
                        if (!items[numItem].triangles[i].objClass) items[numItem].triangles[i].objClass = "misassembled";
                        items[numItem].triangles[i] = changeMisassembledStatus(items[numItem].triangles[i]);
                    }
            }
        }
        hideUncheckedMisassemblies(itemsContainer);
        hideUncheckedMisassemblies(chart);
    }

    function changeMisassembledStatus(block) {
        var msTypes = block.misassemblies.split(';');
        var isMisassembled = "False";
        for (var i = 0; i < msTypes.length; i++) {
            if (msTypes[i] && document.getElementById(msTypes[i]).checked) isMisassembled = "True";
        }
        if (isMisassembled == "True" && block.misassembled == "False") {
            block.objClass = block.objClass.replace("disabled", "misassembled");
        }
        else if (isMisassembled == "False")
            block.objClass = block.objClass.replace(/\bmisassembled\b/g, "disabled");
        block.misassembled = isMisassembled;
        return block;
    }

    function hideUncheckedMisassemblies(track) {
        track.selectAll('.block')
            .classed('misassembled', function (block) {
                if (block && block.misassemblies) {
                    if (block.misassembled) return block.misassembled == 'True';
                    return checkMsTypeToShow(block);
                }
            })
            .classed('disabled', function (block) {
                if (block && block.misassemblies) {
                    if (block.misassembled) return block.misassembled != 'True';
                    return !checkMsTypeToShow(block);
                }
            });
        track.selectAll('path')
            .classed('misassembled', function (block) {
                if (block && block.misassemblies)
                    return checkMsTypeToShow(block);
            })
            .classed('disabled', function (block) {
                if (block && block.misassemblies)
                    return !checkMsTypeToShow(block);
            });
    }

    function checkMsTypeToShow(block) {
        var msTypes = block.misassemblies.split(';');
        for (var i = 0; i < msTypes.length; i++) {
            if (msTypes[i] && document.getElementById(msTypes[i]).checked) return true;
        }
        return false;
    }

    function appendLegend() {
        var menu = d3.select('body').append('div')
                .attr('id', 'legend')
                .attr('class', 'expanded');
        var block = menu.append('div')
                .attr('class', 'block')
                .style('float', 'left');
        var header = block.append('p')
                .style('text-align', 'center')
                .style('font-size', '16px')
                .style('margin-top', '5px')
                .text('Legend');
        var legend = block.append('svg:svg')
            .attr('width', "100%")
            .attr('class', 'legend');

        var legendHeight = 0;
        if (isContigSizePlot) legendHeight = appendLegendContigSize(legend);
        else legendHeight = appendLegendAlignmentViewer(legend);
        legend.attr('height', legendHeight);

        header.on('click', function() {
            menu.attr('class', function() {
                return menu.attr('class') == 'collapsed' ? 'expanded' : 'collapsed';
            });
            legend.attr('class', function() {
                return legend.attr('class') == 'collapsed' ? 'expanded' : 'collapsed';
            })
        });
    }

    function appendLegendAlignmentViewer(legend) {
        var classes = ['', 'similar', 'misassembled light_color', 'misassembled', 'misassembled similar', 'disabled', 'annotation'];
        var classDescriptions = ['correct contigs', 'correct contigs similar among > 50% assemblies', 'misassembled blocks ' +
        '(misassembly event on the left side, on the right side)', 'misassembled blocks (zoom in to get details about misassembly event side)',
            'misassembled blocks similar among > 50% assemblies', 'unchecked misassembled blocks (see checkboxes)', 'genome features (e.g. genes)'];
        var prevOffsetY = 0;
        var offsetY = 0;
        for (var numClass = 0; numClass < classes.length; numClass++) {
            offsetY = addLegendItemWithText(legend, prevOffsetY, classes[numClass], classDescriptions[numClass]);
            if (classes[numClass] == 'misassembled light_color') {
                legend.append('path')
                    .attr('transform',  function () {
                        return 'translate(0,' + prevOffsetY + ')';
                    })
                    .attr('class', function () {
                        return 'mainItem end misassembled';
                    })
                    .attr('d', function () {
                        var startX = 0;
                        var startY = 0;
                        path = ['M', startX, startY, 'L', startX + (Math.sqrt(1) * (legendItemHeight - startY) / 2),
                            (startY + (legendItemHeight - startY)) / 2, 'L', startX, legendItemHeight - startY, 'L',  startX, startY].join(' ');
                        return path;
                    });
                legend.append('path')
                    .attr('transform',  function () {
                        return 'translate(' + legendItemWidth + ',' + prevOffsetY + ')';
                    })
                    .attr('class', function () {
                        return 'mainItem end misassembled odd';
                    })
                    .attr('d', function () {
                        var startX = 0;
                        var startY = 0;
                        path = ['M', startX, startY, 'L', startX - (Math.sqrt(1) * (legendItemHeight - startY) / 2),
                            (startY + (legendItemHeight - startY)) / 2, 'L', startX, legendItemHeight - startY, 'L',  startX, startY].join(' ');
                        return path;
                    });
            }
            prevOffsetY = offsetY;
        }
        return offsetY;
    }

    function appendLegendContigSize(legend) {
        if (items[0].contig_type && items[0].contig_type != 'unknown') {
            var classes = ['correct', 'misassembled', 'unaligned'];
            var classMarks = ['', '', ''];
            var classDescriptions = ['correct contigs', 'misassembled contigs', 'unaligned contigs'];
        }
        else {
            var classes = ['unknown', ''];
            var classMarks = ['', 'N50'];
            var classDescriptions = ['contigs', 'contig of length = Nx statistic (x is 50 or 75)'];
            for (var i = 0; i < items.length; i++) {
                if (items[i].marks && items[i].marks.search('NG') != -1) {
                    classes = ['unknown', '', '', ''];
                    classMarks = ['', 'N50', 'NG50', 'N50, NG50'];
                    classDescriptions = ['contigs', 'contig of length = Nx statistic (x is 50 or 75)',
                        'contig of length = NGx statistic (x is 50 or 75)', 'contig of length = Nx and NGx simultaneously'];
                    break;
                }
            }
        }
        var offsetY = 0;
        for (var numClass = 0; numClass < classes.length; numClass++) {
            offsetY = addLegendItemWithText(legend, offsetY, classes[numClass], classDescriptions[numClass], classMarks[numClass])
        }
        return offsetY;
    }

    function addLegendItemWithText(legend, offsetY, className, description, marks) {
        legend.append('g')
                .attr('class', 'block miniItem legend ' + className)
                .append('rect')
                .attr('width', legendItemWidth)
                .attr('height', legendItemHeight)
                .attr('x', 0)
                .attr('y', offsetY)
                .attr('fill', function (d) {
                    d = {id: className};
                    if (marks) return addGradient(d, marks, false);
                });
        legend.append('text')
                .attr('x', legendTextOffsetX)
                .attr('y', offsetY + 5)
                .attr('dy', '.5ex')
                .style('fill', 'white')
                .text(description)
                .call(wrap, 155, false, false, legendTextOffsetX, ' ');
        offsetY += legendItemHeight;
        offsetY += legendItemYSpace;
        offsetY += 10 * Math.max(0, Math.ceil(description.length / 13 - 3));
        return offsetY;
    }

    function parseFeaturesData(chr) {
      var lanes = [];
      var features = [];
      var data = [];
      var laneId = 0, itemId = 0;

      for (var numContainer = 0; numContainer < features_data.length; numContainer++) {
          var lane = features_data[numContainer];
          var numItems = 0;
          for (var i = 0; i < lane.length; i++) {
              if (!oneHtml && lane[i].chr != references_id[chr]) continue;
              var block = lane[i];
              block.lane = laneId;
              block.id = itemId;
              features.push(block);
              itemId++;
              numItems++;
          }
          if (numItems > 0) {
              lanes.push({
                  id: laneId,
                  label: lane[0].kind });
              laneId++;
          }
      }
      return {lanes: lanes, features: features}
    }

    function addFeatureTrackItems(annotations, scale) {
        var annotationsItems = annotations.append('g').selectAll('miniItems')
            .data(featurePaths)
            .enter().append('rect')
            .attr('class', function (d) {
              return d.objClass;
            })
            .attr('transform', function (d) {
              return 'translate(' + d.x + ', ' + d.y + ')';
            })
            .attr('width', function (d) {
              return scale(d.end - d.start);
            })
            .attr('height', featureMiniHeight)
            .on('mouseenter', selectFeature)
            .on('mouseleave', deselectFeature)
            .on('click',  function(d) {
                addTooltip(d);
            });
        var visFeatureTexts = featurePaths.filter(function (d) {
                if (scale(d.end) - scale(d.start) > 45) return d;
        });
        annotations.append('g').selectAll('miniItems')
                            .data(visFeatureTexts)
                            .enter().append('text')
                            .style("font-size", "10px")
                            .text(function (d) { return getVisibleText(d.name ? d.name : 'ID=' + d.id, scale(d.end) - scale(d.start)) } )
                            .attr('class', 'featureLabel')
                            .attr('transform', function (d) {
                              return 'translate(' + (d.x + 3) + ', ' + (d.y + featureMiniHeight / 2 + 3) + ')';
                            });
    }

    function selectFeature() {
        d3.select(this)
                .transition()
                .style({'opacity': .5})
                .select('rect');
    }

    function deselectFeature() {
        d3.select(this)
                .transition()
                .style({'opacity': 1})
                .select('rect');
    }

    function addFeatureTrackInfo (annotations, scale) {
        annotations.append('g').selectAll('.laneLines')
            .data(featuresData.lanes)
            //.enter().append('line')
            .attr('x1', 0)
            .attr('y1', function (d) {
                return d3.round(scale(d.id)) + .5;
            })
            .attr('x2', chartWidth)
            .attr('y2', function (d) {
                return d3.round(scale(d.id)) + .5;
            })
            .attr('stroke', function (d) {
                return d.label === '' ? 'white' : 'lightgray'
            });

        annotations.append('g').selectAll('.laneText')
            .data(featuresData.lanes)
            .enter().append('text')
            .text(function (d) {
                return d.label;
            })
            .attr('x', -10)
            .attr('y', function (d) {
                return scale(d.id + .5);
            })
            .attr('dy', '.5ex')
            .attr('text-anchor', 'end')
            .attr('class', 'laneText');
    }

    function getFeaturePaths(features) {
        var d, result = [];
        var curLane = 0;
        var numItem = 0;

        for (var c, i = 0; i < features.length; i++) {
            d = features[i];
            if (d.lane != curLane) numItem = 0;
            c = "annotation ";
            if (INTERLACE_BLOCKS_COLOR) c += (numItem % 2 == 0 ? "odd" : "");

            features[i].objClass = c;

            var x = x_mini(d.start);
            var y = y_anno_mini(d.lane);
            y += .15 * annotationMiniLanesHeight;
            if (d.objClass.search("odd") != -1)
                y += .04 * annotationMiniLanesHeight;

            result.push({objClass: c, name: d.name, start: d.start, end: d.end, id: d.id_, y: y, x: x, lane: d.lane, order: i});
            curLane = d.lane;
            numItem++;
        }
        return result;
    }

    function drawFeaturesMain(minExtent, maxExtent) {
        var featuresItems = featurePaths.filter(function (d) {
                if (d.start < maxExtent && d.end > minExtent) {
                    var drawLimit = 0;
                    var visibleLength = x_main(Math.min(maxExtent, d.end)) - x_main(Math.max(minExtent, d.start));
                    if (visibleLength > drawLimit)
                        return d;
                }
            });
        var featureRects = featurePath.selectAll('g')
                .data(featuresItems, function (d) {
                    return d.id;
                })
                .attr('transform', function (d) {
                    var x = x_main(Math.max(minExtent, d.start));
                    var y = y_anno(d.lane) + .15 * featureHeight;
                    if (INTERLACE_BLOCKS_VERT_OFFSET) y += offsetsMiniY[d.order % 2] * featureHeight;
                    return 'translate(' + x + ', ' + y + ')';
                })
                .attr('width', function (d) {
                    return x_main(Math.min(maxExtent, d.end)) - x_main(Math.max(minExtent, d.start));
                });

        featureRects.select('.R')
                .attr('width', function (d) {
                    var w = x_main(Math.min(maxExtent, d.end)) - x_main(Math.max(minExtent, d.start));
                    return w;
                })
                .attr('height', function (d) {
                    return featureHeight;
                });
        featureRects.exit().remove();
        featurePath.selectAll('text')
                .remove();

        var otherFeatures = featureRects.enter().append('g')
                .attr('class', function (d) {
                    return d.objClass;
                })
                .attr('transform', function (d) {
                    var x = x_main(Math.max(minExtent, d.start));
                    var y = y_anno(d.lane) + .15 * featureHeight;
                    if (INTERLACE_BLOCKS_VERT_OFFSET) y += offsetsMiniY[d.order % 2] * featureHeight;

                    return 'translate(' + x + ', ' + y + ')';
                })
                .attr('width', function (d) {
                    return x_main(Math.min(maxExtent, d.end)) - x_main(Math.max(minExtent, d.start));
                });

        otherFeatures.append('rect')
                .attr('class', 'R')
                .attr('width', function (d) {
                    var w = x_main(Math.min(maxExtent, d.end)) - x_main(Math.max(minExtent, d.start));
                    return w;
                })
                .attr('height', function (d) {
                    return featureHeight;
                })
                .on('mouseenter', selectFeature)
                .on('mouseleave', deselectFeature)
                .on('click',  function(d) {
                    addTooltip(d);
                });
        var visFeatureTexts = featuresItems.filter(function (d) {
            if (x_main(Math.min(maxExtent, d.end)) - x_main(Math.max(minExtent, d.start)) > 45) return d;
        });
        featurePath.selectAll('text')
            .data(visFeatureTexts, function (d) {
                return d.id;
            })
            .enter().append('text')
            .attr('fill', 'white')
            .attr('class', 'featureLabel')
            .style("font-size", "10px")
            .attr('x', function(d) {
               return x_main(Math.max(minExtent, d.start)) + 2;
            })
            .attr('y', function(d) {
                var y = y_anno(d.lane) + .15 * featureHeight;
                if (INTERLACE_BLOCKS_VERT_OFFSET) y += offsetsMiniY[d.order % 2] * featureHeight;
                return y + featureHeight / 2;
            })
            .text(function(d) {
                var w = x_main(Math.min(maxExtent, d.end)) - x_main(Math.max(minExtent, d.start));
                return getVisibleText(d.name ? d.name : 'ID=' + d.id, w - 10);
            });
    }

    function hideTrack(track, pane, doHide) {
        removeTooltip();
        var hideBtnCoverageMain = document.getElementById('hideBtnCovMain');
        var hideBtnCoverageMini = document.getElementById('hideBtnCovMini');
        var animationDuration = 200, transitionDelay = 150;
        var paneToHide, hideBtn, textToShow, newOffset;
        var changedTracks = [], changedBtns = [];
        var mainPane = (pane == 'main');

        function setBtnTopPos(btn) {
            if (!btn) return;
            btn.style.top = parseInt(btn.style.top) + newOffset + 'px';
        }

        function setTrackPos(track) {
            if (!track) return;
            var trackY = d3.transform(track.attr("transform")).translate[1];
            trackY += newOffset;
            track.transition()
                 .duration(animationDuration)
                 .attr('transform', function(d) {
                    return 'translate(' + margin.left + ',' + trackY + ')'
                 });
        }

        if (track == 'features') {
            textToShow = 'Show annotation';
            paneToHide = mainPane ? annotationsMain : annotationsMini;
            hideBtn = mainPane ? hideBtnAnnotationsMain : hideBtnAnnotationsMini;
            newOffset = mainPane ? annotationsHeight : annotationsMiniHeight;
            if (mainPane) {
                featuresMainHidden = doHide;
                changedTracks = [main_cov, mini, annotationsMini, mini_cov];
                changedBtns = [hideBtnCoverageMain, hideBtnAnnotationsMini, hideBtnCoverageMini];
            }
            else {
                changedTracks = [mini_cov];
                changedBtns = [hideBtnCoverageMini];
            }
        }
        else {
            textToShow = 'Show read coverage';
            paneToHide = mainPane ? main_cov : mini_cov;
            hideBtn = mainPane ? hideBtnCoverageMain : hideBtnCoverageMini;
            newOffset = coverageHeight;
            if (mainPane) {
                coverageMainHidden = doHide;
                changedTracks = [mini, annotationsMini, mini_cov];
                changedBtns = [hideBtnAnnotationsMini, hideBtnCoverageMini];
            }
        }
        if (doHide) newOffset *= -1;
        if (!doHide) textToShow = 'Hide';
        for (var track_n = 0; track_n < changedTracks.length; track_n++)
            setTrackPos(changedTracks[track_n])
        for (var btn_n = 0; btn_n < changedBtns.length; btn_n++)
            setBtnTopPos(changedBtns[btn_n])
        if (doHide) paneToHide.attr('display', 'none');
        else paneToHide.transition().delay(transitionDelay).attr('display', '');
        hideBtn.onclick = function() {
            hideTrack(track, pane, !doHide);
        };
        hideBtn.innerHTML = textToShow;
        display();
    }

    function getCoordsFromURL() {
        var query = document.location.search;
        query = query.split('+').join(' ');

        var params = {},
            tokens,
            re = /[?&]?([^=]+)=([^&]*)/g;

        while (tokens = re.exec(query)) {
            params[decodeURIComponent(tokens[1])] = decodeURIComponent(tokens[2]);
        }
        if (params && params.assembly && params.contig && params.start && params.end) {
            var delta = 1000;
            setCoords([parseInt(params.start) - delta, parseInt(params.end) + delta]);
            for (var i = 0; i < items.length; i++) {
                if (items[i].assembly == params.assembly && items[i].name == params.contig &&
                        items[i].corr_start == params.start && items[i].corr_end == params.end) {
                    selected_id = items[i].groupId;
                    showArrows(items[i]);
                    changeInfo(items[i]);
                    display();
                    break;
                }
            }
        }
        return params;
    }
</script>

</body>
</html>